--Octave Commands--

#
EDITOR
{
`EDITOR' is a built-in function

 -- Built-in Function: VAL = EDITOR ()
 -- Built-in Function: OLD_VAL = EDITOR (NEW_VAL)
     Query or set the internal variable that specifies the editor to
     use with the `edit_history' command.  The default value is taken
     from the environment variable `EDITOR' when Octave starts.  If the
     environment variable is not initialized, `EDITOR' will be set to
     `"emacs"'.

     See also: edit_history
}

#
EXEC_PATH
{
`EXEC_PATH' is a built-in function

 -- Built-in Function: VAL = EXEC_PATH ()
 -- Built-in Function: OLD_VAL = EXEC_PATH (NEW_VAL)
     Query or set the internal variable that specifies a colon separated
     list of directories to search when executing external programs.
     Its initial value is taken from the environment variable
     `OCTAVE_EXEC_PATH' (if it exists) or `PATH', but that value can be
     overridden by the command line argument `--exec-path PATH'.  At
     startup, an additional set of directories (including the shell
     PATH) is appended to the path specified in the environment or on
     the command line.  If you use the `EXEC_PATH' function to modify
     the path, you should take care to preserve these additional
     directories.
}

#
F_DUPFD
{
`F_DUPFD' is a built-in function

 -- Built-in Function:  F_DUPFD ()
     Return the value required to request that `fcntl' return a
     duplicate file descriptor.

     See also: fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL
}

#
F_GETFD
{
`F_GETFD' is a built-in function

 -- Built-in Function:  F_GETFD ()
     Return the value required to request that `fcntl' to return the
     file descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL
}

#
F_GETFL
{
`F_GETFL' is a built-in function

 -- Built-in Function:  F_GETFL ()
     Return the value required to request that `fcntl' to return the
     file status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL
}

#
F_SETFD
{
`F_SETFD' is a built-in function

 -- Built-in Function:  F_SETFD ()
     Return the value required to request that `fcntl' to set the file
     descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL
}

#
F_SETFL
{
`F_SETFL' is a built-in function

 -- Built-in Function:  F_SETFL ()
     Return the value required to request that `fcntl' to set the file
     status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD
}

#
I
{
`I' is a built-in function

 -- Built-in Function:  I
 -- Built-in Function:  I (N)
 -- Built-in Function:  I (N, M)
 -- Built-in Function:  I (N, M, K, ...)
 -- Built-in Function:  I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as `sqrt (-1)'.  I,
     and its equivalents i, J, and j, are functions so any of the names
     may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".
}

#
IMAGE_PATH
{
`IMAGE_PATH' is a built-in function

 -- Built-in Function: VAL = IMAGE_PATH ()
 -- Built-in Function: OLD_VAL = IMAGE_PATH (NEW_VAL)
     Query or set the internal variable that specifies a colon separated
     list of directories in which to search for image files.
}

#
Inf
{
`Inf' is a built-in function

 -- Built-in Function:  Inf
 -- Built-in Function:  Inf (N)
 -- Built-in Function:  Inf (N, M)
 -- Built-in Function:  Inf (N, M, K, ...)
 -- Built-in Function:  Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented
     using the the IEEE floating point format for numbers.  Two common
     examples which produce infinity are division by zero and overflow.
          [1/0 e^800]
          =>
          Inf   Inf

     When called with no arguments, return a scalar with the value
     `Inf'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isinf
}

#
J
{
`J' is a built-in function

 -- Built-in Function:  I
 -- Built-in Function:  I (N)
 -- Built-in Function:  I (N, M)
 -- Built-in Function:  I (N, M, K, ...)
 -- Built-in Function:  I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as `sqrt (-1)'.  I,
     and its equivalents i, J, and j, are functions so any of the names
     may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".
}

#
NA
{
`NA' is a built-in function

 -- Built-in Function:  NA
 -- Built-in Function:  NA (N)
 -- Built-in Function:  NA (N, M)
 -- Built-in Function:  NA (N, M, K, ...)
 -- Built-in Function:  NA (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the special constant used to designate missing values.

     Note that NA always compares not equal to NA (NA != NA).  To find
     NA values, use the `isna' function.

     When called with no arguments, return a scalar with the value `NA'.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: isna
}

#
NaN
{
`NaN' is a built-in function

 -- Built-in Function:  NaN
 -- Built-in Function:  NaN (N)
 -- Built-in Function:  NaN (N, M)
 -- Built-in Function:  NaN (N, M, K, ...)
 -- Built-in Function:  NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the IEEE symbol NaN (Not a Number).  NaN is the
     result of operations which do not produce a well defined numerical
     result.  Common operations which produce a NaN are arithmetic with
     infinity (Inf - Inf), zero divided by zero (0/0), and any
     operation involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN).  This
     behavior is specified by the IEEE standard for floating point
     arithmetic.  To find NaN values, use the `isnan' function.

     When called with no arguments, return a scalar with the value
     `NaN'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isnan
}

#
OCTAVE_HOME
{
`OCTAVE_HOME' is a built-in function

 -- Built-in Function:  OCTAVE_HOME ()
     Return the name of the top-level Octave installation directory.
}

#
OCTAVE_VERSION
{
`OCTAVE_VERSION' is a built-in function

 -- Built-in Function:  OCTAVE_VERSION ()
     Return the version number of Octave, as a string.
}

#
O_APPEND
{
`O_APPEND' is a built-in function

 -- Built-in Function:  O_APPEND ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate each write operation appends, or
     that may be passed to `fcntl' to set the write mode to append.\n
     See also: fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_ASYNC
{
`O_ASYNC' is a built-in function

 -- Built-in Function:  O_ASYNC ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate asynchronous I/O.

     See also: fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_CREAT
{
`O_CREAT' is a built-in function

 -- Built-in Function:  O_CREAT ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that a file should be created if
     it does not exist.

     See also: fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_EXCL
{
`O_EXCL' is a built-in function

 -- Built-in Function:  O_EXCL ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that file locking is used.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_NONBLOCK
{
`O_NONBLOCK' is a built-in function

 -- Built-in Function:  O_NONBLOCK ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that non-blocking I/O is in use,
     or that may be passsed to `fcntl' to set non-blocking I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_RDONLY
{
`O_RDONLY' is a built-in function

 -- Built-in Function:  O_RDONLY ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that a file is open for reading
     only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_RDWR
{
`O_RDWR' is a built-in function

 -- Built-in Function:  O_RDWR ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that a file is open for both
     reading and writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY
}

#
O_SYNC
{
`O_SYNC' is a built-in function

 -- Built-in Function:  O_SYNC ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that a file is open for
     synchronous I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY
}

#
O_TRUNC
{
`O_TRUNC' is a built-in function

 -- Built-in Variable: O_TRUNC ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that if file exists, it should be
     truncated when writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_SYNC, O_WRONLY
}

#
O_WRONLY
{
`O_WRONLY' is a built-in function

 -- Built-in Function:  O_WRONLY ()
     Return the numerical value of the file status flag that may be
     returned by `fcntl' to indicate that a file is open for writing
     only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_SYNC, O_TRUNC
}

#
PAGER
{
`PAGER' is a built-in function

 -- Built-in Function: VAL = PAGER ()
 -- Built-in Function: OLD_VAL = PAGER (NEW_VAL)
     Query or set the internal variable that specifies the program to
     use to display terminal output on your system.  The default value
     is normally `"less"', `"more"', or `"pg"', depending on what
     programs are installed on your system.  *Note Installation::.

     See also: more, page_screen_output, page_output_immediately,
     PAGER_FLAGS
}

#
PAGER_FLAGS
{
`PAGER_FLAGS' is a built-in function

 -- Built-in Function: VAL = PAGER_FLAGS ()
 -- Built-in Function: OLD_VAL = PAGER_FLAGS (NEW_VAL)
     Query or set the internal variable that specifies the options to
     pass to the pager.

     See also: PAGER
}

#
PS1
{
`PS1' is a built-in function

 -- Built-in Function: VAL = PS1 ()
 -- Built-in Function: OLD_VAL = PS1 (NEW_VAL)
     Query or set the primary prompt string.  When executing
     interactively, Octave displays the primary prompt when it is ready
     to read a command.

     The default value of the primary prompt string is `"\s:\#> "'.  To
     change it, use a command like

          octave:13> PS1 ("\\u@\\H> ")

     which will result in the prompt `boris@kremvax> ' for the user
     `boris' logged in on the host `kremvax.kgb.su'.  Note that two
     backslashes are required to enter a backslash into a double-quoted
     character string.  *Note Strings::.

     See also: PS2, PS4
}

#
PS2
{
`PS2' is a built-in function

 -- Built-in Function: VAL = PS2 ()
 -- Built-in Function: OLD_VAL = PS2 (NEW_VAL)
     Query or set the secondary prompt string.  The secondary prompt is
     printed when Octave is expecting additional input to complete a
     command.  For example, if you are typing a `for' loop that spans
     several lines, Octave will print the secondary prompt at the
     beginning of each line after the first.  The default value of the
     secondary prompt string is `"> "'.

     See also: PS1, PS4
}

#
PS4
{
`PS4' is a built-in function

 -- Built-in Function: VAL = PS4 ()
 -- Built-in Function: OLD_VAL = PS4 (NEW_VAL)
     Query or set the character string used to prefix output produced
     when echoing commands is enabled.  The default value is `"+ "'.
     *Note Diary and Echo Commands::, for a description of echoing
     commands.

     See also: echo, echo_executing_commands, PS1, PS2
}

#
P_tmpdir
{
`P_tmpdir' is a built-in function

 -- Built-in Function:  P_tmpdir ()
     Return the default name of the directory for temporary files on
     this system.  The name of this directory is system dependent.
}

#
SEEK_CUR
{
`SEEK_CUR' is a built-in function

 -- Built-in Function:  SEEK_CUR ()
     See SEEK_SET.
}

#
SEEK_END
{
`SEEK_END' is a built-in function

 -- Built-in Function:  SEEK_END ()
     See SEEK_SET.
}

#
SEEK_SET
{
`SEEK_SET' is a built-in function

 -- Built-in Function:  SEEK_SET ()
 -- Built-in Function:  SEEK_CUR ()
 -- Built-in Function:  SEEK_END ()
     Return the value required to request that `fseek' perform one of
     the following actions:
    `SEEK_SET'
          Position file relative to the beginning.

    `SEEK_CUR'
          Position file relative to the current position.

    `SEEK_END'
          Position file relative to the end.
}

#
SIG
{
`SIG' is a built-in function

 -- Built-in Function:  SIG ()
     Return a structure containing Unix signal names and their defined
     values.
}

#
S_ISBLK
{
`S_ISBLK' is a built-in function

 -- Built-in Function:  S_ISBLK (MODE)
     Return true if MODE corresponds to a block device.  The value of
     MODE is assumed to be returned from a call to `stat'.

     See also: stat, lstat
}

#
S_ISCHR
{
`S_ISCHR' is a built-in function

 -- Built-in Function:  S_ISCHR (MODE)
     Return true if MODE corresponds to a character devicey.  The value
     of MODE is assumed to be returned from a call to `stat'.

     See also: stat, lstat
}

#
S_ISDIR
{
`S_ISDIR' is a built-in function

 -- Built-in Function:  S_ISDIR (MODE)
     Return true if MODE corresponds to a directory.  The value of MODE
     is assumed to be returned from a call to `stat'.

     See also: stat, lstat
}

#
S_ISFIFO
{
`S_ISFIFO' is a built-in function

 -- Built-in Function:  S_ISFIFO (MODE)
     Return true if MODE corresponds to a fifo.  The value of MODE is
     assumed to be returned from a call to `stat'.

     See also: stat, lstat
}

#
S_ISLNK
{
`S_ISLNK' is a built-in function

 -- Built-in Function:  S_ISLNK (MODE)
     Return true if MODE corresponds to a symbolic link.  The value of
     MODE is assumed to be returned from a call to `stat'.

     See also: stat, lstat
}

#
S_ISREG
{
`S_ISREG' is a built-in function

 -- Built-in Function:  S_ISREG (MODE)
     Return true if MODE corresponds to a regular file.  The value of
     MODE is assumed to be returned from a call to `stat'.

     See also: stat, lstat
}

#
S_ISSOCK
{
`S_ISSOCK' is a built-in function

 -- Built-in Function:  S_ISSOCK (MODE)
     See also: stat, lstat
}

#
WCONTINUE
{
`WCONTINUE' is a built-in function

 -- Built-in Function: WCONINTUE ()
     Return the numerical value of the option argument that may be
     passed to `waitpid' to indicate that it should also return if a
     stopped child has been resumed by delivery of a `SIGCONT' signal.

     See also: waitpid, WNOHANG, WUNTRACED
}

#
WCOREDUMP
{
`WCOREDUMP' is a built-in function

 -- Built-in Function:  WCOREDUMP (STATUS)
     Given STATUS from a call to `waitpid', return true if the child
     produced a core dump.  This function should only be employed if
     `WIFSIGNALED' returned true.  The macro used to implement this
     function is not specified in POSIX.1-2001 and is not available on
     some Unix implementations (e.g., AIX, SunOS).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED
}

#
WEXITSTATUS
{
`WEXITSTATUS' is a built-in function

 -- Built-in Function:  WEXITSTATUS (STATUS)
     Given STATUS from a call to `waitpid', return the exit status of
     the child.  This function should only be employed if `WIFEXITED'
     returned true.

     See also: waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED
}

#
WIFCONTINUED
{
`WIFCONTINUED' is a built-in function

 -- Built-in Function:  WIFCONTINUED (STATUS)
     Given STATUS from a call to `waitpid', return true if the child
     process was resumed by delivery of `SIGCONT'.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WSTOPSIG
}

#
WIFEXITED
{
`WIFEXITED' is a built-in function

 -- Built-in Function:  WIFEXITED (STATUS)
     Given STATUS from a call to `waitpid', return true if the child
     terminated normally.

     See also: waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED
}

#
WIFSIGNALED
{
`WIFSIGNALED' is a built-in function

 -- Built-in Function:  WIFSIGNALED (STATUS)
     Given STATUS from a call to `waitpid', return true if the child
     process was terminated by a signal.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED
}

#
WIFSTOPPED
{
`WIFSTOPPED' is a built-in function

 -- Built-in Function:  WIFSTOPPED (STATUS)
     Given STATUS from a call to `waitpid', return true if the child
     process was stopped by delivery of a signal; this is only possible
     if the call was done using `WUNTRACED' or when the child is being
     traced (see ptrace(2)).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WSTOPSIG, WIFCONTINUED
}

#
WNOHANG
{
`WNOHANG' is a built-in function

 -- Built-in Function:  WNOHANG ()
     Return the numerical value of the option argument that may be
     passed to `waitpid' to indicate that it should return its status
     immediately instead of waiting for a process to exit.

     See also: waitpid, WUNTRACED, WCONTINUE
}

#
WSTOPSIG
{
`WSTOPSIG' is a built-in function

 -- Built-in Function:  WSTOPSIG (STATUS)
     Given STATUS from a call to `waitpid', return the number of the
     signal which caused the child to stop.  This function should only
     be employed if `WIFSTOPPED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WIFCONTINUED
}

#
WTERMSIG
{
`WTERMSIG' is a built-in function

 -- Built-in Function:  WTERMSIG (STATUS)
     Given STATUS from a call to `waitpid', return the number of the
     signal that caused the child process to terminate.  This function
     should only be employed if `WIFSIGNALED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED
}

#
WUNTRACED
{
`WUNTRACED' is a built-in function

 -- Built-in Function:  WUNTRACED ()
     Return the numerical value of the option argument that may be
     passed to `waitpid' to indicate that it should also return if the
     child process has stopped but is not traced via the `ptrace'
     system call

     See also: waitpid, WNOHANG, WCONTINUE
}

#
__accumarray_sum__
{
`__accumarray_sum__' is a built-in function

 -- Built-in Function:  __accumarray_sum__ (IDX, VALS, N)
     Undocumented internal function.
}

#
__actual_axis_position__
{
`__actual_axis_position__' is a function from the file /usr/share/octave/3.2.3/m/plot/__actual_axis_position__.m

 -- Function File:  __actual_axis_position__ (H)
 -- Function File:  __actual_axis_position__ (AXIS_STRUCT)
     Undocumented internal function.
}

#
__add_datasource__
{
`__add_datasource__' is a function from the file /usr/share/octave/3.2.3/m/plot/__add_datasource__.m

 -- Function File: NEWARGS = __add_datasource__ (FCN, H, DATA, VARARGIN)
     Undocumented internal function.
}

#
__additional_help_message__
{
`__additional_help_message__' is a function from the file /usr/share/octave/3.2.3/m/help/__additional_help_message__.m

 -- Function File:  __additional_help_message__ ()
     Undocumented internal function.
}

#
__all_opts__
{
`__all_opts__' is a function from the file /usr/share/octave/3.2.3/m/optimization/__all_opts__.m

 -- Function File: NAMES = __all_opts__ (...)
     Undocumented internal function.
}

#
__area__
{
`__area__' is a function from the file /usr/share/octave/3.2.3/m/plot/__area__.m

 -- Function File:  __area__ (AX, X, Y, BV, ...)
     Undocumented internal function.
}

#
__axes_limits__
{
`__axes_limits__' is a function from the file /usr/share/octave/3.2.3/m/plot/__axes_limits__.m

 -- Function File:  __axes_limits__ (FCN, ...)
     Undocumented internal function.
}

#
__axis_label__
{
`__axis_label__' is a function from the file /usr/share/octave/3.2.3/m/plot/__axis_label__.m

 -- Function File:  __axis_label__ (CALLER, TXT, ...)
     Undocumented internal function.
}

#
__bar__
{
`__bar__' is a function from the file /usr/share/octave/3.2.3/m/plot/__bar__.m

 -- Function File:  __bar__ (VERTICAL, FUNC, ...)
     Undocumented internal function.
}

#
__bars__
{
`__bars__' is a function from the file /usr/share/octave/3.2.3/m/plot/__bars__.m

 -- Function File:  __bars__ (AX, VERTICAL, X, Y, XB, YB, WIDTH, GROUP,
          HAVE_COLOR_SPEC, BASE_VALUE, ...)
     Undocumented internal function.
}

#
__builtins__
{
`__builtins__' is a built-in function

 -- Function File: __builtins__ ()
     Undocumented internal function.
}

#
__clabel__
{
`__clabel__' is a function from the file /usr/share/octave/3.2.3/m/plot/__clabel__.m

 -- Function File: H = __clabel__ (C, V, HPARENT, LABEL_SPACING, Z,
          VARARGIN)
     Undocumented internal function.
}

#
__contour__
{
`__contour__' is a function from the file /usr/share/octave/3.2.3/m/plot/__contour__.m

 -- Function File: [C, HG] = __contour__ (...)
     Undocumented internal function.
}

#
__contourc__
{
`__contourc__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__contourc__.oct

 -- Loadable Function:  __contourc__ (X, Y, Z, LEVELS)
     Undocumented internal function.
}

#
__convn__
{
`__convn__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__convn__.oct

 -- Loadable Function:  __convn__(A, B)
     Undocumented internal function.
}

#
__current_scope__
{
`__current_scope__' is a built-in function

 -- Built-in Function: [SCOPE, CONTEXT] __dump_symtab_info__ ()
     Undocumented internal function.
}

#
__default_plot_options__
{
`__default_plot_options__' is a function from the file /usr/share/octave/3.2.3/m/plot/__default_plot_options__.m

 -- Function File: OPTIONS = __default_plot_options__ ()
     Undocumented internal function.
}

#
__delaunayn__
{
`__delaunayn__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__delaunayn__.oct

 -- Loadable Function: T = __delaunayn__ (P[, OPT])
     Undocumented internal function.
}

#
__display_tokens__
{
`__display_tokens__' is a built-in function

 -- Built-in Function:  __display_tokens__ ()
     Query or set the internal variable that determines whether Octave's
     lexer displays tokens as they are read.
}

#
__dogleg__
{
`__dogleg__' is a function from the file /usr/share/octave/3.2.3/m/optimization/__dogleg__.m

 -- Function File: X = __dogleg__ (R, B, X, D, DELTA, ISMIN)
     Solve the double dogleg trust-region problem: Minimize
          norm(R*X-B)
     subject to the constraint
          norm(D.*X) <= DELTA ,
     x being a convex combination of the gauss-newton and scaled
     gradient.  If ISMIN is true (default false), minimizes instead
          norm(R*X)^2-2*B'*X
}

#
__dsearchn__
{
`__dsearchn__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__dsearchn__.oct

 -- Loadable Function: [IDX, D] = dsearch (X, XI)
     Undocumented internal function.
}

#
__dump_symtab_info__
{
`__dump_symtab_info__' is a built-in function

 -- Built-in Function:  __dump_symtab_info__ ()
 -- Built-in Function:  __dump_symtab_info__ (SCOPE)
 -- Built-in Function:  __dump_symtab_info__ ("scopes")
 -- Built-in Function:  __dump_symtab_info__ ("functions")
     Undocumented internal function.
}

#
__end__
{
`__end__' is a built-in function

internal function
}

#
__errcomm__
{
`__errcomm__' is a function from the file /usr/share/octave/3.2.3/m/plot/__errcomm__.m

 -- Function File:  __errcomm__ (CALLER, P, ...)
     Undocumented internal function.
}

#
__error_text__
{
`__error_text__' is a built-in function

 -- Built-in Function: [MSG, MSGID] = lasterr (MSG, MSGID)
     Without any arguments, return the last error message.  With one
     argument, set the last error message to MSG.  With two arguments,
     also set the last message identifier.
}

#
__errplot__
{
`__errplot__' is a function from the file /usr/share/octave/3.2.3/m/plot/__errplot__.m

 -- Function File: H = __errplot__ (FSTR, P, ...)
     Undocumented internal function.
}

#
__extractpath__
{
`__extractpath__' is a function from the file /usr/share/octave/3.2.3/m/path/__extractpath__.m

 -- Function File: VAL = __extractpath__ (FILE)
     Undocumented internal function.
}

#
__ezplot__
{
`__ezplot__' is a function from the file /usr/share/octave/3.2.3/m/plot/__ezplot__.m

 -- Function File: [H, NEEDUSAGE] = __ezplot__ (PFUNC, VARARGIN)
     Undocumented internal function.
}

#
__fdjac__
{
`__fdjac__' is a function from the file /usr/share/octave/3.2.3/m/optimization/__fdjac__.m

 -- Function File:  __fdjac__ (FCN, X, FVEC, ERR)
     Undocumented internal function.
}

#
__finish__
{
`__finish__' is a function from the file /usr/share/octave/3.2.3/m/startup/__finish__.m

 -- Function File:  __finish__ ()
     Undocumented internal function.
}

#
__fltk_maxtime__
{
No documented.
}

#
__fltk_redraw__
{
No documented.
}

#
__get__
{
`__get__' is a built-in function

 -- Built-in Function:  __get__ (H)
     Undocumented internal function.
}

#
__glpk__
{
`__glpk__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__glpk__.oct

 -- Loadable Function: [VALUES] = __glpk__ (ARGS)
     Undocumented internal function.
}

#
__gnuplot_get_var__
{
`__gnuplot_get_var__' is a function from the file /usr/share/octave/3.2.3/m/plot/__gnuplot_get_var__.m

 -- Function File: VALUE = __gnuplot_get_var__ (H, NAME, FMT)
     Undocumented internal function.
}

#
__gnuplot_ginput__
{
`__gnuplot_ginput__' is a function from the file /usr/share/octave/3.2.3/m/plot/__gnuplot_ginput__.m

 -- Function File: [X, Y, BUTTONS] = __gnuplot_ginput__ (F, N)
     Undocumented internal function.
}

#
__gnuplot_has_feature__
{
`__gnuplot_has_feature__' is a function from the file /usr/share/octave/3.2.3/m/plot/__gnuplot_has_feature__.m

 -- Function File: HAS_FEATURE = __gnuplot_has_feature__ (FEATURE)
     Undocumented internal function.
}

#
__gnuplot_open_stream__
{
`__gnuplot_open_stream__' is a function from the file /usr/share/octave/3.2.3/m/plot/__gnuplot_open_stream__.m

 -- Function File: STREAM __gnuplot_open_stream__ (NPIPES, H)
     Undocumented internal function.
}

#
__gnuplot_version__
{
`__gnuplot_version__' is a function from the file /usr/share/octave/3.2.3/m/plot/__gnuplot_version__.m

 -- Function File: VERSION = __gnuplot_version__ ()
     Undocumented internal function.
}

#
__go_axes__
{
`__go_axes__' is a built-in function

 -- Built-in Function:  __go_axes__ (PARENT)
     Undocumented internal function.
}

#
__go_axes_init__
{
`__go_axes_init__' is a built-in function

 -- Built-in Function:  __go_axes_init__ (H, MODE)
     Undocumented internal function.
}

#
__go_close_all__
{
`__go_close_all__' is a function from the file /usr/share/octave/3.2.3/m/plot/__go_close_all__.m

 -- Function File:  __go_close_all__ ()
     Undocumented internal function.
}

#
__go_delete__
{
`__go_delete__' is a built-in function

 -- Built-in Function:  __go_delete__ (H)
     Undocumented internal function.
}

#
__go_draw_axes__
{
`__go_draw_axes__' is a function from the file /usr/share/octave/3.2.3/m/plot/__go_draw_axes__.m

 -- Function File:  __go_draw_axes__ (H, PLOT_STREAM, ENHANCED, MONO)
     Undocumented internal function.
}

#
__go_draw_figure__
{
`__go_draw_figure__' is a function from the file /usr/share/octave/3.2.3/m/plot/__go_draw_figure__.m

 -- Function File:  __go_draw_figure__ (H, PLOT_STREAM, ENHANCED, MONO)
     Undocumented internal function.
}

#
__go_execute_callback__
{
`__go_execute_callback__' is a built-in function

 -- Built-in Function:  __go_execute_callback__ (H, NAME)
 -- Built-in Function:  __go_execute_callback__ (H, NAME, PARAM)
     Undocumented internal function.
}

#
__go_figure__
{
`__go_figure__' is a built-in function

 -- Built-in Function:  __go_figure__ (FIGNUM)
     Undocumented internal function.
}

#
__go_figure_handles__
{
`__go_figure_handles__' is a built-in function

 -- Built-in Function:  __go_figure_handles__ ()
     Undocumented internal function.
}

#
__go_handles__
{
`__go_handles__' is a built-in function

 -- Built-in Function:  __go_handles__ ()
     Undocumented internal function.
}

#
__go_hggroup__
{
`__go_hggroup__' is a built-in function

 -- Built-in Function:  __go_hggroup__ (PARENT)
     Undocumented internal function.
}

#
__go_image__
{
`__go_image__' is a built-in function

 -- Built-in Function:  __go_image__ (PARENT)
     Undocumented internal function.
}

#
__go_line__
{
`__go_line__' is a built-in function

 -- Built-in Function:  __go_line__ (PARENT)
     Undocumented internal function.
}

#
__go_patch__
{
`__go_patch__' is a built-in function

 -- Built-in Function:  __go_patch__ (PARENT)
     Undocumented internal function.
}

#
__go_surface__
{
`__go_surface__' is a built-in function

 -- Built-in Function:  __go_surface__ (PARENT)
     Undocumented internal function.
}

#
__go_text__
{
`__go_text__' is a built-in function

 -- Built-in Function:  __go_text__ (PARENT)
     Undocumented internal function.
}

#
__gud_mode__
{
`__gud_mode__' is a built-in function

 -- Built-in Function:  __gud_mode__ ()
     Undocumented internal function.
}

#
__img__
{
`__img__' is a function from the file /usr/share/octave/3.2.3/m/image/__img__.m

 Undocumented internal function.
}

#
__img_via_file__
{
`__img_via_file__' is a function from the file /usr/share/octave/3.2.3/m/image/__img_via_file__.m

 Undocumented internal function.
}

#
__init_fltk__
{
No documented.
}

#
__interp_cube__
{
`__interp_cube__' is a function from the file /usr/share/octave/3.2.3/m/plot/__interp_cube__.m

 -- Function File: [VXYZ, IDX, FRAC] = __interp_cube__ (X, Y, Z, VAL, V)
     Undocumented internal function.
}

#
__isa_parent__
{
`__isa_parent__' is a built-in function

 -- Built-in Function:  __isa_parent__ (CLASS, NAME)
     Undocumented internal function.
}

#
__isequal__
{
`__isequal__' is a function from the file /usr/share/octave/3.2.3/m/general/__isequal__.m

 Undocumented internal function.
}

#
__keywords__
{
`__keywords__' is a built-in function

 -- Function File: __keywords__ ()
     Undocumented internal function.
}

#
__lexer_debug_flag__
{
`__lexer_debug_flag__' is a built-in function

 -- Built-in Function: OLD_VAL = __lexer_debug_flag__ (NEW_VAL))
     Undocumented internal function.
}

#
__lin_interpn__
{
`__lin_interpn__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__lin_interpn__.oct

 -- Loadable Function: VI = __lin_interpn__ (X1, X2, ..., XN, V, Y1,
          Y2, ..., YN)
     Undocumented internal function.
}

#
__line__
{
`__line__' is a function from the file /usr/share/octave/3.2.3/m/plot/__line__.m

 -- Function File: H = __line__ (P, ...)
     Undocumented internal function.
}

#
__list_functions__
{
`__list_functions__' is a built-in function

 -- Function File: RETVAL = __list_functions__ ()
 -- Function File: RETVAL = __list_functions__ (DIRECTORY)
     Undocumented internal function.
}

#
__magick_finfo__
{
`__magick_finfo__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__magick_read__.oct

 -- Loadable File:  __magick_finfo__(FNAME)
     Read image information with GraphicsMagick++.  In general you
     should not be using this function.  Instead you should use
     `imfinfo'.

     See also: imfinfo, imread
}

#
__magick_read__
{
`__magick_read__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__magick_read__.oct

 -- Function File: M = __magick_read__(FNAME, INDEX)
 -- Function File: [M, COLORMAP] = __magick_read__(FNAME, INDEX)
 -- Function File: [M, COLORMAP, ALPHA] = __magick_read__(FNAME, INDEX)
     Read images with ImageMagick++.  In general you should not be
     using this function.  Instead you should use `imread'.

     See also: imread
}

#
__magick_write__
{
`__magick_write__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__magick_read__.oct

 -- Function File:  __magick_write__(FNAME, FMT, IMG)
 -- Function File:  __magick_write__(FNAME, FMT, IMG, MAP)
     Write images with ImageMagick++.  In general you should not be
     using this function.  Instead you should use `imwrite'.

     See also: imread
}

#
__makeinfo__
{
`__makeinfo__' is a function from the file /usr/share/octave/3.2.3/m/help/__makeinfo__.m

 -- Function File: [RETVAL, STATUS] = __makeinfo__ (TEXT, OUTPUT_TYPE)
 -- Function File: [RETVAL, STATUS] = __makeinfo__ (TEXT, OUTPUT_TYPE,
          SEE_ALSO)
     Undocumented internal function.
}

#
__marching_cube__
{
`__marching_cube__' is a function from the file /usr/share/octave/3.2.3/m/plot/__marching_cube__.m

 -- Function File: [T, P] = __marching_cube__ (X, Y, Z, VAL, ISO)
 -- Function File: [T, P, C] = __marching_cube__ (X, Y, Z, VAL, ISO,
          COL)
     Undocumented internal function.
}

#
__next_line_color__
{
`__next_line_color__' is a function from the file /usr/share/octave/3.2.3/m/plot/__next_line_color__.m

 -- Function File: RGB = __next_line_color__ (RESET)
     Undocumented internal function.
}

#
__operators__
{
`__operators__' is a built-in function

 -- Function File: __operators__ ()
     Undocumented internal function.
}

#
__parent_classes__
{
`__parent_classes__' is a built-in function

 -- Built-in Function:  __parent_classes__ (X)
     Undocumented internal function.
}

#
__parser_debug_flag__
{
`__parser_debug_flag__' is a built-in function

 -- Built-in Function: OLD_VAL = __parser_debug_flag__ (NEW_VAL))
     Undocumented internal function.
}

#
__patch__
{
`__patch__' is a function from the file /usr/share/octave/3.2.3/m/plot/__patch__.m

 -- Function File: [H, FAIL] = __patch__ (P, ...)
     Undocumented internal function.
}

#
__pathorig__
{
`__pathorig__' is a built-in function

 -- Built-in Function: VAL = __pathorig__ ()
     Undocumented internal function.
}

#
__pchip_deriv__
{
`__pchip_deriv__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__pchip_deriv__.oct

 -- Loadable Function:  __pchip_deriv__ (X, Y, DIM)
     Undocumented internal function.
}

#
__plr1__
{
`__plr1__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plr1__.m

 -- Function File:  __plr1__ (H, THETA, FMT)
     Undocumented internal function.
}

#
__plr2__
{
`__plr2__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plr2__.m

 -- Function File:  __plr2__ (H, THETA, RHO, FMT)
     Undocumented internal function.
}

#
__plt1__
{
`__plt1__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt1__.m

 -- Function File:  __plt1__ (H, X1, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2__
{
`__plt2__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2__.m

 -- Function File:  __plt2__ (H, X1, X2, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2mm__
{
`__plt2mm__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2mm__.m

 -- Function File:  __plt2mm__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2mv__
{
`__plt2mv__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2mv__.m

 -- Function File:  __plt2mv__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2ss__
{
`__plt2ss__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2ss__.m

 -- Function File:  __plt2ss__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2sv__
{
`__plt2sv__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2sv__.m

 -- Function File:  __plt2sv__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2vm__
{
`__plt2vm__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2vm__.m

 -- Function File:  __plt2vm__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2vs__
{
`__plt2vs__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2vs__.m

 -- Function File:  __plt2vs__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt2vv__
{
`__plt2vv__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt2vv__.m

 -- Function File:  __plt2vv__ (H, X, Y, OPTIONS, PROPERTIES)
     Undocumented internal function.
}

#
__plt__
{
`__plt__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt__.m

 -- Function File:  __plt__ (CALLER, H, VARARGIN)
     Undocumented internal function.
}

#
__plt_get_axis_arg__
{
`__plt_get_axis_arg__' is a function from the file /usr/share/octave/3.2.3/m/plot/__plt_get_axis_arg__.m

 -- Function File: [H, VARARGIN, NARG] = __plt_get_axis_arg__ (CALLER,
          VARARGIN)
     Undocumented internal function.
}

#
__pltopt1__
{
`__pltopt1__' is a function from the file /usr/share/octave/3.2.3/m/plot/__pltopt1__.m

 -- Function File: [OPTIONS, VALID] = __pltopt1__ (CALLER, OPT,
          ERR_ON_INVALID)
     Undocumented internal function.
}

#
__pltopt__
{
`__pltopt__' is a function from the file /usr/share/octave/3.2.3/m/plot/__pltopt__.m

 -- Function File:  __pltopt__ (CALLER, OPT)
     Undocumented internal function.
}

#
__qp__
{
`__qp__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__qp__.oct

 -- Loadable Function: [X, LAMBDA, INFO, ITER] = __qp__ (X0, H, Q, AEQ,
          BEQ, AIN, BIN, MAXIT)
     Undocumented internal function.
}

#
__quantile__
{
`__quantile__' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/__quantile__.m

 -- Function File: Q = __quantile__ (X, P)
 -- Function File: Q = __quantile__ (X, P, METHOD)
     Undocumented internal function.
}

#
__quiver__
{
`__quiver__' is a function from the file /usr/share/octave/3.2.3/m/plot/__quiver__.m

 -- Function File: HG = __quiver__ (...)
     Undocumented internal function.
}

#
__remove_fltk__
{
No documented.
}

#
__request_drawnow__
{
`__request_drawnow__' is a built-in function

 -- Built-in Function:  __request_drawnow__ ()
 -- Built-in Function:  __request_drawnow__ (FLAG)
     Undocumented internal function.
}

#
__scatter__
{
`__scatter__' is a function from the file /usr/share/octave/3.2.3/m/plot/__scatter__.m

 -- Function File: HG = __scatter__ (...)
     Undocumented internal function.
}

#
__sort_rows_idx__
{
`__sort_rows_idx__' is a built-in function

 -- Built-in Function:  __sort_rows_idx__ (A, MODE)
     Undocumented internal function.
}

#
__splinen__
{
`__splinen__' is a function from the file /usr/share/octave/3.2.3/m/general/__splinen__.m

 Undocumented internal function.
}

#
__stem__
{
`__stem__' is a function from the file /usr/share/octave/3.2.3/m/plot/__stem__.m

 -- Function File: H = __stem__ (HAVE_Z, VARARGIN)
     Undocumented internal function.
}

#
__strip_html_tags__
{
`__strip_html_tags__' is a function from the file /usr/share/octave/3.2.3/m/help/__strip_html_tags__.m

 -- Function File: [TEXT, STATUS] = __strip_html_tags__ (HTML_TEXT)
     Undocumented internal function.
}

#
__token_count__
{
`__token_count__' is a built-in function

 -- Built-in Function:  __token_count__ ()
     Number of language tokens processed since Octave startup.
}

#
__version_info__
{
`__version_info__' is a built-in function

 -- Built-in Function: retval = __version_info__ (NAME, VERSION,
          RELEASE, DATE)
     Undocumented internal function.
}

#
__voronoi__
{
`__voronoi__' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/__voronoi__.oct

 -- Loadable Function: TRI = __voronoi__ (POINT)
 -- Loadable Function: TRI = __voronoi__ (POINT, OPTIONS)
     Undocumented internal function.
}

#
__which__
{
`__which__' is a built-in function

 -- Built-in Function:  __which__ (NAME, ...)
     Undocumented internal function.
}

#
__xzip__
{
`__xzip__' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/__xzip__.m

 -- Function File: ENTRIES = __xzip__ (COMMANDNAME, EXTENSION,
          COMMANDTEMPLATE, FILES, OUTDIR)
     Undocumented internal function.
}

#
abs
{
`abs' is a built-in function

 -- Mapping Function:  abs (Z)
     Compute the magnitude of Z, defined as |Z| = `sqrt (x^2 + y^2)'.

     For example,

          abs (3 + 4i)
              => 5
}

#
accumarray
{
`accumarray' is a function from the file /usr/share/octave/3.2.3/m/general/accumarray.m

 -- Function File:  accumarray (SUBS, VALS, SZ, FUNC, FILLVAL, ISSPARSE)
 -- Function File:  accumarray (CSUBS, VALS, ...)
     Create an array by accumulating the elements of a vector into the
     positions defined by their subscripts.  The subscripts are defined
     by the rows of the matrix SUBS and the values by VALS.  Each row
     of SUBS corresponds to one of the values in VALS.

     The size of the matrix will be determined by the subscripts
     themselves.  However, if SZ is defined it determines the matrix
     size.  The length of SZ must correspond to the number of columns
     in SUBS.

     The default action of `accumarray' is to sum the elements with the
     same subscripts.  This behavior can be modified by defining the
     FUNC function.  This should be a function or function handle that
     accepts a column vector and returns a scalar.  The result of the
     function should not depend on the order of the subscripts.

     The elements of the returned array that have no subscripts
     associated with them are set to zero.  Defining FILLVAL to some
     other value allows these values to be defined.

     By default `accumarray' returns a full matrix.  If ISSPARSE is
     logically true, then a sparse matrix is returned instead.

     An example of the use of `accumarray' is:

          accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2], 101:105)
          => ans(:,:,1) = [101, 0, 0; 0, 0, 0]
             ans(:,:,2) = [0, 0, 0; 206, 0, 208]
}

#
acos
{
`acos' is a built-in function

 -- Mapping Function:  acos (X)
     Compute the inverse cosine in radians for each element of X.

     See also: cos, acosd
}

#
acosd
{
`acosd' is a function from the file /usr/share/octave/3.2.3/m/elfun/acosd.m

 -- Function File:  acosd (X)
     Compute the inverse cosine in degrees for each element of X.

     See also: cosd, acos
}

#
acosh
{
`acosh' is a built-in function

 -- Mapping Function:  acosh (X)
     Compute the inverse hyperbolic cosine for each element of X.

     See also: cosh
}

#
acot
{
`acot' is a function from the file /usr/share/octave/3.2.3/m/elfun/acot.m

 -- Mapping Function:  acot (X)
     Compute the inverse cotangent in radians for each element of X.

     See also: cot, acotd
}

#
acotd
{
`acotd' is a function from the file /usr/share/octave/3.2.3/m/elfun/acotd.m

 -- Function File:  acotd (X)
     Compute the inverse cotangent in degrees for each element of X.

     See also: cotd, acot
}

#
acoth
{
`acoth' is a function from the file /usr/share/octave/3.2.3/m/elfun/acoth.m

 -- Mapping Function:  acoth (X)
     Compute the inverse hyperbolic cotangent of each element of X.

     See also: coth
}

#
acsc
{
`acsc' is a function from the file /usr/share/octave/3.2.3/m/elfun/acsc.m

 -- Mapping Function:  acsc (X)
     Compute the inverse cosecant in radians for each element of X.

     See also: csc, acscd
}

#
acscd
{
`acscd' is a function from the file /usr/share/octave/3.2.3/m/elfun/acscd.m

 -- Function File:  acscd (X)
     Compute the inverse cosecant in degrees for each element of X.

     See also: cscd, acsc
}

#
acsch
{
`acsch' is a function from the file /usr/share/octave/3.2.3/m/elfun/acsch.m

 -- Mapping Function:  acsch (X)
     Compute the inverse hyperbolic cosecant of each element of X.

     See also: csch
}

#
add_input_event_hook
{
`add_input_event_hook' is a built-in function

 -- Built-in Function:  add_input_event_hook (FCN, DATA)
     Add the named function FCN to the list of functions to call
     periodically when Octave is waiting for input.  The function should
     have the form
          FCN (DATA)

     If DATA is omitted, Octave calls the function without any
     arguments.

     See also: remove_input_event_hook
}

#
addlistener
{
`addlistener' is a built-in function

 -- Built-in Function:  addlistener (H, PROP, FCN)
     Register FCN as listener for the property PROP of the graphics
     object H.  Property listeners are executed (in order of
     registration) when the property is set.  The new value is already
     available when the listeners are executed.

     PROP must be a string naming a valid property in H.

     FCN can be a function handle, a string or a cell array whose first
     element is a function handle.  If FCN is a function handle, the
     corresponding function should accept at least 2 arguments, that
     will be set to the object handle and the empty matrix
     respectively.  If FCN is a string, it must be any valid octave
     expression.  If FCN is a cell array, the first element must be a
     function handle with the same signature as described above.  The
     next elements of the cell array are passed as additional arguments
     to the function.

     Example:

          function my_listener (h, dummy, p1)
           fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          addlistener (gcf, "position", {@my_listener, "my string"})
}

#
addpath
{
`addpath' is a built-in function

 -- Built-in Function:  addpath (DIR1, ...)
 -- Built-in Function:  addpath (DIR1, ..., OPTION)
     Add DIR1, ... to the current function search path.  If OPTION is
     `"-begin"' or 0 (the default), prepend the directory name to the
     current path.  If OPTION is `"-end"' or 1, append the directory
     name to the current path.  Directories added to the path must
     exist.

     See also: path, rmpath, genpath, pathdef, savepath, pathsep
}

#
addproperty
{
`addproperty' is a built-in function

 -- Built-in Function:  addproperty (NAME, H, TYPE, [ARG, ...])
     Create a new property named NAME in graphics object H.  TYPE
     determines the type of the property to create.  ARGS usually
     contains the default value of the property, but additional
     arguments might be given, depending on the type of the property.

     The supported property types are:

    `string'
          A string property.  ARG contains the default string value.

    `any'
          An un-typed property.  This kind of property can hold any
          octave value.  ARGS contains the default value.

    `radio'
          A string property with a limited set of accepted values.  The
          first argument must be a string with all accepted values
          separated by a vertical bar ('|').  The default value can be
          marked by enclosing it with a '{' '}' pair.  The default
          value may also be given as an optional second string argument.

    `boolean'
          A boolean property.  This property type is equivalent to a
          radio property with "on|off" as accepted values.  ARG contains
          the default property value.

    `double'
          A scalar double property.  ARG contains the default value.

    `handle'
          A handle property.  This kind of property holds the handle of
          a graphics object.  ARG contains the default handle value.
          When no default value is given, the property is initialized to
          the empty matrix.

    `data'
          A data (matrix) property.  ARG contains the default data
          value.  When no default value is given, the data is
          initialized to the empty matrix.

    `color'
          A color property.  ARG contains the default color value.
          When no default color is given, the property is set to black.
          An optional second string argument may be given to specify an
          additional set of accepted string values (like a radio
          property).

     TYPE may also be the concatenation of a core object type and a
     valid property name for that object type.  The property created
     then has the same characteristics as the referenced property (type,
     possible values, hidden state...).  This allows to clone an
     existing property into the graphics object H.

     Examples:

          addproperty ("my_property", gcf, "string", "a string value");
          addproperty ("my_radio", gcf, "radio", "val_1|val_2|{val_3}");
          addproperty ("my_style", gcf, "linelinestyle", "--");
}

#
addtodate
{
`addtodate' is a function from the file /usr/share/octave/3.2.3/m/time/addtodate.m

 -- Function File: D = addtodate (D, Q, F)
     Add Q amount of time (with units F) to the datenum, D.

     F must be one of "year", "month", "day", "hour", "minute", or
     "second".

     See also: datenum, datevec
}

#
airy
{
`airy' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/besselj.oct

 -- Loadable Function: [A, IERR] = airy (K, Z, OPT)
     Compute Airy functions of the first and second kind, and their
     derivatives.

          K   Function   Scale factor (if 'opt' is supplied)
          ---  --------   ---------------------------------------
          0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
          1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
          2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))
          3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))

     The function call `airy (Z)' is equivalent to `airy (0, Z)'.

     The result is the same size as Z.

     If requested, IERR contains the following status information and
     is the same size as the result.

       0. Normal return.

       1. Input error, return `NaN'.

       2. Overflow, return `Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          `NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return `NaN'.
}

#
all
{
`all' is a built-in function

 -- Built-in Function:  all (X, DIM)
     The function `all' behaves like the function `any', except that it
     returns true only if all the elements of a vector, or all the
     elements along dimension DIM of a matrix, are nonzero.
}

#
allchild
{
`allchild' is a function from the file /usr/share/octave/3.2.3/m/plot/allchild.m

 -- Function File: H = allchild (HANDLES)
     Find all children, including hidden children, of a graphics object.

     This function is similar to `get (h, "children")', but also
     returns includes hidden objects.  If HANDLES is a scalar, H will
     be a vector.  Otherwise, H will be a cell matrix of the same size
     as HANDLES and each cell will contain a vector of handles.

     See also: get, set, findall, findobj
}

#
amd
{
`amd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/amd.oct

 -- Loadable Function: P = amd (S)
 -- Loadable Function: P = amd (S, OPTS)
     Returns the approximate minimum degree permutation of a matrix.
     This permutation such that the Cholesky factorization of `S (P,
     P)' tends to be sparser than the Cholesky factorization of S
     itself.  `amd' is typically faster than `symamd' but serves a
     similar purpose.

     The optional parameter OPTS is a structure that controls the
     behavior of `amd'.  The fields of these structure are

    opts.dense
          Determines what `amd' considers to be a dense row or column
          of the input matrix.  Rows or columns with more than `max(16,
          (dense * sqrt (N)' entries, where N is the order of the
          matrix S, are ignored by `amd' during the calculation of the
          permutation The value of dense must be a positive scalar and
          its default value is 10.0

    opts.aggressive
          If this value is a non zero scalar, then `amd' performs
          aggressive absorption.  The default is not to perform
          aggressive absorption.

     The author of the code itself is Timothy A. Davis
     (davis@cise.ufl.edu), University of Florida (see
     `http://www.cise.ufl.edu/research/sparse/amd').

     See also: symamd, colamd
}

#
ancestor
{
`ancestor' is a function from the file /usr/share/octave/3.2.3/m/plot/ancestor.m

 -- Function File: PARENT = ancestor (H, TYPE)
 -- Function File: PARENT = ancestor (H, TYPE, 'toplevel')
     Return the first ancestor of handle object H whose type matches
     TYPE, where TYPE is a character string.  If TYPE is a cell array
     of strings, return the first parent whose type matches any of the
     given type strings.

     If the handle object H is of type TYPE, return H.

     If `"toplevel"' is given as a 3rd argument, return the highest
     parent in the object hierarchy that matches the condition, instead
     of the first (nearest) one.

     See also: get, set
}

#
and
{
`and' is a built-in function

 -- Built-in Function:  and (X, Y)
     This function is equivalent to `x & y'.
}

#
angle
{
`angle' is a built-in function

 -- Mapping Function:  angle (Z)
     See arg.
}

#
anova
{
`anova' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/anova.m

 -- Function File: [PVAL, F, DF_B, DF_W] = anova (Y, G)
     Perform a one-way analysis of variance (ANOVA).  The goal is to
     test whether the population means of data taken from K different
     groups are all equal.

     Data may be given in a single vector Y with groups specified by a
     corresponding vector of group labels G (e.g., numbers from 1 to
     K).  This is the general form which does not impose any
     restriction on the number of data in each group or the group
     labels.

     If Y is a matrix and G is omitted, each column of Y is treated as
     a group.  This form is only appropriate for balanced ANOVA in
     which the numbers of samples from each group are all equal.

     Under the null of constant means, the statistic F follows an F
     distribution with DF_B and DF_W degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is
     returned in PVAL.

     If no output argument is given, the standard one-way ANOVA table is
     printed.
}

#
ans
{
`ans' is the file /usr/share/octave/3.2.3/m/miscellaneous/ans.m

 -- Automatic Variable: ans
     The most recently computed result that was not explicitly assigned
     to a variable.  For example, after the expression

          3^2 + 4^2

     is evaluated, the value returned by `ans' is 25.
}

#
any
{
`any' is a built-in function

 -- Built-in Function:  any (X, DIM)
     For a vector argument, return 1 if any element of the vector is
     nonzero.

     For a matrix argument, return a row vector of ones and zeros with
     each element indicating whether any of the elements of the
     corresponding column of the matrix are nonzero.  For example,

          any (eye (2, 4))
              => [ 1, 1, 0, 0 ]

     If the optional argument DIM is supplied, work along dimension
     DIM.  For example,

          any (eye (2, 4), 2)
              => [ 1; 1 ]
}

#
append
{
`append' is a built-in function

 -- Built-in Function:  append (LIST, A1, A2, ...)
     Return a new list created by appending A1, A2, ..., to LIST.  If
     any of the arguments to be appended is a list, its elements are
     appended individually.  For example,

          x = list (1, 2);
          y = list (3, 4);
          append (x, y);

     results in the list containing the four elements `(1 2 3 4)', not
     a list containing the three elements `(1 2 (3 4))'.
}

#
arch_fit
{
`arch_fit' is a function from the file /usr/share/octave/3.2.3/m/signal/arch_fit.m

 -- Function File: [A, B] = arch_fit (Y, X, P, ITER, GAMMA, A0, B0)
     Fit an ARCH regression model to the time series Y using the
     scoring algorithm in Engle's original ARCH paper.  The model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2

     in which e(t) is N(0, h(t)), given a time-series vector Y up to
     time t-1 and a matrix of (ordinary) regressors X up to t.  The
     order of the regression of the residual variance is specified by P.

     If invoked as `arch_fit (Y, K, P)' with a positive integer K, fit
     an ARCH(K, P) process, i.e., do the above with the t-th row of X
     given by

          [1, y(t-1), ..., y(t-k)]

     Optionally, one can specify the number of iterations ITER, the
     updating factor GAMMA, and initial values a0 and b0 for the
     scoring algorithm.
}

#
arch_rnd
{
`arch_rnd' is a function from the file /usr/share/octave/3.2.3/m/signal/arch_rnd.m

 -- Function File:  arch_rnd (A, B, T)
     Simulate an ARCH sequence of length T with AR coefficients B and
     CH coefficients A.  I.e., the result y(t) follows the model

          y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),

     where e(t), given Y up to time t-1, is N(0, h(t)), with

          h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
}

#
arch_test
{
`arch_test' is a function from the file /usr/share/octave/3.2.3/m/signal/arch_test.m

 -- Function File: [PVAL, LM] = arch_test (Y, X, P)
     For a linear regression model

          y = x * b + e

     perform a Lagrange Multiplier (LM) test of the null hypothesis of
     no conditional heteroscedascity against the alternative of CH(P).

     I.e., the model is

          y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),

     given Y up to t-1 and X up to t, e(t) is N(0, h(t)) with

          h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,

     and the null is a(1) == ... == a(p) == 0.

     If the second argument is a scalar integer, k, perform the same
     test in a linear autoregression model of order k, i.e., with

          [1, y(t-1), ..., y(t-K)]

     as the t-th row of X.

     Under the null, LM approximately has a chisquare distribution with
     P degrees of freedom and PVAL is the p-value (1 minus the CDF of
     this distribution at LM) of the test.

     If no output argument is given, the p-value is displayed.
}

#
area
{
`area' is a function from the file /usr/share/octave/3.2.3/m/plot/area.m

 -- Function File:  area (X, Y)
 -- Function File:  area (X, Y, LVL)
 -- Function File:  area (..., PROP, VAL, ...)
 -- Function File:  area (Y, ...)
 -- Function File:  area (H, ...)
 -- Function File: H = area (...)
     Area plot of cumulative sum of the columns of Y.  This shows the
     contributions of a value to a sum, and is functionally similar to
     `plot (X, cumsum (Y, 2))', except that the area under the curve is
     shaded.

     If the X argument is omitted it is assumed to be given by `1 :
     rows (Y)'.  A value LVL can be defined that determines where the
     base level of the shading under the curve should be defined.

     Additional arguments to the `area' function are passed to the
     `patch'.  The optional return value H provides a handle to area
     series object representing the patches of the areas.

     See also: plot, patch
}

#
arg
{
`arg' is a built-in function

 -- Mapping Function:  arg (Z)
 -- Mapping Function:  angle (Z)
     Compute the argument of Z, defined as, THETA = `atan2 (Y, X)', in
     radians.

     For example,

          arg (3 + 4i)
              => 0.92730
}

#
argnames
{
`argnames' is a built-in function

 -- Built-in Function:  argnames (FUN)
     Return a cell array of character strings containing the names of
     the arguments of the inline function FUN.

     See also: inline, formula, vectorize
}

#
argv
{
`argv' is a built-in function

 -- Built-in Function:  argv ()
     Return the command line arguments passed to Octave.  For example,
     if you invoked Octave using the command

          octave --no-line-editing --silent

     `argv' would return a cell array of strings with the elements
     `--no-line-editing' and `--silent'.

     If you write an executable Octave script, `argv' will return the
     list of arguments passed to the script.  *Note Executable Octave
     Programs::, for an example of how to create an executable Octave
     script.
}

#
arma_rnd
{
`arma_rnd' is a function from the file /usr/share/octave/3.2.3/m/signal/arma_rnd.m

 -- Function File:  arma_rnd (A, B, V, T, N)
     Return a simulation of the ARMA model

          x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
               + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)

     in which K is the length of vector A, L is the length of vector B
     and E is Gaussian white noise with variance V.  The function
     returns a vector of length T.

     The optional parameter N gives the number of dummy X(I) used for
     initialization, i.e., a sequence of length T+N is generated and
     X(N+1:T+N) is returned.  If N is omitted, N = 100 is used.
}

#
arrayfun
{
`arrayfun' is a function from the file /usr/share/octave/3.2.3/m/general/arrayfun.m

 -- Function File:  arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A, B, ...)
 -- Function File: [X, Y, ...] = arrayfun (FUNC, A, ...)
 -- Function File:  arrayfun (..., "UniformOutput", VAL)
 -- Function File:  arrayfun (..., "ErrorHandler", ERRFUNC)
     Execute a function on each element of an array.  This is useful for
     functions that do not accept array arguments.  If the function does
     accept array arguments it is better to call the function directly.

     The first input argument FUNC can be a string, a function handle,
     an inline function or an anonymous function.  The input argument A
     can be a logic array, a numeric array, a string array, a structure
     array or a cell array.  By a call of the function `arrayfun' all
     elements of A are passed on to the named function FUNC
     individually.

     The named function can also take more than two input arguments,
     with the input arguments given as third input argument B, fourth
     input argument C, ...  If given more than one array input argument
     then all input arguments must have the same sizes, for example

          arrayfun (@atan2, [1, 0], [0, 1])
          => ans = [1.5708   0.0000]

     If the parameter VAL after a further string input argument
     "UniformOutput" is set `true' (the default), then the named
     function FUNC must return a single element which then will be
     concatenated into the return value and is of type matrix.
     Otherwise, if that parameter is set to `false', then the outputs
     are concatenated in a cell array.  For example

          arrayfun (@(x,y) x:y, "abc", "def", "UniformOutput", false)
          => ans =
          {
            [1,1] = abcd
            [1,2] = bcde
            [1,3] = cdef
          }

     If more than one output arguments are given then the named function
     must return the number of return values that also are expected, for
     example

          [A, B, C] = arrayfun (@find, [10; 0], "UniformOutput", false)
          =>
          A =
          {
            [1,1] =  1
            [2,1] = [](0x0)
          }
          B =
          {
            [1,1] =  1
            [2,1] = [](0x0)
          }
          C =
          {
            [1,1] =  10
            [2,1] = [](0x0)
          }

     If the parameter ERRFUNC after a further string input argument
     "ErrorHandler" is another string, a function handle, an inline
     function or an anonymous function, then ERRFUNC defines a function
     to call in the case that FUNC generates an error.  The definition
     of the function must be of the form

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by S.  This is a structure with the elements
     "identifier", "message" and "index", giving respectively the error
     identifier, the error message and the index of the array elements
     that caused the error.  The size of the output argument of ERRFUNC
     must have the same size as the output argument of FUNC, otherwise
     a real error is thrown.  For example

          function y = ferr (s, x), y = "MyString"; endfunction
          arrayfun (@str2num, [1234], \
                    "UniformOutput", false, "ErrorHandler", @ferr)
          => ans =
          {
           [1,1] = MyString
          }

     See also: cellfun, spfun, structfun
}

#
asctime
{
`asctime' is a function from the file /usr/share/octave/3.2.3/m/time/asctime.m

 -- Function File:  asctime (TM_STRUCT)
     Convert a time structure to a string using the following five-field
     format: Thu Mar 28 08:40:14 1996.  For example,

          asctime (localtime (time ()))
               => "Mon Feb 17 01:15:06 1997\n"

     This is equivalent to `ctime (time ())'.
}

#
asec
{
`asec' is a function from the file /usr/share/octave/3.2.3/m/elfun/asec.m

 -- Mapping Function:  asec (X)
     Compute the inverse secant in radians for each element of X.

     See also: sec, asecd
}

#
asecd
{
`asecd' is a function from the file /usr/share/octave/3.2.3/m/elfun/asecd.m

 -- Function File:  asecd (X)
     Compute the inverse secant in degrees for each element of X.

     See also: secd, asec
}

#
asech
{
`asech' is a function from the file /usr/share/octave/3.2.3/m/elfun/asech.m

 -- Mapping Function:  asech (X)
     Compute the inverse hyperbolic secant of each element of X.

     See also: sech
}

#
asin
{
`asin' is a built-in function

 -- Mapping Function:  asin (X)
     Compute the inverse sine in radians for each element of X.

     See also: sin, asind
}

#
asind
{
`asind' is a function from the file /usr/share/octave/3.2.3/m/elfun/asind.m

 -- Function File:  asind (X)
     Compute the inverse sine in degrees for each element of X.

     See also: sind, asin
}

#
asinh
{
`asinh' is a built-in function

 -- Mapping Function:  asinh (X)
     Compute the inverse hyperbolic sine for each element of X.

     See also: sinh
}

#
assert
{
`assert' is a function from the file /usr/share/octave/3.2.3/m/testfun/assert.m

 -- Function File:  assert (COND)
 -- Function File:  assert (COND, ERRMSG, ...)
 -- Function File:  assert (COND, MSG_ID, ERRMSG, ...)
 -- Function File:  assert (OBSERVED,EXPECTED)
 -- Function File:  assert (OBSERVED,EXPECTED,TOL)
     Produces an error if the condition is not met.  `assert' can be
     called in three different ways.

    `assert (COND)'
    `assert (COND, ERRMSG, ...)'
    `assert (COND, MSG_ID, ERRMSG, ...)'
          Called with a single argument COND, `assert' produces an
          error if COND is zero.  If called with a single argument a
          generic error message.  With more than one argument, the
          additional arguments are passed to the `error' function.

    `assert (OBSERVED, EXPECTED)'
          Produce an error if observed is not the same as expected.
          Note that observed and expected can be strings, scalars,
          vectors, matrices, lists or structures.

    `assert(OBSERVED, EXPECTED, TOL)'
          Accept a tolerance when comparing numbers.  If TOL is
          positive use it as an absolute tolerance, will produce an
          error if `abs(OBSERVED - EXPECTED) > abs(TOL)'.  If TOL is
          negative use it as a relative tolerance, will produce an
          error if `abs(OBSERVED - EXPECTED) > abs(TOL * EXPECTED)'.
          If EXPECTED is zero TOL will always be used as an absolute
          tolerance.

     See also: test
}

#
assignin
{
`assignin' is a built-in function

 -- Built-in Function:  assignin (CONTEXT, VARNAME, VALUE)
     Assign VALUE to VARNAME in context CONTEXT, which may be either
     `"base"' or `"caller"'.
}

#
atan
{
`atan' is a built-in function

 -- Mapping Function:  atan (X)
     Compute the inverse tangent in radians for each element of X.

     See also: tan, atand
}

#
atan2
{
`atan2' is a built-in function

 -- Mapping Function:  atan2 (Y, X)
     Compute atan (Y / X) for corresponding elements of Y and X.
     Signal an error if Y and X do not match in size and orientation.
}

#
atand
{
`atand' is a function from the file /usr/share/octave/3.2.3/m/elfun/atand.m

 -- Function File:  atand (X)
     Compute the inverse tangent in degrees for each element of X.

     See also: tand, atan
}

#
atanh
{
`atanh' is a built-in function

 -- Mapping Function:  atanh (X)
     Compute the inverse hyperbolic tangent for each element of X.

     See also: tanh
}

#
atexit
{
`atexit' is a built-in function

 -- Built-in Function:  atexit (FCN)
 -- Built-in Function:  atexit (FCN, FLAG)
     Register a function to be called when Octave exits.  For example,

          function last_words ()
           disp ("Bye bye");
          endfunction
          atexit ("last_words");

     will print the message "Bye bye" when Octave exits.

     The additional argument FLAG will register or unregister FCN from
     the list of functions to be called when Octave exits.  If FLAG is
     true, the function is registered, and if FLAG is false, it is
     unregistered.  For example, after registering the function
     `last_words' above,

          atexit ("last_words", false);

     will remove the function from the list and Octave will not call
     `last_words' when it exits.

     Note that `atexit' only removes the first occurrence of a function
     from the list, so if a function was placed in the list multiple
     times with `atexit', it must also be removed from the list
     multiple times.
}

#
autocor
{
`autocor' is a function from the file /usr/share/octave/3.2.3/m/signal/autocor.m

 -- Function File:  autocor (X, H)
     Return the autocorrelations from lag 0 to H of vector X.  If H is
     omitted, all autocorrelations are computed.  If X is a matrix, the
     autocorrelations of each column are computed.
}

#
autocov
{
`autocov' is a function from the file /usr/share/octave/3.2.3/m/signal/autocov.m

 -- Function File:  autocov (X, H)
     Return the autocovariances from lag 0 to H of vector X.  If H is
     omitted, all autocovariances are computed.  If X is a matrix, the
     autocovariances of each column are computed.
}

#
autoload
{
`autoload' is a built-in function

 -- Built-in Function:  autoload (FUNCTION, FILE)
     Define FUNCTION to autoload from FILE.

     The second argument, FILE, should be an absolute file name or a
     file name in the same directory as the function or script from
     which the autoload command was run.  FILE should not depend on the
     Octave load path.

     Normally, calls to `autoload' appear in PKG_ADD script files that
     are evaluated when a directory is added to the Octave's load path.
     To avoid having to hardcode directory names in FILE, if FILE is in
     the same directory as the PKG_ADD script then

          autoload ("foo", "bar.oct");

     will load the function `foo' from the file `bar.oct'.  The above
     when `bar.oct' is not in the same directory or uses like

          autoload ("foo", file_in_loadpath ("bar.oct"))

     are strongly discouraged, as their behavior might be unpredictable.

     With no arguments, return a structure containing the current
     autoload map.

     See also: PKG_ADD
}

#
autoreg_matrix
{
`autoreg_matrix' is a function from the file /usr/share/octave/3.2.3/m/signal/autoreg_matrix.m

 -- Function File:  autoreg_matrix (Y, K)
     Given a time series (vector) Y, return a matrix with ones in the
     first column and the first K lagged values of Y in the other
     columns.  I.e., for T > K, `[1, Y(T-1), ..., Y(T-K)]' is the t-th
     row of the result.  The resulting matrix may be used as a
     regressor matrix in autoregressions.
}

#
autumn
{
`autumn' is a function from the file /usr/share/octave/3.2.3/m/image/autumn.m

 -- Function File:  autumn (N)
     Create color colormap.  This colormap is red through orange to
     yellow.  The argument N should be a scalar.  If it is omitted, the
     length of the current colormap or 64 is assumed.

     See also: colormap
}

#
available_backends
{
`available_backends' is a built-in function

 -- Built-in Function:  available_backends ()
     Return a cell array of registered graphics backends.
}

#
axes
{
`axes' is a function from the file /usr/share/octave/3.2.3/m/plot/axes.m

 -- Function File:  axes ()
 -- Function File:  axes (PROPERTY, VALUE, ...)
 -- Function File:  axes (H)
     Create an axes object and return a handle to it.
}

#
axis
{
`axis' is a function from the file /usr/share/octave/3.2.3/m/plot/axis.m

 -- Function File:  axis (LIMITS)
     Set axis limits for plots.

     The argument LIMITS should be a 2, 4, or 6 element vector.  The
     first and second elements specify the lower and upper limits for
     the x axis.  The third and fourth specify the limits for the
     y-axis, and the fifth and sixth specify the limits for the z-axis.

     Without any arguments, `axis' turns autoscaling on.

     With one output argument, `x = axis' returns the current axes

     The vector argument specifying limits is optional, and additional
     string arguments may be used to specify various axis properties.
     For example,

          axis ([1, 2, 3, 4], "square");

     forces a square aspect ratio, and

          axis ("labely", "tic");

     turns tic marks on for all axes and tic mark labels on for the
     y-axis only.

     The following options control the aspect ratio of the axes.

    `"square"'
          Force a square aspect ratio.

    `"equal"'
          Force x distance to equal y-distance.

    `"normal"'
          Restore the balance.

     The following options control the way axis limits are interpreted.

    `"auto"'
          Set the specified axes to have nice limits around the data or
          all if no axes are specified.

    `"manual"'
          Fix the current axes limits.

    `"tight"'
          Fix axes to the limits of the data.

     The option `"image"' is equivalent to `"tight"' and `"equal"'.

     The following options affect the appearance of tic marks.

    `"on"'
          Turn tic marks and labels on for all axes.

    `"off"'
          Turn tic marks off for all axes.

    `"tic[xyz]"'
          Turn tic marks on for all axes, or turn them on for the
          specified axes and off for the remainder.

    `"label[xyz]"'
          Turn tic labels on for all axes, or turn them on for the
          specified axes and off for the remainder.

    `"nolabel"'
          Turn tic labels off for all axes.
     Note, if there are no tic marks for an axis, there can be no
     labels.

     The following options affect the direction of increasing values on
     the axes.

    `"ij"'
          Reverse y-axis, so lower values are nearer the top.

    `"xy"'
          Restore y-axis, so higher values are nearer the top.

     If an axes handle is passed as the first argument, then operate on
     this axes rather than the current axes.
}

#
backend
{
`backend' is a function from the file /usr/share/octave/3.2.3/m/plot/backend.m

 -- Function File:  backend (NAME)
 -- Function File:  backend (HLIST, NAME)
     Change the default graphics backend to NAME.  If the backend is
     not already loaded, it is first initialized (initialization is done
     through the execution of `__init_NAME__').

     When called with a list of figure handles, HLIST, the backend is
     changed only for the listed figures.

     See also: available_backends
}

#
balance
{
`balance' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/balance.oct

 -- Loadable Function: AA = balance (A, OPT)
 -- Loadable Function: [DD, AA] = balance (A, OPT)
 -- Loadable Function: [D, P, AA] = balance (A, OPT)
 -- Loadable Function: [CC, DD, AA, BB] = balance (A, B, OPT)
     Compute `aa = dd \ a * dd' in which `aa' is a matrix whose row and
     column norms are roughly equal in magnitude, and `dd' = `p * d',
     in which `p' is a permutation matrix and `d' is a diagonal matrix
     of powers of two.  This allows the equilibration to be computed
     without roundoff.  Results of eigenvalue calculation are typically
     improved by balancing first.

     If two output values are requested, `balance' returns the diagonal
     `d' and the permutation `p' separately as vectors.  In this case,
     `dd = eye(n)(p,:) * diag (d)', where `n' is the matrix size.

     If four output values are requested, compute `aa = cc*a*dd' and
     `bb = cc*b*dd)', in which `aa' and `bb' have non-zero elements of
     approximately the same magnitude and `cc' and `dd' are permuted
     diagonal matrices as in `dd' for the algebraic eigenvalue problem.

     The eigenvalue balancing option `opt' may be one of:

    `"noperm"', `"S"'
          Scale only; do not permute.

    `"noscal"', `"P"'
          Permute only; do not scale.

     Algebraic eigenvalue balancing uses standard LAPACK routines.

     Generalized eigenvalue problem balancing uses Ward's algorithm
     (SIAM Journal on Scientific and Statistical Computing, 1981).
}

#
bar
{
`bar' is a function from the file /usr/share/octave/3.2.3/m/plot/bar.m

 -- Function File:  bar (X, Y)
 -- Function File:  bar (Y)
 -- Function File:  bar (X, Y, W)
 -- Function File:  bar (X, Y, W, STYLE)
 -- Function File: H = bar (..., PROP, VAL)
 -- Function File:  bar (H, ...)
     Produce a bar graph from two vectors of x-y data.

     If only one argument is given, it is taken as a vector of y-values
     and the x coordinates are taken to be the indices of the elements.

     The default width of 0.8 for the bars can be changed using W.

     If Y is a matrix, then each column of Y is taken to be a separate
     bar graph plotted on the same graph.  By default the columns are
     plotted side-by-side.  This behavior can be changed by the STYLE
     argument, which can take the values `"grouped"' (the default), or
     `"stacked"'.

     The optional return value H provides a handle to the "bar series"
     object with one handle per column of the variable Y.  This series
     allows common elements of the group of bar series objects to be
     changed in a single bar series and the same properties are changed
     in the other "bar series".  For example

          h = bar (rand (5, 10));
          set (h(1), "basevalue", 0.5);

     changes the position on the base of all of the bar series.

     The optional input handle H allows an axis handle to be passed.
     Properties of the patch graphics object can be changed using PROP,
     VAL pairs.

     See also: barh, plot
}

#
barh
{
`barh' is a function from the file /usr/share/octave/3.2.3/m/plot/barh.m

 -- Function File:  barh (X, Y)
 -- Function File:  barh (Y)
 -- Function File:  barh (X, Y, W)
 -- Function File:  barh (X, Y, W, STYLE)
 -- Function File: H = barh (..., PROP, VAL)
 -- Function File:  barh (H, ...)
     Produce a horizontal bar graph from two vectors of x-y data.

     If only one argument is given, it is taken as a vector of y-values
     and the x coordinates are taken to be the indices of the elements.

     The default width of 0.8 for the bars can be changed using W.

     If Y is a matrix, then each column of Y is taken to be a separate
     bar graph plotted on the same graph.  By default the columns are
     plotted side-by-side.  This behavior can be changed by the STYLE
     argument, which can take the values `"grouped"' (the default), or
     `"stacked"'.

     The optional return value H provides a handle to the bar series
     object.  See `bar' for a description of the use of the bar series.

     The optional input handle H allows an axis handle to be passed.
     Properties of the patch graphics object can be changed using PROP,
     VAL pairs.

     See also: bar, plot
}

#
bartlett
{
`bartlett' is a function from the file /usr/share/octave/3.2.3/m/signal/bartlett.m

 -- Function File:  bartlett (M)
     Return the filter coefficients of a Bartlett (triangular) window of
     length M.

     For a definition of the Bartlett window, see e.g., A. V. Oppenheim
     & R. W. Schafer, `Discrete-Time Signal Processing'.
}

#
bartlett_test
{
`bartlett_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/bartlett_test.m

 -- Function File: [PVAL, CHISQ, DF] = bartlett_test (X1, ...)
     Perform a Bartlett test for the homogeneity of variances in the
     data vectors X1, X2, ..., XK, where K > 1.

     Under the null of equal variances, the test statistic CHISQ
     approximately follows a chi-square distribution with DF degrees of
     freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.
}

#
base2dec
{
`base2dec' is a function from the file /usr/share/octave/3.2.3/m/strings/base2dec.m

 -- Function File:  base2dec (S, B)
     Convert S from a string of digits of base B into an integer.

          base2dec ("11120", 3)
               => 123

     If S is a matrix, returns a column vector with one value per row
     of S.  If a row contains invalid symbols then the corresponding
     value will be NaN.  Rows are right-justified before converting so
     that trailing spaces are ignored.

     If B is a string, the characters of B are used as the symbols for
     the digits of S.  Space (' ') may not be used as a symbol.

          base2dec ("yyyzx", "xyz")
               => 123

     See also: dec2base, dec2bin, bin2dec, hex2dec, dec2hex
}

#
beep
{
`beep' is a function from the file /usr/share/octave/3.2.3/m/io/beep.m

 -- Function File:  beep ()
     Produce a beep from the speaker (or visual bell).

     See also: puts, fputs, printf, fprintf
}

#
beep_on_error
{
`beep_on_error' is a built-in function

 -- Built-in Function: VAL = beep_on_error ()
 -- Built-in Function: OLD_VAL = beep_on_error (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will try to ring the terminal bell before printing an error
     message.
}

#
bessel
{
`bessel' is a function from the file /usr/share/octave/3.2.3/m/specfun/bessel.m

 -- Loadable Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Loadable Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Loadable Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Loadable Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Loadable Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

    `besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by `exp(-abs(imag(x)))'.

    `bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by `exp(-abs(imag(x)))'.

    `besseli'
          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by
          `exp(-abs(real(x)))'.

    `besselk'
          Modified Bessel functions of the second kind.  If the
          argument OPT is supplied, the result is multiplied by
          `exp(x)'.

    `besselh'
          Compute Hankel functions of the first (K = 1) or second (K =
          2) kind.  If the argument OPT is supplied, the result is
          multiplied by `exp (-I*X)' for K = 1 or `exp (I*X)' for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a
     scalar, the result is the same size as ALPHA.  If ALPHA is a row
     vector and X is a column vector, the result is a matrix with
     `length (X)' rows and `length (ALPHA)' columns.  Otherwise, ALPHA
     and X must conform and the result will be the same size.

     The value of ALPHA must be real.  The value of X may be complex.

     If requested, IERR contains the following status information and
     is the same size as the result.

       0. Normal return.

       1. Input error, return `NaN'.

       2. Overflow, return `Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          `NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return `NaN'.
}

#
besselh
{
`besselh' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/besselj.oct

 -- Loadable Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     See besselj.
}

#
besseli
{
`besseli' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/besselj.oct

 -- Loadable Function: [I, IERR] = besseli (ALPHA, X, OPT)
     See besselj.
}

#
besselj
{
`besselj' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/besselj.oct

 -- Loadable Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Loadable Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Loadable Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Loadable Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Loadable Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

    `besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by `exp(-abs(imag(x)))'.

    `bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by `exp(-abs(imag(x)))'.

    `besseli'
          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by
          `exp(-abs(real(x)))'.

    `besselk'
          Modified Bessel functions of the second kind.  If the
          argument OPT is supplied, the result is multiplied by
          `exp(x)'.

    `besselh'
          Compute Hankel functions of the first (K = 1) or second (K =
          2) kind.  If the argument OPT is supplied, the result is
          multiplied by `exp (-I*X)' for K = 1 or `exp (I*X)' for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a
     scalar, the result is the same size as ALPHA.  If ALPHA is a row
     vector and X is a column vector, the result is a matrix with
     `length (X)' rows and `length (ALPHA)' columns.  Otherwise, ALPHA
     and X must conform and the result will be the same size.

     The value of ALPHA must be real.  The value of X may be complex.

     If requested, IERR contains the following status information and
     is the same size as the result.

       0. Normal return.

       1. Input error, return `NaN'.

       2. Overflow, return `Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          `NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return `NaN'.
}

#
besselk
{
`besselk' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/besselj.oct

 -- Loadable Function: [K, IERR] = besselk (ALPHA, X, OPT)
     See besselj.
}

#
bessely
{
`bessely' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/besselj.oct

 -- Loadable Function: [Y, IERR] = bessely (ALPHA, X, OPT)
     See besselj.
}

#
beta
{
`beta' is a function from the file /usr/share/octave/3.2.3/m/specfun/beta.m

 -- Mapping Function:  beta (A, B)
     For real inputs, return the Beta function,

          beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
}

#
beta_cdf
{
`beta_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/beta_cdf.m

 -- Function File:  beta_cdf (X, A, B)
     For each element of X, returns the CDF at X of the beta
     distribution with parameters A and B, i.e., PROB (beta (A, B) <=
     X).
}

#
beta_inv
{
`beta_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/beta_inv.m

 -- Function File:  beta_inv (X, A, B)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the Beta distribution with parameters A and B.
}

#
beta_pdf
{
`beta_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/beta_pdf.m

 -- Function File:  beta_pdf (X, A, B)
     For each element of X, returns the PDF at X of the beta
     distribution with parameters A and B.
}

#
beta_rnd
{
`beta_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/beta_rnd.m

 -- Function File:  beta_rnd (A, B, R, C)
 -- Function File:  beta_rnd (A, B, SZ)
     Return an R by C or `size (SZ)' matrix of random samples from the
     Beta distribution with parameters A and B.  Both A and B must be
     scalar or of size R  by C.

     If R and C are omitted, the size of the result matrix is the
     common size of A and B.
}

#
betacdf
{
`betacdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/betacdf.m

 -- Function File:  betacdf (X, A, B)
     For each element of X, returns the CDF at X of the beta
     distribution with parameters A and B, i.e., PROB (beta (A, B) <=
     X).
}

#
betai
{
`betai' is a function from the file /usr/share/octave/3.2.3/m/specfun/betai.m

 -- Function File:  betai (A, B, X)
     This function is provided for compatibility with older versions of
     Octave.  New programs should use betainc instead.

     `betai (A, B, X)' is the same as `betainc (X, A, B)'.
}

#
betainc
{
`betainc' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/betainc.oct

 -- Mapping Function:  betainc (X, A, B)
     Return the incomplete Beta function,

                                               x
                                              /
          betainc (x, a, b) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.
                                              /
                                           t=0

     If x has more than one component, both A and B must be scalars.
     If X is a scalar, A and B must be of compatible dimensions.
}

#
betainv
{
`betainv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/betainv.m

 -- Function File:  betainv (X, A, B)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the Beta distribution with parameters A and B.
}

#
betaln
{
`betaln' is a function from the file /usr/share/octave/3.2.3/m/specfun/betaln.m

 -- Mapping Function:  betaln (A, B)
     Return the log of the Beta function,

          betaln (a, b) = gammaln (a) + gammaln (b) - gammaln (a + b)

     See also: beta, betainc, gammaln
}

#
betapdf
{
`betapdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/betapdf.m

 -- Function File:  betapdf (X, A, B)
     For each element of X, returns the PDF at X of the beta
     distribution with parameters A and B.
}

#
betarnd
{
`betarnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/betarnd.m

 -- Function File:  betarnd (A, B, R, C)
 -- Function File:  betarnd (A, B, SZ)
     Return an R by C or `size (SZ)' matrix of random samples from the
     Beta distribution with parameters A and B.  Both A and B must be
     scalar or of size R  by C.

     If R and C are omitted, the size of the result matrix is the
     common size of A and B.
}

#
bicgstab
{
`bicgstab' is a function from the file /usr/share/octave/3.2.3/m/sparse/bicgstab.m

 -- Function File:  bicgstab (A, B)
 -- Function File:  bicgstab (A, B, TOL, MAXIT, M1, M2, X0)
     This procedure attempts to solve a system of linear equations A*x
     = b for x.  The A must be square, symmetric and positive definite
     real matrix N*N.  The B must be a one column vector with a length
     of N.  The TOL specifies the tolerance of the method, the default
     value is 1e-6.  The MAXIT specifies the maximum number of
     iterations, the default value is min(20,N).  The M1 specifies a
     preconditioner, can also be a function handler which returns M\X.
     The M2 combined with M1 defines preconditioner as
     preconditioner=M1*M2.  The X0 is the initial guess, the default
     value is zeros(N,1).

     The value X is a computed result of this procedure.  The value
     FLAG can be 0 when we reach tolerance in MAXIT iterations, 1 when
     we don't reach tolerance in MAXIT iterations and 3 when the
     procedure stagnates.  The value RELRES is a relative residual -
     norm(b-A*x)/norm(b).  The value ITER is an iteration number in
     which x was computed.  The value RESVEC is a vector of RELRES for
     each iteration.
}

#
bicubic
{
`bicubic' is a function from the file /usr/share/octave/3.2.3/m/general/bicubic.m

 -- Function File: ZI = bicubic (X, Y, Z, XI, YI, EXTRAPVAL)
     Return a matrix ZI corresponding to the bicubic interpolations at
     XI and YI of the data supplied as X, Y and Z.  Points outside the
     grid are set to EXTRAPVAL.

     See `http://wiki.woodpecker.org.cn/moin/Octave/Bicubic' for
     further information.

     See also: interp2
}

#
bin2dec
{
`bin2dec' is a function from the file /usr/share/octave/3.2.3/m/strings/bin2dec.m

 -- Function File:  bin2dec (S)
     Return the decimal number corresponding to the binary number stored
     in the string S.  For example,

          bin2dec ("1110")
               => 14

     If S is a string matrix, returns a column vector of converted
     numbers, one per row of S.  Invalid rows evaluate to NaN.

     See also: dec2hex, base2dec, dec2base, hex2dec, dec2bin
}

#
bincoeff
{
`bincoeff' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/bincoeff.m

 -- Mapping Function:  bincoeff (N, K)
     Return the binomial coefficient of N and K, defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)
           |   |  = -------------------------
           | k |               k!
           \   /

     For example,

          bincoeff (5, 2)
               => 10

     In most cases, the `nchoosek' function is faster for small scalar
     integer arguments.  It also warns about loss of precision for big
     arguments.

     See also: nchoosek
}

#
binocdf
{
`binocdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/binocdf.m

 -- Function File:  binocdf (X, N, P)
     For each element of X, compute the CDF at X of the binomial
     distribution with parameters N and P.
}

#
binoinv
{
`binoinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/binoinv.m

 -- Function File:  binoinv (X, N, P)
     For each element of X, compute the quantile at X of the binomial
     distribution with parameters N and P.
}

#
binomial_cdf
{
`binomial_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/binomial_cdf.m

 -- Function File:  binomial_cdf (X, N, P)
     For each element of X, compute the CDF at X of the binomial
     distribution with parameters N and P.
}

#
binomial_inv
{
`binomial_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/binomial_inv.m

 -- Function File:  binomial_inv (X, N, P)
     For each element of X, compute the quantile at X of the binomial
     distribution with parameters N and P.
}

#
binomial_pdf
{
`binomial_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/binomial_pdf.m

 -- Function File:  binomial_pdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the binomial distribution with parameters N and P.
}

#
binomial_rnd
{
`binomial_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/binomial_rnd.m

 -- Function File:  binomial_rnd (N, P, R, C)
 -- Function File:  binomial_rnd (N, P, SZ)
     Return an R by C  or a `size (SZ)' matrix of random samples from
     the binomial distribution with parameters N and P.  Both N and P
     must be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of N and P.
}

#
binopdf
{
`binopdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/binopdf.m

 -- Function File:  binopdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the binomial distribution with parameters N and P.
}

#
binornd
{
`binornd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/binornd.m

 -- Function File:  binornd (N, P, R, C)
 -- Function File:  binornd (N, P, SZ)
     Return an R by C  or a `size (SZ)' matrix of random samples from
     the binomial distribution with parameters N and P.  Both N and P
     must be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of N and P.
}

#
bitand
{
`bitand' is a built-in function

 -- Built-in Function:  bitand (X, Y)
     Return the bitwise AND of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax
}

#
bitcmp
{
`bitcmp' is a function from the file /usr/share/octave/3.2.3/m/general/bitcmp.m

 -- Function File:  bitcmp (A, K)
     Return the K-bit complement of integers in A.  If K is omitted `k
     = log2 (bitmax) + 1' is assumed.

          bitcmp(7,4)
          => 8
          dec2bin(11)
          => 1011
          dec2bin(bitcmp(11, 6))
          => 110100

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift,
     bitmax
}

#
bitget
{
`bitget' is a function from the file /usr/share/octave/3.2.3/m/general/bitget.m

 -- Function File: X = bitget (A,N)
     Return the status of bit(s) N of unsigned integers in A the lowest
     significant bit is N = 1.

          bitget (100, 8:-1:1)
          => 0  1  1  0  0  1  0  0

     See also: bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax
}

#
bitmax
{
`bitmax' is a built-in function

 -- Built-in Function:  bitmax ()
     Return the largest integer that can be represented as a floating
     point value.  On IEEE-754 compatible systems, `bitmax' is `2^53 -
     1'.
}

#
bitor
{
`bitor' is a built-in function

 -- Built-in Function:  bitor (X, Y)
     Return the bitwise OR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax
}

#
bitset
{
`bitset' is a function from the file /usr/share/octave/3.2.3/m/general/bitset.m

 -- Function File: X = bitset (A, N)
 -- Function File: X = bitset (A, N, V)
     Set or reset bit(s) N of unsigned integers in A.  V = 0 resets and
     V = 1 sets the bits.  The lowest significant bit is: N = 1

          dec2bin (bitset (10, 1))
          => 1011

     See also: bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax
}

#
bitshift
{
`bitshift' is a built-in function

 -- Built-in Function:  bitshift (A, K)
 -- Built-in Function:  bitshift (A, K, N)
     Return a K bit shift of N-digit unsigned integers in A.  A
     positive K leads to a left shift.  A negative value to a right
     shift.  If N is omitted it defaults to log2(bitmax)+1.  N must be
     in the range [1,log2(bitmax)+1] usually [1,33]

          bitshift (eye (3), 1)
          =>
          2 0 0
          0 2 0
          0 0 2

          bitshift (10, [-2, -1, 0, 1, 2])
          => 2   5  10  20  40

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax
}

#
bitxor
{
`bitxor' is a built-in function

 -- Built-in Function:  bitxor (X, Y)
     Return the bitwise XOR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax
}

#
blackman
{
`blackman' is a function from the file /usr/share/octave/3.2.3/m/signal/blackman.m

 -- Function File:  blackman (M)
     Return the filter coefficients of a Blackman window of length M.

     For a definition of the Blackman window, see e.g., A. V. Oppenheim
     & R. W. Schafer, `Discrete-Time Signal Processing'.
}

#
blanks
{
`blanks' is a function from the file /usr/share/octave/3.2.3/m/strings/blanks.m

 -- Function File:  blanks (N)
     Return a string of N blanks, for example:

          blanks(10);
          whos ans;
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     ans         1x10                        10  char

     See also: repmat
}

#
blkdiag
{
`blkdiag' is a function from the file /usr/share/octave/3.2.3/m/general/blkdiag.m

 -- Function File:  blkdiag (A, B, C, ...)
     Build a block diagonal matrix from A, B, C, ....  All the
     arguments must be numeric and are two-dimensional matrices or
     scalars.

     See also: diag, horzcat, vertcat
}

#
bone
{
`bone' is a function from the file /usr/share/octave/3.2.3/m/image/bone.m

 -- Function File:  bone (N)
     Create color colormap.  This colormap is a gray colormap with a
     light blue tone.  The argument N should be a scalar.  If it is
     omitted, the length of the current colormap or 64 is assumed.

     See also: colormap
}

#
box
{
`box' is a function from the file /usr/share/octave/3.2.3/m/plot/box.m

 -- Function File:  box (ARG)
 -- Function File:  box (H, ...)
     Control the display of a border around the plot.  The argument may
     be either `"on"' or `"off"'.  If it is omitted, the current box
     state is toggled.

     See also: grid
}

#
break
{

 -- Keyword: break
     Exit the innermost enclosing do, while or for loop.

     See also: do, while, for, continue
}

#
brighten
{
`brighten' is a function from the file /usr/share/octave/3.2.3/m/image/brighten.m

 -- Function File: MAP_OUT = brighten (MAP, BETA)
 -- Function File: MAP_OUT = brighten (H, BETA)
 -- Function File: MAP_OUT = brighten (BETA)
     Darkens or brightens the given colormap.  If the MAP argument is
     omitted, the function is applied to the current colormap.  The
     first argument can also be a valid graphics handle H, in which case
     `brighten' is applied to the colormap associated with this handle.

     Should the resulting colormap MAP_OUT not be assigned, it will be
     written to the current colormap.

     The argument BETA should be a scalar between -1 and 1, where a
     negative value darkens and a positive value brightens the colormap.

     See also: colormap
}

#
bsxfun
{
`bsxfun' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/bsxfun.oct

 -- Loadable Function:  bsxfun (F, A, B)
     Applies a binary function F element-wise to two matrix arguments A
     and B.  The function F must be capable of accepting two column
     vector arguments of equal length, or one column vector argument
     and a scalar.

     The dimensions of A and B must be equal or singleton.  The
     singleton dimensions of the matrices will be expanded to the same
     dimensionality as the other matrix.

     See also: arrayfun, cellfun
}

#
bug_report
{
`bug_report' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/bug_report.m

 -- Function File:  bug_report ()
     Have Octave create a bug report template file, invoke your favorite
     editor, and submit the report to the bug-octave mailing list when
     you are finished editing.
}

#
builtin
{
`builtin' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dispatch.oct

 -- Loadable Function: [...] builtin (F, ...)
     Call the base function F even if F is overloaded to some other
     function for the given type signature.

     See also: dispatch
}

#
bunzip2
{
`bunzip2' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/bunzip2.m

 -- Function File:  bunzip2 (BZFILE, DIR)
     Unpack the bzip2 archive BZFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: unpack, bzip2, tar, untar, gzip, gunzip, zip, unzip
}

#
bzip2
{
`bzip2' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/bzip2.m

 -- Function File: ENTRIES = bzip2 (FILES)
 -- Function File: ENTRIES = bzip2 (FILES, OUTDIR)
     Compress the list of files specified in FILES.  Each file is
     compressed separately and a new file with a '.bz2' extension is
     created.  The original files are not touched.  Existing compressed
     files are silently overwritten.If OUTDIR is defined the compressed
     versions of the files are placed in this directory.

     See also: bunzip2, gzip, zip, tar
}

#
calendar
{
`calendar' is a function from the file /usr/share/octave/3.2.3/m/time/calendar.m

 -- Function File:  calendar (...)
 -- Function File: C = calendar ()
 -- Function File: C = calendar (D)
 -- Function File: C = calendar (Y, M)
     If called with no arguments, return the current monthly calendar in
     a 6x7 matrix.

     If D is specified, return the calendar for the month containing
     the day D, which must be a serial date number or a date string.

     If Y and M are specified, return the calendar for year Y and month
     M.

     If no output arguments are specified, print the calendar on the
     screen instead of returning a matrix.

     See also: datenum
}

#
canonicalize_file_name
{
`canonicalize_file_name' is a built-in function

 -- Built-in Function: [CNAME, STATUS, MSG] canonicalize_file_name
          (NAME)
     Return the canonical name of file NAME.
}

#
cart2pol
{
`cart2pol' is a function from the file /usr/share/octave/3.2.3/m/general/cart2pol.m

 -- Function File: [THETA, R] = cart2pol (X, Y)
 -- Function File: [THETA, R, Z] = cart2pol (X, Y, Z)
     Transform Cartesian to polar or cylindrical coordinates.  X, Y
     (and Z) must be the same shape, or scalar.  THETA describes the
     angle relative to the positive x-axis.  R is the distance to the
     z-axis (0, 0, z).

     See also: pol2cart, cart2sph, sph2cart
}

#
cart2sph
{
`cart2sph' is a function from the file /usr/share/octave/3.2.3/m/general/cart2sph.m

 -- Function File: [THETA, PHI, R] = cart2sph (X, Y, Z)
     Transform Cartesian to spherical coordinates.  X, Y and Z must be
     the same shape, or scalar.  THETA describes the angle relative to
     the positive x-axis.  PHI is the angle relative to the xy-plane.
     R is the distance to the origin (0, 0, 0).

     See also: pol2cart, cart2pol, sph2cart
}

#
case
{

 -- Keyword: case {VALUE}
     A case statement in an switch.  Octave cases are exclusive and do
     not fall-through as do C-language cases.  A switch statement must
     have at least one case.  See `switch' for an example.

     See also: switch
}

#
cast
{
`cast' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/cast.m

 -- Function File:  cast (VAL, TYPE)
     Convert VAL to data type TYPE.

     See also: int8, uint8, int16, uint16, int32, uint32, int64,
     uint64, double
}

#
cat
{
`cat' is a built-in function

 -- Built-in Function:  cat (DIM, ARRAY1, ARRAY2, ..., ARRAYN)
     Return the concatenation of N-d array objects, ARRAY1, ARRAY2,
     ..., ARRAYN along dimension DIM.

          A = ones (2, 2);
          B = zeros (2, 2);
          cat (2, A, B)
          => ans =

              1 1 0 0
              1 1 0 0

     Alternatively, we can concatenate A and B along the second
     dimension the following way:

          [A, B].

     DIM can be larger than the dimensions of the N-d array objects and
     the result will thus have DIM dimensions as the following example
     shows:
          cat (4, ones(2, 2), zeros (2, 2))
          => ans =

            ans(:,:,1,1) =

              1 1
              1 1

            ans(:,:,1,2) =
              0 0
              0 0

     See also: horzcat, vertcat
}

#
catch
{

 -- Keyword: catch
     Begin the cleanup part of a try-catch block.

     See also: try
}

#
cauchy_cdf
{
`cauchy_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/cauchy_cdf.m

 -- Function File:  cauchy_cdf (X, LAMBDA, SIGMA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Cauchy distribution with location
     parameter LAMBDA and scale parameter SIGMA.  Default values are
     LAMBDA = 0, SIGMA = 1.
}

#
cauchy_inv
{
`cauchy_inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/cauchy_inv.m

 -- Function File:  cauchy_inv (X, LAMBDA, SIGMA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Cauchy distribution with location parameter
     LAMBDA and scale parameter SIGMA.  Default values are LAMBDA = 0,
     SIGMA = 1.
}

#
cauchy_pdf
{
`cauchy_pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/cauchy_pdf.m

 -- Function File:  cauchy_pdf (X, LAMBDA, SIGMA)
     For each element of X, compute the probability density function
     (PDF) at X of the Cauchy distribution with location parameter
     LAMBDA and scale parameter SIGMA > 0.  Default values are LAMBDA =
     0, SIGMA = 1.
}

#
cauchy_rnd
{
`cauchy_rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/cauchy_rnd.m

 -- Function File:  cauchy_rnd (LAMBDA, SIGMA, R, C)
 -- Function File:  cauchy_rnd (LAMBDA, SIGMA, SZ)
     Return an R by C or a `size (SZ)' matrix of random samples from
     the Cauchy distribution with parameters LAMBDA and SIGMA which
     must both be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of LAMBDA and SIGMA.
}

#
caxis
{
`caxis' is a function from the file /usr/share/octave/3.2.3/m/plot/caxis.m

 -- Function File:  caxis (LIMITS)
 -- Function File:  caxis (H, ...)
     Set color axis limits for plots.

     The argument LIMITS should be a 2 element vector specifying the
     lower and upper limits to assign to the first and last value in the
     colormap.  Values outside this range are clamped to the first and
     last colormap entries.

     If LIMITS is 'auto', then automatic colormap scaling is applied,
     whereas if LIMITS is 'manual' the colormap scaling is set to
     manual.

     Called without any arguments to current color axis limits are
     returned.

     If an axes handle is passed as the first argument, then operate on
     this axes rather than the current axes.
}

#
ccolamd
{
`ccolamd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/ccolamd.oct

 -- Loadable Function: P = ccolamd (S)
 -- Loadable Function: P = ccolamd (S, KNOBS)
 -- Loadable Function: P = ccolamd (S, KNOBS, CMEMBER)
 -- Loadable Function: [P, STATS] = ccolamd (...)
     Constrained column approximate minimum degree permutation.  `P =
     ccolamd (S)' returns the column approximate minimum degree
     permutation vector for the sparse matrix S.  For a non-symmetric
     matrix S, `S (:, P)' tends to have sparser LU factors than S.
     `chol (S (:, P)' * S (:, P))' also tends to be sparser than `chol
     (S' * S)'.  `P = ccolamd (S, 1)' optimizes the ordering for `lu (S
     (:, P))'.  The ordering is followed by a column elimination tree
     post-ordering.

     KNOBS is an optional one- to five-element input vector, with a
     default value of `[0 10 10 1 0]' if not present or empty.  Entries
     not present are set to their defaults.

    `KNOBS(1)'
          if nonzero, the ordering is optimized for `lu (S (:, p))'.
          It will be a poor ordering for `chol (S (:, P)' * S (:, P))'.
          This is the most important knob for ccolamd.

    `KNOB(2)'
          if S is m-by-n, rows with more than `max (16, KNOBS (2) *
          sqrt (n))' entries are ignored.

    `KNOB(3)'
          columns with more than `max (16, KNOBS (3) * sqrt (min (M,
          N)))' entries are ignored and ordered last in the output
          permutation (subject to the cmember constraints).

    `KNOB(4)'
          if nonzero, aggressive absorption is performed.

    `KNOB(5)'
          if nonzero, statistics and knobs are printed.


     CMEMBER is an optional vector of length n.  It defines the
     constraints on the column ordering.  If `CMEMBER (j) = C', then
     column J is in constraint set C (C must be in the range 1 to N).
     In the output permutation P, all columns in set 1 appear first,
     followed by all columns in set 2, and so on.  `CMEMBER =
     ones(1,n)' if not present or empty.  `ccolamd (S, [], 1 : N)'
     returns `1 : N'

     `P = ccolamd (S)' is about the same as `P = colamd (S)'.  KNOBS
     and its default values differ.  `colamd' always does aggressive
     absorption, and it finds an ordering suitable for both `lu (S (:,
     P))' and `chol (S (:, P)' * S (:, P))'; it cannot optimize its
     ordering for `lu (S (:, P))' to the extent that `ccolamd (S, 1)'
     can.

     STATS is an optional 20-element output vector that provides data
     about the ordering and the validity of the input matrix S.
     Ordering statistics are in `STATS (1 : 3)'.  `STATS (1)' and
     `STATS (2)' are the number of dense or empty rows and columns
     ignored by CCOLAMD and `STATS (3)' is the number of garbage
     collections performed on the internal data structure used by
     CCOLAMD (roughly of size `2.2 * nnz (S) + 4 * M + 7 * N' integers).

     `STATS (4 : 7)' provide information if CCOLAMD was able to
     continue.  The matrix is OK if `STATS (4)' is zero, or 1 if
     invalid.  `STATS (5)' is the rightmost column index that is
     unsorted or contains duplicate entries, or zero if no such column
     exists.  `STATS (6)' is the last seen duplicate or out-of-order row
     index in the column index given by `STATS (5)', or zero if no such
     row index exists.  `STATS (7)' is the number of duplicate or
     out-of-order row indices.  `STATS (8 : 20)' is always zero in the
     current version of CCOLAMD (reserved for future use).

     The authors of the code itself are S. Larimore, T. Davis (Uni of
     Florida) and S. Rajamanickam in collaboration with J. Bilbert and
     E. Ng.  Supported by the National Science Foundation (DMS-9504974,
     DMS-9803599, CCR-0203270), and a grant from Sandia National Lab.
     See `http://www.cise.ufl.edu/research/sparse' for ccolamd,
     csymamd, amd, colamd, symamd, and other related orderings.

     See also: colamd, csymamd
}

#
cd
{
`cd' is a built-in function

 -- Command: cd dir
 -- Command: chdir dir
     Change the current working directory to DIR.  If DIR is omitted,
     the current directory is changed to the user's home directory.
     For example,

          cd ~/octave

     Changes the current working directory to `~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

     See also: mkdir, rmdir, dir
}

#
ceil
{
`ceil' is a built-in function

 -- Mapping Function:  ceil (X)
     Return the smallest integer not less than X.  This is equivalent to
     rounding towards positive infinity.  If X is complex, return `ceil
     (real (X)) + ceil (imag (X)) * I'.
          ceil ([-2.7, 2.7])
            =>  -2   3

     See also: floor, round, fix
}

#
cell
{
`cell' is a built-in function

 -- Built-in Function:  cell (X)
 -- Built-in Function:  cell (N, M)
     Create a new cell array object.  If invoked with a single scalar
     argument, `cell' returns a square cell array with the dimension
     specified.  If you supply two scalar arguments, `cell' takes them
     to be the number of rows and columns.  If given a vector with two
     elements, `cell' uses the values of the elements as the number of
     rows and columns, respectively.
}

#
cell2mat
{
`cell2mat' is a function from the file /usr/share/octave/3.2.3/m/general/cell2mat.m

 -- Function File: M = cell2mat (C)
     Convert the cell array C into a matrix by concatenating all
     elements of C into a hyperrectangle.  Elements of C must be
     numeric, logical or char, and `cat' must be able to concatenate
     them together.

     See also: mat2cell, num2cell
}

#
cell2struct
{
`cell2struct' is a built-in function

 -- Built-in Function:  cell2struct (CELL, FIELDS, DIM)
     Convert CELL to a structure.  The number of fields in FIELDS must
     match the number of elements in CELL along dimension DIM, that is
     `numel (FIELDS) == size (CELL, DIM)'.

          A = cell2struct ({'Peter', 'Hannah', 'Robert';
                            185, 170, 168},
                          {'Name','Height'}, 1);
          A(1)
          => ans =
               {
                 Height = 185
                 Name   = Peter
               }
}

#
celldisp
{
`celldisp' is a function from the file /usr/share/octave/3.2.3/m/general/celldisp.m

 -- Function File:  celldisp (C, NAME)
     Recursively display the contents of a cell array.  By default the
     values are displayed with the name of the variable C.  However,
     this name can be replaced with the variable NAME.

     See also: disp
}

#
cellfun
{
`cellfun' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/cellfun.oct

 -- Loadable Function:  cellfun (NAME, C)
 -- Loadable Function:  cellfun ("size", C, K)
 -- Loadable Function:  cellfun ("isclass", C, CLASS)
 -- Loadable Function:  cellfun (FUNC, C)
 -- Loadable Function:  cellfun (FUNC, C, D)
 -- Loadable Function: [A, B] = cellfun (...)
 -- Loadable Function:  cellfun (..., 'ErrorHandler', ERRFUNC)
 -- Loadable Function:  cellfun (..., 'UniformOutput', VAL)
     Evaluate the function named NAME on the elements of the cell array
     C.  Elements in C are passed on to the named function
     individually.  The function NAME can be one of the functions

    `isempty'
          Return 1 for empty elements.

    `islogical'
          Return 1 for logical elements.

    `isreal'
          Return 1 for real elements.

    `length'
          Return a vector of the lengths of cell elements.

    `ndims'
          Return the number of dimensions of each element.

    `prodofsize'
          Return the product of dimensions of each element.

    `size'
          Return the size along the K-th dimension.

    `isclass'
          Return 1 for elements of CLASS.

     Additionally, `cellfun' accepts an arbitrary function FUNC in the
     form of an inline function, function handle, or the name of a
     function (in a character string).  In the case of a character
     string argument, the function must accept a single argument named
     X, and it must return a string value.  The function can take one
     or more arguments, with the inputs args given by C, D, etc.
     Equally the function can return one or more output arguments.  For
     example

          cellfun (@atan2, {1, 0}, {0, 1})
          =>ans = [1.57080   0.00000]

     Note that the default output argument is an array of the same size
     as the input arguments.

     If the parameter 'UniformOutput' is set to true (the default),
     then the function must return a single element which will be
     concatenated into the return value.  If 'UniformOutput' is false,
     the outputs are concatenated in a cell array.  For example

          cellfun ("tolower(x)", {"Foo", "Bar", "FooBar"},
                  "UniformOutput",false)
          => ans = {"foo", "bar", "foobar"}

     Given the parameter 'ErrorHandler', then ERRFUNC defines a
     function to call in case FUNC generates an error.  The form of the
     function is

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by S.  This is a structure with the elements
     'identifier', 'message' and 'index', giving respectively the error
     identifier, the error message, and the index into the input
     arguments of the element that caused the error.  For example

          function y = foo (s, x), y = NaN; endfunction
          cellfun (@factorial, {-1,2},'ErrorHandler',@foo)
          => ans = [NaN 2]

     See also: isempty, islogical, isreal, length, ndims, numel, size
}

#
cellidx
{
`cellidx' is a function from the file /usr/share/octave/3.2.3/m/general/cellidx.m

 -- Function File: [IDXVEC, ERRMSG] = cellidx (LISTVAR, STRLIST)
     Return indices of string entries in LISTVAR that match strings in
     STRLIST.

     Both LISTVAR and STRLIST may be passed as strings or string
     matrices.  If they are passed as string matrices, each entry is
     processed by `deblank' prior to searching for the entries.

     The first output is the vector of indices in LISTVAR.

     If STRLIST contains a string not in LISTVAR, then an error message
     is returned in ERRMSG.  If only one output argument is requested,
     then CELLIDX prints ERRMSG to the screen and exits with an error.
}

#
cellslices
{
`cellslices' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/cellfun.oct

 -- Loadable Function: SL = cellslices (X, LB, UB)
     Given a vector X, this function produces a cell array of slices
     from the vector determined by the index vectors LB, UB, for lower
     and upper bounds, respectively.  In other words, it is equivalent
     to the following code:

          n = length (lb);
          sl = cell (1, n);
          for i = 1:length (lb)
           sl{i} = x(lb(i):ub(i));
          endfor

     If X is a matrix or array, indexing is done along the last
     dimension.

     See also: mat2cell
}

#
cellstr
{
`cellstr' is a built-in function

 -- Built-in Function:  cellstr (STRING)
     Create a new cell array object from the elements of the string
     array STRING.
}

#
center
{
`center' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/center.m

 -- Function File:  center (X)
 -- Function File:  center (X, DIM)
     If X is a vector, subtract its mean.  If X is a matrix, do the
     above for each column.  If the optional argument DIM is given,
     perform the above operation along this dimension
}

#
cgs
{
`cgs' is a function from the file /usr/share/octave/3.2.3/m/sparse/cgs.m

 -- Function File:  cgs (A, B)
 -- Function File:  cgs (A, B, TOL, MAXIT, M1, M2, X0)
     This procedure attempts to solve a system of linear equations A*x
     = b for x.  The A must be square, symmetric and positive definite
     real matrix N*N.  The B must be a one column vector with a length
     of N.  The TOL specifies the tolerance of the method, default
     value is 1e-6.  The MAXIT specifies the maximum number of
     iteration, default value is MIN(20,N).  The M1 specifies a
     preconditioner, can also be a function handler which returns M\X.
     The M2 combined with M1 defines preconditioner as
     preconditioner=M1*M2.  The X0 is initial guess, default value is
     zeros(N,1).
}

#
char
{
`char' is a built-in function

 -- Built-in Function:  char (X)
 -- Built-in Function:  char (X, ...)
 -- Built-in Function:  char (S1, S2, ...)
 -- Built-in Function:  char (CELL_ARRAY)
     Create a string array from one or more numeric matrices, character
     matrices, or cell arrays.  Arguments are concatenated vertically.
     The returned values are padded with blanks as needed to make each
     row of the string array have the same length.  Empty input strings
     are significant and will concatenated in the output.

     For numerical input, each element is converted to the
     corresponding ASCII character.  A range error results if an input
     is outside the ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through `char' can mostly be converted back with
     `cellstr'.  For example,

          char ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
              => ["abc    "
                  "       "
                  "98     "
                  "99     "
                  "d      "
                  "str1   "
                  "half   "]

     See also: strvcat, cellstr
}

#
chdir
{
`chdir' is a built-in function

 -- Command: cd dir
 -- Command: chdir dir
     Change the current working directory to DIR.  If DIR is omitted,
     the current directory is changed to the user's home directory.
     For example,

          cd ~/octave

     Changes the current working directory to `~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

     See also: mkdir, rmdir, dir
}

#
chi2cdf
{
`chi2cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/chi2cdf.m

 -- Function File:  chi2cdf (X, N)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the chisquare distribution with N degrees
     of freedom.
}

#
chi2inv
{
`chi2inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/chi2inv.m

 -- Function File:  chi2inv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the chisquare distribution with N degrees of freedom.
}

#
chi2pdf
{
`chi2pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/chi2pdf.m

 -- Function File:  chisquare_pdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the chisquare distribution with N degrees of freedom.
}

#
chi2rnd
{
`chi2rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/chi2rnd.m

 -- Function File:  chi2rnd (N, R, C)
 -- Function File:  chi2rnd (N, SZ)
     Return an R by C  or a `size (SZ)' matrix of random samples from
     the chisquare distribution with N degrees of freedom.  N must be a
     scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the size
     of N.
}

#
chisquare_cdf
{
`chisquare_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/chisquare_cdf.m

 -- Function File:  chisquare_cdf (X, N)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the chisquare distribution with N degrees
     of freedom.
}

#
chisquare_inv
{
`chisquare_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/chisquare_inv.m

 -- Function File:  chisquare_inv (X, N)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the chisquare distribution with N degrees of freedom.
}

#
chisquare_pdf
{
`chisquare_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/chisquare_pdf.m

 -- Function File:  chisquare_pdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the chisquare distribution with N degrees of freedom.
}

#
chisquare_rnd
{
`chisquare_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/chisquare_rnd.m

 -- Function File:  chisquare_rnd (N, R, C)
 -- Function File:  chisquare_rnd (N, SZ)
     Return an R by C  or a `size (SZ)' matrix of random samples from
     the chisquare distribution with N degrees of freedom.  N must be a
     scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the size
     of N.
}

#
chisquare_test_homogeneity
{
`chisquare_test_homogeneity' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/chisquare_test_homogeneity.m

 -- Function File: [PVAL, CHISQ, DF] = chisquare_test_homogeneity (X,
          Y, C)
     Given two samples X and Y, perform a chisquare test for
     homogeneity of the null hypothesis that X and Y come from the same
     distribution, based on the partition induced by the (strictly
     increasing) entries of C.

     For large samples, the test statistic CHISQ approximately follows a
     chisquare distribution with DF = `length (C)' degrees of freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.
}

#
chisquare_test_independence
{
`chisquare_test_independence' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/chisquare_test_independence.m

 -- Function File: [PVAL, CHISQ, DF] = chisquare_test_independence (X)
     Perform a chi-square test for independence based on the contingency
     table X.  Under the null hypothesis of independence, CHISQ
     approximately has a chi-square distribution with DF degrees of
     freedom.

     The p-value (1 minus the CDF of this distribution at chisq) of the
     test is returned in PVAL.

     If no output argument is given, the p-value is displayed.
}

#
chol
{
`chol' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function: R = chol (A)
 -- Loadable Function: [R, P] = chol (A)
 -- Loadable Function: [R, P, Q] = chol (S)
 -- Loadable Function: [R, P, Q] = chol (S, 'vector')
 -- Loadable Function: [L, ...] = chol (..., 'lower')
     Compute the Cholesky factor, R, of the symmetric positive definite
     matrix A, where

          R' * R = A.

     Called with one output argument `chol' fails if A or S is not
     positive definite.  With two or more output arguments P flags
     whether the matrix was positive definite and `chol' does not fail.
     A zero value indicated that the matrix was positive definite and
     the R gives the factorization, and P will have a positive value
     otherwise.

     If called with 3 outputs then a sparsity preserving row/column
     permutation is applied to A prior to the factorization.  That is R
     is the factorization of `A(Q,Q)' such that

          R' * R = Q' * A * Q.

     The sparsity preserving permutation is generally returned as a
     matrix.  However, given the flag 'vector', Q will be returned as a
     vector such that

          R' * R = a (Q, Q).

     Called with either a sparse or full matrix and using the 'lower'
     flag, `chol' returns the lower triangular factorization such that

          L * L' = A.

     In general the lower triangular factorization is significantly
     faster for sparse matrices.

     See also: cholinv, chol2inv
}

#
chol2inv
{
`chol2inv' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function:  chol2inv (U)
     Invert a symmetric, positive definite square matrix from its
     Cholesky decomposition, U.  Note that U should be an
     upper-triangular matrix with positive diagonal elements.
     `chol2inv (U)' provides `inv (U'*U)' but it is much faster than
     using `inv'.

     See also: chol, cholinv
}

#
choldelete
{
`choldelete' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function: R1 = choldelete (R, J)
     Given a Cholesky factorization of a real symmetric or complex
     hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A(p,p), where
     p = [1:j-1,j+1:n+1].

     See also: chol, cholupdate, cholinsert
}

#
cholinsert
{
`cholinsert' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function: [R1, INFO] = cholinsert (R, J, U)
     Given a Cholesky factorization of a real symmetric or complex
     hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A1, where A1(p,p) = A,
     A1(:,j) = A1(j,:)' = u and p = [1:j-1,j+1:n+1].  u(j) should be
     positive.  On return, INFO is set to
        * 0 if the insertion was successful,

        * 1 if A1 is not positive definite,

        * 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and
     2.

     See also: chol, cholupdate, choldelete
}

#
cholinv
{
`cholinv' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function:  cholinv (A)
     Use the Cholesky factorization to compute the inverse of the
     symmetric positive definite matrix A.

     See also: chol, chol2inv
}

#
cholshift
{
`cholshift' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function: R1 = cholshift (R, I, J)
     Given a Cholesky factorization of a real symmetric or complex
     hermitian positive definite matrix A = R'*R, R upper triangular,
     return the Cholesky factorization of A(p,p), where p is the
     permutation
     `p = [1:i-1, shift(i:j, 1), j+1:n]' if I < J
     or
     `p = [1:j-1, shift(j:i,-1), i+1:n]' if J < I.
     See also: chol, cholinsert, choldelete
}

#
cholupdate
{
`cholupdate' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/chol.oct

 -- Loadable Function: [R1, INFO] = cholupdate (R, U, OP)
     Update or downdate a Cholesky factorization.  Given an upper
     triangular matrix R and a column vector U, attempt to determine
     another upper triangular matrix R1 such that
        * R1'*R1 = R'*R + U*U' if OP is "+"

        * R1'*R1 = R'*R - U*U' if OP is "-"

     If OP is "-", INFO is set to
        * 0 if the downdate was successful,

        * 1 if R'*R - U*U' is not positive definite,

        * 2 if R is singular.

     If INFO is not present, an error message is printed in cases 1 and
     2.

     See also: chol, qrupdate
}

#
circshift
{
`circshift' is a function from the file /usr/share/octave/3.2.3/m/general/circshift.m

 -- Function File: Y = circshift (X, N)
     Circularly shifts the values of the array X.  N must be a vector
     of integers no longer than the number of dimensions in X.  The
     values of N can be either positive or negative, which determines
     the direction in which the values or X are shifted.  If an element
     of N is zero, then the corresponding dimension of X will not be
     shifted.  For example

          x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
          circshift (x, 1)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, -2)
          =>  7, 8, 9
              1, 2, 3
              4, 5, 6
          circshift (x, [0,1])
          =>  3, 1, 2
              6, 4, 5
              9, 7, 8

     See also: permute, ipermute, shiftdim
}

#
cla
{
`cla' is a function from the file /usr/share/octave/3.2.3/m/plot/cla.m

 -- Function File:  cla ()
 -- Function File:  cla ("reset")
 -- Function File:  cla (HAX)
 -- Function File:  cla (HAX, "reset")
     Delete the children of the current axes with visible handles.  If
     HAX is specified and is an axes object handle, operate on it
     instead of the current axes.  If the optional argument `"reset"'
     is specified, also delete the children with hidden handles.

     See also: clf
}

#
clabel
{
`clabel' is a function from the file /usr/share/octave/3.2.3/m/plot/clabel.m

 -- Function File:  clabel (C, H)
 -- Function File:  clabel (C, H, V)
 -- Function File:  clabel (C, H, "manual")
 -- Function File:  clabel (C)
 -- Function File:  clabel (C, H)
 -- Function File:  clabel (..., PROP, VAL, ...)
 -- Function File: H = clabel (...)
     Adds labels to the contours of a contour plot.  The contour plot
     is specified by the contour matrix C and optionally the
     contourgroup object H that are returned by `contour', `contourf'
     and `contour3'.  The contour labels are rotated and placed in the
     contour itself.

     By default, all contours are labelled.  However, the contours to
     label can be specified by the vector V.  If the "manual" argument
     is given then the contours to label can be selected with the mouse.

     Additional property/value pairs that are valid properties of text
     objects can be given and are passed to the underlying text
     objects.  Additionally, the property "LabelSpacing" is available
     allowing the spacing between labels on a contour (in points) to be
     specified.  The default is 144 points, or 2 inches.

     The returned value H is the set of text object that represent the
     contour labels.  The "userdata" property of the text objects
     contains the numerical value of the contour label.

     An example of the use of `clabel' is

          [c, h] = contour (peaks(), -4 : 6);
          clabel (c, h, -4 : 2 : 6, 'fontsize', 12);

     See also: contour, contourf, contour3, meshc, surfc, text
}

#
class
{
`class' is a built-in function

 -- Built-in Function:  class (EXPR)
 -- Built-in Function:  class (S, ID)
 -- Built-in Function:  class (S, ID, P, ...)
     Return the class of the expression EXPR or create a class with
     fields from structure S and name (string) ID.  Additional
     arguments name a list of parent classes from which the new class is
     derived.
}

#
clc
{
`clc' is a built-in function

 -- Built-in Function:  clc ()
 -- Built-in Function:  home ()
     Clear the terminal screen and move the cursor to the upper left
     corner.
}

#
clear
{
`clear' is a built-in function

 -- Command: clear [options] pattern ...
     Delete the names matching the given patterns from the symbol
     table.  The pattern may contain the following special characters:

    `?'
          Match any single character.

    `*'
          Match zero or more characters.

    `[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is `!' or `^', match all characters except those
          specified by LIST.  For example, the pattern `[a-zA-Z]' will
          match all lower and upper case alphabetic characters.

     For example, the command

          clear foo b*r

     clears the name `foo' and all names that begin with the letter `b'
     and end with the letter `r'.

     If `clear' is called without any arguments, all user-defined
     variables (local and global) are cleared from the symbol table.  If
     `clear' is called with at least one argument, only the visible
     names matching the arguments are cleared.  For example, suppose
     you have defined a function `foo', and then hidden it by
     performing the assignment `foo = 2'.  Executing the command `clear
     foo' once will clear the variable definition and restore the
     definition of `foo' as a function.  Executing `clear foo' a second
     time will clear the function definition.

     The following options are available in both long and short form
    `-all, -a'
          Clears all local and global user-defined variables and all
          functions from the symbol table.

    `-exclusive, -x'
          Clears the variables that don't match the following pattern.

    `-functions, -f'
          Clears the function names and the built-in symbols names.

    `-global, -g'
          Clears the global symbol names.

    `-variables, -v'
          Clears the local variable names.

    `-classes, -c'
          Clears the class structure table and clears all objects.

    `-regexp, -r'
          The arguments are treated as regular expressions as any
          variables that match will be cleared.
     With the exception of `exclusive', all long options can be used
     without the dash as well.
}

#
clearplot
{
`clearplot' is a function from the file /usr/share/octave/3.2.3/m/deprecated/clearplot.m

 -- Function File:  clearplot ()
     This function has been deprecated.  Use clf instead.
}

#
clf
{
`clf' is a function from the file /usr/share/octave/3.2.3/m/plot/clf.m

 -- Function File:  clf ()
 -- Function File:  clf ("reset")
 -- Function File:  clf (HFIG)
 -- Function File:  clf (HFIG, "reset")
     Clear the current figure window.  `clf' operates by deleting child
     graphics objects with visible handles (`HandleVisibility' = on).
     If HFIG is specified operate on it instead of the current figure.
     If the optional argument `"reset"' is specified, all objects
     including those with hidden handles are deleted.

     See also: cla, close, delete
}

#
clg
{
`clg' is a function from the file /usr/share/octave/3.2.3/m/deprecated/clg.m

 -- Function File:  clg ()
     This function has been deprecated.  Use clf instead.
}

#
clock
{
`clock' is a function from the file /usr/share/octave/3.2.3/m/time/clock.m

 -- Function File:  clock ()
     Return a vector containing the current year, month (1-12), day
     (1-31), hour (0-23), minute (0-59) and second (0-61).  For example,

          clock ()
               => [ 1993, 8, 20, 4, 56, 1 ]

     The function clock is more accurate on systems that have the
     `gettimeofday' function.
}

#
cloglog
{
`cloglog' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/cloglog.m

 -- Function File:  cloglog (X)
     Return the complementary log-log function of X, defined as

          cloglog(x) = - log (- log (X))
}

#
close
{
`close' is a function from the file /usr/share/octave/3.2.3/m/plot/close.m

 -- Command:  close
 -- Command:  close (N)
 -- Command:  close all
 -- Command:  close all hidden
     Close figure window(s) by calling the function specified by the
     `"closerequestfcn"' property for each figure.  By default, the
     function `closereq' is used.

     See also: closereq
}

#
closereq
{
`closereq' is a function from the file /usr/share/octave/3.2.3/m/plot/closereq.m

 -- Function File:  closereq ()
     Close the current figure and delete all graphics objects associated
     with it.

     See also: close, delete
}

#
colamd
{
`colamd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/colamd.oct

 -- Loadable Function: P = colamd (S)
 -- Loadable Function: P = colamd (S, KNOBS)
 -- Loadable Function: [P, STATS] = colamd (S)
 -- Loadable Function: [P, STATS] = colamd (S, KNOBS)
     Column approximate minimum degree permutation.  `P = colamd (S)'
     returns the column approximate minimum degree permutation vector
     for the sparse matrix S.  For a non-symmetric matrix S, `S (:,P)'
     tends to have sparser LU factors than S.  The Cholesky
     factorization of `S (:,P)' * S (:,P)' also tends to be sparser
     than that of `S' * S'.

     KNOBS is an optional one- to three-element input vector.  If S is
     m-by-n, then rows with more than `max(16,KNOBS(1)*sqrt(n))' entries
     are ignored.  Columns with more than
     `max(16,knobs(2)*sqrt(min(m,n)))' entries are removed prior to
     ordering, and ordered last in the output permutation P.  Only
     completely dense rows or columns are removed if `KNOBS (1)' and
     `KNOBS (2)' are < 0, respectively.  If `KNOBS (3)' is nonzero,
     STATS and KNOBS are printed.  The default is `KNOBS = [10 10 0]'.
     Note that KNOBS differs from earlier versions of colamd

     STATS is an optional 20-element output vector that provides data
     about the ordering and the validity of the input matrix S.
     Ordering statistics are in `STATS (1:3)'.  `STATS (1)' and `STATS
     (2)' are the number of dense or empty rows and columns ignored by
     COLAMD and `STATS (3)' is the number of garbage collections
     performed on the internal data structure used by COLAMD (roughly
     of size `2.2 * nnz(S) + 4 * M + 7 * N' integers).

     Octave built-in functions are intended to generate valid sparse
     matrices, with no duplicate entries, with ascending row indices of
     the nonzeros in each column, with a non-negative number of entries
     in each column (!)  and so on.  If a matrix is invalid, then
     COLAMD may or may not be able to continue.  If there are duplicate
     entries (a row index appears two or more times in the same column)
     or if the row indices in a column are out of order, then COLAMD
     can correct these errors by ignoring the duplicate entries and
     sorting each column of its internal copy of the matrix S (the
     input matrix S is not repaired, however).  If a matrix is invalid
     in other ways then COLAMD cannot continue, an error message is
     printed, and no output arguments (P or STATS) are returned.
     COLAMD is thus a simple way to check a sparse matrix to see if it's
     valid.

     `STATS (4:7)' provide information if COLAMD was able to continue.
     The matrix is OK if `STATS (4)' is zero, or 1 if invalid.  `STATS
     (5)' is the rightmost column index that is unsorted or contains
     duplicate entries, or zero if no such column exists.  `STATS (6)'
     is the last seen duplicate or out-of-order row index in the column
     index given by `STATS (5)', or zero if no such row index exists.
     `STATS (7)' is the number of duplicate or out-of-order row
     indices.  `STATS (8:20)' is always zero in the current version of
     COLAMD (reserved for future use).

     The ordering is followed by a column elimination tree
     post-ordering.

     The authors of the code itself are Stefan I. Larimore and Timothy
     A.  Davis (davis@cise.ufl.edu), University of Florida.  The
     algorithm was developed in collaboration with John Gilbert, Xerox
     PARC, and Esmond Ng, Oak Ridge National Laboratory.  (see
     `http://www.cise.ufl.edu/research/sparse/colamd')

     See also: colperm, symamd
}

#
colloc
{
`colloc' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/colloc.oct

 -- Loadable Function: [R, AMAT, BMAT, Q] = colloc (N, "left", "right")
     Compute derivative and integral weight matrices for orthogonal
     collocation using the subroutines given in J. Villadsen and M. L.
     Michelsen, `Solution of Differential Equation Models by Polynomial
     Approximation'.
}

#
colon
{
`colon' is a function from the file /usr/share/octave/3.2.3/m/general/colon.m

 -- Function File: R = colon (A, B)
 -- Function File: R = colon (A, B, C)
     Method of a class to construct a range with the `:' operator.  For
     example.

          a = myclass (...)
          b = myclass (...)
          c = a : b

     See also: class, subsref, subsasgn
}

#
colorbar
{
`colorbar' is a function from the file /usr/share/octave/3.2.3/m/plot/colorbar.m

 -- Function File:  colorbar (S)
 -- Function File:  colorbar ("peer", H, ...)
     Adds a colorbar to the current axes.  Valid values for S are

    "EastOutside"
          Place the colorbar outside the plot to the right.  This is
          the default.

    "East"
          Place the colorbar inside the plot to the right.

    "WestOutside"
          Place the colorbar outside the plot to the left.

    "West"
          Place the colorbar inside the plot to the left.

    "NorthOutside"
          Place the colorbar above the plot.

    "North"
          Place the colorbar at the top of the plot.

    "SouthOutside"
          Place the colorbar under the plot.

    "South"
          Place the colorbar at the bottom of the plot.

    "Off", "None"
          Remove any existing colorbar from the plot.

     If the argument "peer" is given, then the following argument is
     treated as the axes handle on which to add the colorbar.
}

#
colormap
{
`colormap' is a function from the file /usr/share/octave/3.2.3/m/image/colormap.m

 -- Function File:  colormap (MAP)
 -- Function File:  colormap ("default")
     Set the current colormap.

     `colormap (MAP)' sets the current colormap to MAP.  The color map
     should be an N row by 3 column matrix.  The columns contain red,
     green, and blue intensities respectively.  All entries should be
     between 0 and 1 inclusive.  The new colormap is returned.

     `colormap ("default")' restores the default colormap (the `jet'
     map with 64 entries).  The default colormap is returned.

     With no arguments, `colormap' returns the current color map.

     See also: jet
}

#
colperm
{
`colperm' is a function from the file /usr/share/octave/3.2.3/m/sparse/colperm.m

 -- Function File: P = colperm (S)
     Returns the column permutations such that the columns of `S (:,
     P)' are ordered in terms of increase number of non-zero elements.
     If S is symmetric, then P is chosen such that `S (P, P)' orders
     the rows and columns with increasing number of non zeros elements.
}

#
columns
{
`columns' is a built-in function

 -- Built-in Function:  columns (A)
     Return the number of columns of A.

     See also: size, numel, rows, length, isscalar, isvector, ismatrix
}

#
com2str
{
`com2str' is a function from the file /usr/share/octave/3.2.3/m/deprecated/com2str.m

 -- Function File:  com2str (ZZ, FLG)
     This function has been deprecated.  Use num2str instead.

     Convert complex number to a string.  *Inputs*
    ZZ
          complex number

    FLG
          format flag 0 (default):            -1, 0, 1,   1i,   1 + 0.5i
          1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
}

#
comet
{
`comet' is a function from the file /usr/share/octave/3.2.3/m/plot/comet.m

 -- Function File:  comet (Y)
 -- Function File:  comet (X, Y)
 -- Function File:  comet (X, Y, P)
 -- Function File:  comet (AX, ...)
     Produce a simple comet style animation along the trajectory
     provided by the input coordinate vectors (X, Y), where X will
     default to the indices of Y.

     The speed of the comet may be controlled by P, which represents the
     time which passes as the animation passes from one point to the
     next.  The default for P is 0.1 seconds.

     If AX is specified the animation is produced in that axis rather
     than the `gca'.
}

#
comma
{
`comma' is the file /usr/share/octave/3.2.3/m/miscellaneous/comma.m

 -- Operator: ,
     Array index, function argument, or command separator.

     See also: semicolon
}

#
command_line_path
{
`command_line_path' is a built-in function

 -- Built-in Function:  command_line_path (...)
     Return the command line path variable.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep
}

#
common_size
{
`common_size' is a function from the file /usr/share/octave/3.2.3/m/general/common_size.m

 -- Function File: [ERR, Y1, ...] = common_size (X1, ...)
     Determine if all input arguments are either scalar or of common
     size.  If so, ERR is zero, and YI is a matrix of the common size
     with all entries equal to XI if this is a scalar or XI otherwise.
     If the inputs cannot be brought to a common size, errorcode is 1,
     and YI is XI.  For example,

          [errorcode, a, b] = common_size ([1 2; 3 4], 5)
               => errorcode = 0
               => a = [ 1, 2; 3, 4 ]
               => b = [ 5, 5; 5, 5 ]

     This is useful for implementing functions where arguments can
     either be scalars or of common size.
}

#
commutation_matrix
{
`commutation_matrix' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/commutation_matrix.m

 -- Function File:  commutation_matrix (M, N)
     Return the commutation matrix  K(m,n)  which is the unique  M*N by
     M*N  matrix such that  K(m,n) * vec(A) = vec(A')  for all  m by n
     matrices  A.

     If only one argument M is given,  K(m,m)  is returned.

     See Magnus and Neudecker (1988), Matrix differential calculus with
     applications in statistics and econometrics.
}

#
compan
{
`compan' is a function from the file /usr/share/octave/3.2.3/m/polynomial/compan.m

 -- Function File:  compan (C)
     Compute the companion matrix corresponding to polynomial
     coefficient vector C.

     The companion matrix is

               _                                                        _
              |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(N)/c(1)  -c(N+1)/c(1)  |
              |       1            0      ...       0             0      |
              |       0            1      ...       0             0      |
          A = |       .            .   .            .             .      |
              |       .            .       .        .             .      |
              |       .            .           .    .             .      |
              |_      0            0      ...       1             0     _|

     The eigenvalues of the companion matrix are equal to the roots of
     the polynomial.

     See also: poly, roots, residue, conv, deconv, polyval, polyderiv,
     polyinteg
}

#
compare_versions
{
`compare_versions' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/compare_versions.m

 -- Function File:  compare_versions (V1, V2, OPERATOR)
     Compares to version strings using the given OPERATOR.

     This function assumes that versions V1 and V2 are arbitrarily long
     strings made of numeric and period characters possibly followed by
     an arbitrary string (e.g., "1.2.3", "0.3", "0.1.2+", or
     "1.2.3.4-test1").

     The version is first split into the numeric and the character parts
     then the parts are padded to be the same length (i.e., "1.1" would
     be padded to be like "1.1.0" when being compared with "1.1.1", and
     separately, the character parts of the strings are padded with
     nulls).

     The operator can be any logical operator from the set

        * "==" equal

        * "<" less than

        * "<=" less than or equal to

        * ">" greater than

        * ">=" greater than or equal to

        * "!=" not equal

        * "~=" not equal

     Note that version "1.1-test2" would compare as greater than
     "1.1-test10".  Also, since the numeric part is compared first, "a"
     compares less than "1a" because the second string starts with a
     numeric part even though double("a") is greater than double("1").
}

#
compass
{
`compass' is a function from the file /usr/share/octave/3.2.3/m/plot/compass.m

 -- Function File:  compass (U, V)
 -- Function File:  compass (Z)
 -- Function File:  compass (..., STYLE)
 -- Function File:  compass (H, ...)
 -- Function File: H = compass (...)
     Plot the `(U, V)' components of a vector field emanating from the
     origin of a polar plot.  If a single complex argument Z is given,
     then `U = real (Z)' and `V = imag (Z)'.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the `plot'
     command.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          a = toeplitz([1;randn(9,1)],[1,randn(1,9)]);
          compass (eig (a))

     See also: plot, polar, quiver, feather
}

#
complement
{
`complement' is a function from the file /usr/share/octave/3.2.3/m/set/complement.m

 -- Function File:  complement (X, Y)
     Return the elements of set Y that are not in set X.  For example,

          complement ([ 1, 2, 3 ], [ 2, 3, 5 ])
               => 5

     See also: union, intersect, unique
}

#
completion_append_char
{
`completion_append_char' is a built-in function

 -- Built-in Function: VAL = completion_append_char ()
 -- Built-in Function: OLD_VAL = completion_append_char (NEW_VAL)
     Query or set the internal character variable that is appended to
     successful command-line completion attempts.  The default value is
     `" "' (a single space).
}

#
completion_matches
{
`completion_matches' is a built-in function

 -- Built-in Function:  completion_matches (HINT)
     Generate possible completions given HINT.

     This function is provided for the benefit of programs like Emacs
     which might be controlling Octave and handling user input.  The
     current command number is not incremented when this function is
     called.  This is a feature, not a bug.
}

#
complex
{
`complex' is a built-in function

 -- Built-in Function:  complex (X)
 -- Built-in Function:  complex (RE, IM)
     Return a complex result from real arguments.  With 1 real argument
     X, return the complex result `X + 0i'.  With 2 real arguments,
     return the complex result `RE + IM'.  `complex' can often be more
     convenient than expressions such as `a + i*b'.  For example:

          complex ([1, 2], [3, 4])
          =>
            1 + 3i   2 + 4i

     See also: real, imag, iscomplex
}

#
computer
{
`computer' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/computer.m

 -- Function File: [C, MAXSIZE, ENDIAN] = computer ()
     Print or return a string of the form CPU-VENDOR-OS that identifies
     the kind of computer Octave is running on.  If invoked with an
     output argument, the value is returned instead of printed.  For
     example,

          computer ()
               -| i586-pc-linux-gnu

          x = computer ()
               => x = "i586-pc-linux-gnu"

     If two output arguments are requested, also return the maximum
     number of elements for an array.

     If three output arguments are requested, also return the byte order
     of the current system as a character (`"B"' for big-endian or
     `"L"' for little-endian).
}

#
cond
{
`cond' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/cond.m

 -- Function File:  cond (A,P)
     Compute the P-norm condition number of a matrix.  `cond (A)' is
     defined as `norm (A, P) * norm (inv (A), P)'.  By default `P=2' is
     used which implies a (relatively slow) singular value
     decomposition.  Other possible selections are `P= 1, Inf, inf,
     'Inf', 'fro'' which are generally faster.

     See also: condest, rcond, norm, svd
}

#
condest
{
`condest' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/condest.m

 -- Function File: [EST, V] = condest (A, T)
 -- Function File: [EST, V] = condest (A, SOLVE, SOLVE_T, T)
 -- Function File: [EST, V] = condest (APPLY, APPLY_T, SOLVE, SOLVE_T,
          N, T)
     Estimate the 1-norm condition number of a matrix A using T test
     vectors using a randomized 1-norm estimator.  If T exceeds 5, then
     only 5 test vectors are used.

     If the matrix is not explicit, e.g., when estimating the condition
     number of A given an LU factorization, `condest' uses the
     following functions:

    APPLY
          `A*x' for a matrix `x' of size N by T.

    APPLY_T
          `A'*x' for a matrix `x' of size N by T.

    SOLVE
          `A \ b' for a matrix `b' of size N by T.

    SOLVE_T
          `A' \ b' for a matrix `b' of size N by T.

     The implicit version requires an explicit dimension N.

     `condest' uses a randomized algorithm to approximate the 1-norms.

     `condest' returns the 1-norm condition estimate EST and a vector V
     satisfying `norm (A*v, 1) == norm (A, 1) * norm (V, 1) / EST'.
     When EST is large, V is an approximate null vector.

     References:
        * Nicholas J. Higham and Fran
}

#
confirm_recursive_rmdir
{
`confirm_recursive_rmdir' is a built-in function

 -- Built-in Function: VAL = confirm_recursive_rmdir ()
 -- Built-in Function: OLD_VAL = confirm_recursive_rmdir (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will ask for confirmation before recursively removing a directory
     tree.
}

#
conj
{
`conj' is a built-in function

 -- Mapping Function:  conj (Z)
     Return the complex conjugate of Z, defined as `conj (Z)' = X - IY.

     See also: real, imag
}

#
continue
{

 -- Keyword: continue
     Jump to the end of the innermost enclosing do, while or for loop.

     See also: do, while, for, break
}

#
contour
{
`contour' is a function from the file /usr/share/octave/3.2.3/m/plot/contour.m

 -- Function File:  contour (Z)
 -- Function File:  contour (Z, VN)
 -- Function File:  contour (X, Y, Z)
 -- Function File:  contour (X, Y, Z, VN)
 -- Function File:  contour (..., STYLE)
 -- Function File:  contour (H, ...)
 -- Function File: [C, H] = contour (...)
     Plot level curves (contour lines) of the matrix Z, using the
     contour matrix C computed by `contourc' from the same arguments;
     see the latter for their interpretation.  The set of contour
     levels, C, is only returned if requested.  For example:

          x = 0:2;
          y = x;
          z = x' * y;
          contour (x, y, z, 2:3)

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the `plot'
     command.  Any markers defined by STYLE are ignored.

     The optional input and output argument H allows an axis handle to
     be passed to `contour' and the handles to the contour objects to be
     returned.

     See also: contourc, patch, plot
}

#
contour3
{
`contour3' is a function from the file /usr/share/octave/3.2.3/m/plot/contour3.m

 -- Function File:  contour3 (Z)
 -- Function File:  contour3 (Z, VN)
 -- Function File:  contour3 (X, Y, Z)
 -- Function File:  contour3 (X, Y, Z, VN)
 -- Function File:  contour3 (..., STYLE)
 -- Function File:  contour3 (H, ...)
 -- Function File: [C, H] = contour3 (...)
     Plot level curves (contour lines) of the matrix Z, using the
     contour matrix C computed by `contourc' from the same arguments;
     see the latter for their interpretation.  The contours are plotted
     at the Z level corresponding to their contour.  The set of contour
     levels, C, is only returned if requested.  For example:

          contour3 (peaks (19));
          hold on
          surface (peaks (19), "facecolor", "none", "EdgeColor", "black")
          colormap hot

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the `plot'
     command.  Any markers defined by STYLE are ignored.

     The optional input and output argument H allows an axis handle to
     be passed to `contour' and the handles to the contour objects to be
     returned.

     See also: contourc, patch, plot
}

#
contourc
{
`contourc' is a function from the file /usr/share/octave/3.2.3/m/plot/contourc.m

 -- Function File: [C, LEV] = contourc (X, Y, Z, VN)
     Compute isolines (contour lines) of the matrix Z.  Parameters X, Y
     and VN are optional.

     The return value LEV is a vector of the contour levels.  The
     return value C is a 2 by N matrix containing the contour lines in
     the following format

          C = [lev1, x1, x2, ..., levn, x1, x2, ...
               len1, y1, y2, ..., lenn, y1, y2, ...]

     in which contour line N has a level (height) of LEVN and length of
     LENN.

     If X and Y are omitted they are taken as the row/column index of
     Z.  VN is either a scalar denoting the number of lines to compute
     or a vector containing the values of the lines.  If only one value
     is wanted, set `VN = [val, val]'; If VN is omitted it defaults to
     10.

     For example,
          x = 0:2;
          y = x;
          z = x' * y;
          contourc (x, y, z, 2:3)
               =>   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
               2.0000   1.0000   2.0000   2.0000   2.0000   1.5000

     See also: contour
}

#
contourf
{
`contourf' is a function from the file /usr/share/octave/3.2.3/m/plot/contourf.m

 -- Function File: [C, H] = contourf (X, Y, Z, LVL)
 -- Function File: [C, H] = contourf (X, Y, Z, N)
 -- Function File: [C, H] = contourf (X, Y, Z)
 -- Function File: [C, H] = contourf (Z, N)
 -- Function File: [C, H] = contourf (Z, LVL)
 -- Function File: [C, H] = contourf (Z)
 -- Function File: [C, H] = contourf (AX, ...)
 -- Function File: [C, H] = contourf (..., "PROPERTY", VAL)
     Compute and plot filled contours of the matrix Z.  Parameters X, Y
     and N or LVL are optional.

     The return value C is a 2xn matrix containing the contour lines as
     described in the help to the contourc function.

     The return value H is handle-vector to the patch objects creating
     the filled contours.

     If X and Y are omitted they are taken as the row/column index of
     Z.  N is a scalar denoting the number of lines to compute.
     Alternatively LVL is a vector containing the contour levels.  If
     only one value (e.g., lvl0) is wanted, set LVL to [lvl0, lvl0].
     If both N or LVL are omitted a default value of 10 contour level
     is assumed.

     If provided, the filled contours are added to the axes object AX
     instead of the current axis.

     The following example plots filled contours of the `peaks'
     function.
          [x, y, z] = peaks (50);
          contourf (x, y, z, -7:9)

     See also: contour, contourc, patch
}

#
contrast
{
`contrast' is a function from the file /usr/share/octave/3.2.3/m/image/contrast.m

 -- Function File:  contrast (X, N)
     Return a gray colormap that maximizes the contrast in an image.
     The returned colormap will have N rows.  If N is not defined then
     the size of the current colormap is used instead.

     See also: colormap
}

#
conv
{
`conv' is a function from the file /usr/share/octave/3.2.3/m/polynomial/conv.m

 -- Function File:  conv (A, B)
     Convolve two vectors.

     `y = conv (a, b)' returns a vector of length equal to `length (a)
     + length (b) - 1'.  If A and B are polynomial coefficient vectors,
     `conv' returns the coefficients of the product polynomial.

     See also: deconv, poly, roots, residue, polyval, polyderiv,
     polyinteg
}

#
conv2
{
`conv2' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/conv2.oct

 -- Loadable Function: y = conv2 (A, B, SHAPE)
 -- Loadable Function: y = conv2 (V1, V2, M, SHAPE)
     Returns 2D convolution of A and B where the size of C is given by

    SHAPE= 'full'
          returns full 2-D convolution

    SHAPE= 'same'
          same size as a. 'central' part of convolution

    SHAPE= 'valid'
          only parts which do not include zero-padded edges

     By default SHAPE is 'full'.  When the third argument is a matrix
     returns the convolution of the matrix M by the vector V1 in the
     column direction and by vector V2 in the row direction
}

#
convhull
{
`convhull' is a function from the file /usr/share/octave/3.2.3/m/geometry/convhull.m

 -- Function File: H = convhull (X, Y)
 -- Function File: H = convhull (X, Y, OPT)
     Returns the index vector to the points of the enclosing convex
     hull.  The data points are defined by the x and y vectors.

     A third optional argument, which must be a string, contains extra
     options passed to the underlying qhull command.  See the
     documentation for the Qhull library for details.

     See also: delaunay, convhulln
}

#
convhulln
{
`convhulln' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/convhulln.oct

 -- Loadable Function: H = convhulln (P)
 -- Loadable Function: H = convhulln (P, OPT)
 -- Loadable Function: [H, V] = convhulln (...)
     Return an index vector to the points of the enclosing convex hull.
     The input matrix of size [n, dim] contains n points of dimension
     dim.

     If a second optional argument is given, it must be a string or
     cell array of strings containing options for the underlying qhull
     command.  (See the Qhull documentation for the available options.)
     The default options are "s Qci Tcv".  If the second output V is
     requested the volume of the convex hull is calculated.

     See also: convhull, delaunayn
}

#
convn
{
`convn' is a function from the file /usr/share/octave/3.2.3/m/polynomial/convn.m

 -- Function File: C = convn (A, B, SHAPE)
     N-dimensional convolution of matrices A and B.

     The size of the output is determined by the SHAPE argument.  This
     can be any of the following character strings:

    "full"
          The full convolution result is returned.  The size out of the
          output is `size (A) + size (B)-1'.  This is the default
          behavior.

    "same"
          The central part of the convolution result is returned.  The
          size out of the output is the same as A.

    "valid"
          The valid part of the convolution is returned.  The size of
          the result is `max (size (A) - size (B)+1, 0)'.

     See also: conv, conv2
}

#
cool
{
`cool' is a function from the file /usr/share/octave/3.2.3/m/image/cool.m

 -- Function File:  cool (N)
     Create color colormap.  The colormap is cyan to magenta.  The
     argument N should be a scalar.  If it is omitted, the length of
     the current colormap or 64 is assumed.

     See also: colormap
}

#
copper
{
`copper' is a function from the file /usr/share/octave/3.2.3/m/image/copper.m

 -- Function File:  copper (N)
     Create color colormap.  This colormap is black to a light copper
     tone.  The argument N should be a scalar.  If it is omitted, the
     length of the current colormap or 64 is assumed.

     See also: colormap
}

#
copyfile
{
`copyfile' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/copyfile.m

 -- Function File: [STATUS, MSG, MSGID] = copyfile (F1, F2, FORCE)
     Copy the file F1 to the new name F2.  The name F1 may contain
     globbing patterns.  If F1 expands to multiple file names, F2 must
     be a directory.  If FORCE is given and equals the string "f" the
     copy operation will be forced.

     If successful, STATUS is 1, with MSG and MSGID empty\n\ character
     strings.  Otherwise, STATUS is 0, MSG contains a\n\
     system-dependent error message, and MSGID contains a unique\n\
     message identifier.\n\

     See also: glob, movefile
}

#
cor
{
`cor' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/cor.m

 -- Function File:  cor (X, Y)
     Compute correlation.

     The (I, J)-th entry of `cor (X, Y)' is the correlation between the
     I-th variable in X and the J-th variable in Y.

          corrcoef(x,y) = cov(x,y)/(std(x)*std(y))

     For matrices, each row is an observation and each column a
     variable; vectors are always observations and may be row or column
     vectors.

     `cor (X)' is equivalent to `cor (X, X)'.

     Note that the `corrcoef' function does the same as `cor'.
}

#
cor_test
{
`cor_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/cor_test.m

 -- Function File:  cor_test (X, Y, ALT, METHOD)
     Test whether two samples X and Y come from uncorrelated
     populations.

     The optional argument string ALT describes the alternative
     hypothesis, and can be `"!="' or `"<>"' (non-zero), `">"' (greater
     than 0), or `"<"' (less than 0).  The default is the two-sided
     case.

     The optional argument string METHOD specifies on which correlation
     coefficient the test should be based.  If METHOD is `"pearson"'
     (default), the (usual) Pearson's product moment correlation
     coefficient is used.  In this case, the data should come from a
     bivariate normal distribution.  Otherwise, the other two methods
     offer nonparametric alternatives.  If METHOD is `"kendall"', then
     Kendall's rank correlation tau is used.  If METHOD is
     `"spearman"', then Spearman's rank correlation rho is used.  Only
     the first character is necessary.

     The output is a structure with the following elements:

    PVAL
          The p-value of the test.

    STAT
          The value of the test statistic.

    DIST
          The distribution of the test statistic.

    PARAMS
          The parameters of the null distribution of the test statistic.

    ALTERNATIVE
          The alternative hypothesis.

    METHOD
          The method used for testing.

     If no output argument is given, the p-value is displayed.
}

#
corrcoef
{
`corrcoef' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/corrcoef.m

 -- Function File:  corrcoef (X, Y)
     Compute correlation.

     If each row of X and Y is an observation and each column is a
     variable, the (I, J)-th entry of `corrcoef (X, Y)' is the
     correlation between the I-th variable in X and the J-th variable
     in Y.

          corrcoef(x,y) = cov(x,y)/(std(x)*std(y))

     If called with one argument, compute `corrcoef (X, X)'.
}

#
cos
{
`cos' is a built-in function

 -- Mapping Function:  cos (X)
     Compute the cosine for each element of X in radians.

     See also: acos, cosd, cosh
}

#
cosd
{
`cosd' is a function from the file /usr/share/octave/3.2.3/m/elfun/cosd.m

 -- Function File:  cosd (X)
     Compute the cosine for each element of X in degrees.  Returns zero
     for elements where `(X-90)/180' is an integer.

     See also: acosd, cos
}

#
cosh
{
`cosh' is a built-in function

 -- Mapping Function:  cosh (X)
     Compute the hyperbolic cosine for each element of X.

     See also: acosh, sinh, tanh
}

#
cot
{
`cot' is a function from the file /usr/share/octave/3.2.3/m/elfun/cot.m

 -- Mapping Function:  cot (X)
     Compute the cotangent for each element of X in radians.

     See also: acot, cotd, coth
}

#
cotd
{
`cotd' is a function from the file /usr/share/octave/3.2.3/m/elfun/cotd.m

 -- Function File:  cotd (X)
     Compute the cotangent for each element of X in degrees.

     See also: acotd, cot
}

#
coth
{
`coth' is a function from the file /usr/share/octave/3.2.3/m/elfun/coth.m

 -- Mapping Function:  coth (X)
     Compute the hyperbolic cotangent of each element of X.

     See also: acoth
}

#
cov
{
`cov' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/cov.m

 -- Function File:  cov (X, Y)
     Compute covariance.

     If each row of X and Y is an observation and each column is a
     variable, the (I, J)-th entry of `cov (X, Y)' is the covariance
     between the I-th variable in X and the J-th variable in Y.  If
     called with one argument, compute `cov (X, X)'.
}

#
cplxpair
{
`cplxpair' is a function from the file /usr/share/octave/3.2.3/m/general/cplxpair.m

 -- Function File:  cplxpair (Z)
 -- Function File:  cplxpair (Z, TOL)
 -- Function File:  cplxpair (Z, TOL, DIM)
     Sort the numbers Z into complex conjugate pairs ordered by
     increasing real part.  Place the negative imaginary complex number
     first within each pair.  Place all the real numbers (those with
     `abs (imag (Z) / Z) < TOL)') after the complex pairs.

     If TOL is unspecified the default value is 100*`eps'.

     By default the complex pairs are sorted along the first
     non-singleton dimension of Z.  If DIM is specified, then the
     complex pairs are sorted along this dimension.

     Signal an error if some complex numbers could not be paired.
     Signal an error if all complex numbers are not exact conjugates
     (to within TOL).  Note that there is no defined order for pairs
     with identical real parts but differing imaginary parts.

          cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
}

#
cputime
{
`cputime' is a built-in function

 -- Built-in Function: [TOTAL, USER, SYSTEM] = cputime ();
     Return the CPU time used by your Octave session.  The first output
     is the total time spent executing your process and is equal to the
     sum of second and third outputs, which are the number of CPU
     seconds spent executing in user mode and the number of CPU seconds
     spent executing in system mode, respectively.  If your system does
     not have a way to report CPU time usage, `cputime' returns 0 for
     each of its output values.  Note that because Octave used some CPU
     time to start, it is reasonable to check to see if `cputime' works
     by checking to see if the total CPU time used is nonzero.
}

#
crash_dumps_octave_core
{
`crash_dumps_octave_core' is a built-in function

 -- Built-in Function: VAL = crash_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = crash_dumps_octave_core (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file "octave-core" if it
     crashes or receives a hangup, terminate or similar signal.

     See also: octave_core_file_limit, octave_core_file_name,
     octave_core_file_options
}

#
create_set
{
`create_set' is a function from the file /usr/share/octave/3.2.3/m/deprecated/create_set.m

 -- Function File:  create_set (X)
 -- Function File:  create_set (X, "rows")
     This function has been deprecated.  Use unique instead.
}

#
cross
{
`cross' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/cross.m

 -- Function File:  cross (X, Y)
 -- Function File:  cross (X, Y, DIM)
     Compute the vector cross product of two 3-dimensional vectors X
     and Y.

          cross ([1,1,0], [0,1,1])
               => [ 1; -1; 1 ]

     If X and Y are matrices, the cross product is applied along the
     first dimension with 3 elements.  The optional argument DIM forces
     the cross product to be calculated along the specified dimension.

     See also: dot
}

#
csc
{
`csc' is a function from the file /usr/share/octave/3.2.3/m/elfun/csc.m

 -- Mapping Function:  csc (X)
     Compute the cosecant for each element of X in radians.

     See also: acsc, cscd, csch
}

#
cscd
{
`cscd' is a function from the file /usr/share/octave/3.2.3/m/elfun/cscd.m

 -- Function File:  cscd (X)
     Compute the cosecant for each element of X in degrees.

     See also: acscd, csc
}

#
csch
{
`csch' is a function from the file /usr/share/octave/3.2.3/m/elfun/csch.m

 -- Mapping Function:  csch (X)
     Compute the hyperbolic cosecant of each element of X.

     See also: acsch
}

#
cstrcat
{
`cstrcat' is a function from the file /usr/share/octave/3.2.3/m/strings/cstrcat.m

 -- Function File:  cstrcat (S1, S2, ...)
     Return a string containing all the arguments concatenated
     horizontally.  Trailing white space is preserved.  For example,

          cstrcat ("ab   ", "cd")
               => "ab   cd"

          s = [ "ab"; "cde" ];
          cstrcat (s, s, s)
               => ans =
                  "ab ab ab "
                  "cdecdecde"

     See also: strcat, char, strvcat
}

#
csvread
{
`csvread' is a function from the file /usr/share/octave/3.2.3/m/io/csvread.m

 -- Function File: X = csvread (FILENAME)
     Read the matrix X from a file.

     This function is equivalent to
          dlmread (FILENAME, "," , ...)

     See also: dlmread, dlmwrite, csvwrite
}

#
csvwrite
{
`csvwrite' is a function from the file /usr/share/octave/3.2.3/m/io/csvwrite.m

 -- Function File: X = csvwrite (FILENAME, X)
     Write the matrix X to a file.

     This function is equivalent to
          dlmwrite (FILENAME, X, ",", ...)

     See also: dlmread, dlmwrite, csvread
}

#
csymamd
{
`csymamd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/ccolamd.oct

 -- Loadable Function: P = csymamd (S)
 -- Loadable Function: P = csymamd (S, KNOBS)
 -- Loadable Function: P = csymamd (S, KNOBS, CMEMBER)
 -- Loadable Function: [P, STATS] = csymamd (...)
     For a symmetric positive definite matrix S, returns the permutation
     vector P such that `S(P,P)' tends to have a sparser Cholesky
     factor than S.  Sometimes `csymamd' works well for symmetric
     indefinite matrices too.  The matrix S is assumed to be symmetric;
     only the strictly lower triangular part is referenced.  S must be
     square.  The ordering is followed by an elimination tree
     post-ordering.

     KNOBS is an optional one- to three-element input vector, with a
     default value of `[10 1 0]' if present or empty.  Entries not
     present are set to their defaults.

    `KNOBS(1)'
          If S is n-by-n, then rows and columns with more than
          `max(16,KNOBS(1)*sqrt(n))' entries are ignored, and ordered
          last in the output permutation (subject to the cmember
          constraints).

    `KNOBS(2)'
          If nonzero, aggressive absorption is performed.

    `KNOBS(3)'
          If nonzero, statistics and knobs are printed.


     CMEMBER is an optional vector of length n. It defines the
     constraints on the ordering.  If `CMEMBER(j) = S', then row/column
     j is in constraint set C (C must be in the range 1 to n).  In the
     output permutation P, rows/columns in set 1 appear first, followed
     by all rows/columns in set 2, and so on.  `CMEMBER = ones(1,n)' if
     not present or empty.  `csymamd(S,[],1:n)' returns `1:n'.

     `P = csymamd(S)' is about the same as `P = symamd(S)'.  KNOBS and
     its default values differ.

     `STATS (4:7)' provide information if CCOLAMD was able to continue.
     The matrix is OK if `STATS (4)' is zero, or 1 if invalid.  `STATS
     (5)' is the rightmost column index that is unsorted or contains
     duplicate entries, or zero if no such column exists.  `STATS (6)'
     is the last seen duplicate or out-of-order row index in the column
     index given by `STATS (5)', or zero if no such row index exists.
     `STATS (7)' is the number of duplicate or out-of-order row
     indices.  `STATS (8:20)' is always zero in the current version of
     CCOLAMD (reserved for future use).

     The authors of the code itself are S. Larimore, T. Davis (Uni of
     Florida) and S. Rajamanickam in collaboration with J. Bilbert and
     E. Ng.  Supported by the National Science Foundation (DMS-9504974,
     DMS-9803599, CCR-0203270), and a grant from Sandia National Lab.
     See `http://www.cise.ufl.edu/research/sparse' for ccolamd,
     csymamd, amd, colamd, symamd, and other related orderings.

     See also: symamd, ccolamd
}

#
ctime
{
`ctime' is a function from the file /usr/share/octave/3.2.3/m/time/ctime.m

 -- Function File:  ctime (T)
     Convert a value returned from `time' (or any other non-negative
     integer), to the local time and return a string of the same form as
     `asctime'.  The function `ctime (time)' is equivalent to `asctime
     (localtime (time))'.  For example,

          ctime (time ())
               => "Mon Feb 17 01:15:06 1997\n"
}

#
ctranspose
{
`ctranspose' is a built-in function

 -- Built-in Function:  ctranspose (X)
     This function is equivalent to `x''.
}

#
cummax
{
`cummax' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/max.oct

 -- Loadable Function:  cummax (X)
 -- Loadable Function:  cummax (X, DIM)
 -- Loadable Function: [W, IW] = cummax (X)
     Return the cumulative maximum values along dimension DIM.  If DIM
     is unspecified it defaults to column-wise operation.  For example,

          cummax ([1 3 2 6 4 5])
             =>  1  3  3  6  6  6

     The call
          [w, iw] = cummax (x, dim)

     is equivalent to the following code:
          w = iw = zeros (size (x));
          idxw = idxx = repmat ({':'}, 1, ndims (x));
          for i = 1:size (x, dim)
           idxw{dim} = i; idxx{dim} = 1:i;
           [w(idxw{:}), iw(idxw{:})] = max(x(idxx{:}), [], dim);
          endfor

     but computed in a much faster manner.

     See also: cummin, max, min
}

#
cummin
{
`cummin' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/max.oct

 -- Loadable Function:  cummin (X)
 -- Loadable Function:  cummin (X, DIM)
 -- Loadable Function: [W, IW] = cummin (X)
     Return the cumulative minimum values along dimension DIM.  If DIM
     is unspecified it defaults to column-wise operation.  For example,

          cummin ([5 4 6 2 3 1])
             =>  5  4  4  2  2  1

     The call
           [w, iw] = cummin (x, dim)

     is equivalent to the following code:
          w = iw = zeros (size (x));
          idxw = idxx = repmat ({':'}, 1, ndims (x));
          for i = 1:size (x, dim)
           idxw{dim} = i; idxx{dim} = 1:i;
           [w(idxw{:}), iw(idxw{:})] = min(x(idxx{:}), [], dim);
          endfor

     but computed in a much faster manner.

     See also: cummax, min, max
}

#
cumprod
{
`cumprod' is a built-in function

 -- Built-in Function:  cumprod (X)
 -- Built-in Function:  cumprod (X, DIM)
     Cumulative product of elements along dimension DIM.  If DIM is
     omitted, it defaults to 1 (column-wise cumulative products).

     As a special case, if X is a vector and DIM is omitted, return the
     cumulative product of the elements as a vector with the same
     orientation as X.

     See also: prod, cumsum
}

#
cumsum
{
`cumsum' is a built-in function

 -- Built-in Function:  cumsum (X)
 -- Built-in Function:  cumsum (X, DIM)
 -- Built-in Function:  cumsum (..., 'native')
     Cumulative sum of elements along dimension DIM.  If DIM is
     omitted, it defaults to 1 (column-wise cumulative sums).

     As a special case, if X is a vector and DIM is omitted, return the
     cumulative sum of the elements as a vector with the same
     orientation as X.

     The "native" argument implies the summation is performed in native
     type.  See `sum' for a complete description and example of the use
     of "native".

     See also: sum, cumprod
}

#
cumtrapz
{
`cumtrapz' is a function from the file /usr/share/octave/3.2.3/m/general/cumtrapz.m

 -- Function File: Z = cumtrapz (Y)
 -- Function File: Z = cumtrapz (X, Y)
 -- Function File: Z = cumtrapz (..., DIM)
     Cumulative numerical integration using trapezoidal method.
     `cumtrapz (Y)' computes the cumulative integral of the Y along the
     first non-singleton dimension.  If the argument X is omitted a
     equally spaced vector is assumed.  `cumtrapz (X, Y)' evaluates the
     cumulative integral with respect to X.

     See also: trapz, cumsum
}

#
cut
{
`cut' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/cut.m

 -- Function File:  cut (X, BREAKS)
     Create categorical data out of numerical or continuous data by
     cutting into intervals.

     If BREAKS is a scalar, the data is cut into that many equal-width
     intervals.  If BREAKS is a vector of break points, the category
     has `length (BREAKS) - 1' groups.

     The returned value is a vector of the same size as X telling which
     group each point in X belongs to.  Groups are labelled from 1 to
     the number of groups; points outside the range of BREAKS are
     labelled by `NaN'.
}

#
cylinder
{
`cylinder' is a function from the file /usr/share/octave/3.2.3/m/plot/cylinder.m

 -- Function File:  cylinder
 -- Function File:  cylinder (R)
 -- Function File:  cylinder (R, N)
 -- Function File: [X, Y, Z] = cylinder (...)
 -- Function File:  cylinder (AX, ...)
     Generates three matrices in `meshgrid' format, such that `surf (X,
     Y, Z)' generates a unit cylinder.  The matrices are of size
     `N+1'-by-`N+1'.  R is a vector containing the radius along the
     z-axis.  If N or R are omitted then default values of 20 or [1 1]
     are assumed.

     Called with no return arguments, `cylinder' calls directly `surf
     (X, Y, Z)'.  If an axes handle AX is passed as the first argument,
     the surface is plotted to this set of axes.

     Examples:
          disp ("plotting a cone")
          [x, y, z] = cylinder (10:-1:0,50);
          surf (x, y, z);

     See also: sphere
}

#
daspk
{
`daspk' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/daspk.oct

 -- Loadable Function: [X, XDOT, ISTATE, MSG] = daspk (FCN, X_0,
          XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strings, inline functions, or function handles, the first
     element names the function f described above, and the second
     element names a function to compute the modified Jacobian

               df       df
          jac = -- + c ------
               dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)

     The second and third arguments to `daspk' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly
     required to be consistent.  If they are not consistent, you must
     use the `daspk_options' function to provide additional information
     so that `daspk' can compute a consistent starting point.

     The fifth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where
     there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be
     greater than zero (consistent with the Fortran version of DASPK).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function `daspk_options' to set optional
     parameters for `daspk'.

     See also: dassl
}

#
daspk_options
{
`daspk_options' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/daspk.oct

 -- Loadable Function:  daspk_options (OPT, VAL)
     When called with two arguments, this function allows you set
     options parameters for the function `daspk'.  Given one argument,
     `daspk_options' returns the value of the corresponding option.  If
     no arguments are supplied, the names of all the available options
     and their current values are displayed.

     Options include

    `"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

    `"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                abs (local error in x(i))
                     <= rtol(i) * abs (Y(i)) + atol(i)

    `"compute consistent initial condition"'
          Denoting the differential variables in the state vector by
          `Y_d' and the algebraic variables by `Y_a', `ddaspk' can solve
          one of two initialization problems:

            1. Given Y_d, calculate Y_a and Y'_d

            2. Given Y', calculate Y.

          In either case, initial values for the given components are
          input, and initial guesses for the unknown components must
          also be provided as input.  Set this option to 1 to solve the
          first problem, or 2 to solve the second (the default is 0, so
          you must provide a set of initial conditions that are
          consistent).

          If this option is set to a nonzero value, you must also set
          the `"algebraic variables"' option to declare which variables
          in the problem are algebraic.

    `"use initial condition heuristics"'
          Set to a nonzero value to use the initial condition
          heuristics options described below.

    `"initial condition heuristics"'
          A vector of the following parameters that can be used to
          control the initial condition calculation.

         `MXNIT'
               Maximum number of Newton iterations (default is 5).

         `MXNJ'
               Maximum number of Jacobian evaluations (default is 6).

         `MXNH'
               Maximum number of values of the artificial stepsize
               parameter to be tried if the `"compute consistent
               initial condition"' option has been set to 1 (default is
               5).

               Note that the maximum total number of Newton iterations
               allowed is `MXNIT*MXNJ*MXNH' if the `"compute consistent
               initial condition"' option has been set to 1 and
               `MXNIT*MXNJ' if it is set to 2.

         `LSOFF'
               Set to a nonzero value to disable the linesearch
               algorithm (default is 0).

         `STPTOL'
               Minimum scaled step in linesearch algorithm (default is
               eps^(2/3)).

         `EPINIT'
               Swing factor in the Newton iteration convergence test.
               The test is applied to the residual vector,
               premultiplied by the approximate Jacobian.  For
               convergence, the weighted RMS norm of this vector
               (scaled by the error weights) must be less than
               `EPINIT*EPCON', where `EPCON' = 0.33 is the analogous
               test constant used in the time steps.  The default is
               `EPINIT' = 0.01.

    `"print initial condition info"'
          Set this option to a nonzero value to display detailed
          information about the initial condition calculation (default
          is 0).

    `"exclude algebraic variables from error test"'
          Set to a nonzero value to exclude algebraic variables from
          the error test.  You must also set the `"algebraic
          variables"' option to declare which variables in the problem
          are algebraic (default is 0).

    `"algebraic variables"'
          A vector of the same length as the state vector.  A nonzero
          element indicates that the corresponding element of the state
          vector is an algebraic variable (i.e., its derivative does
          not appear explicitly in the equation set.

          This option is required by the `compute consistent initial
          condition"' and `"exclude algebraic variables from error
          test"' options.

    `"enforce inequality constraints"'
          Set to one of the following values to enforce the inequality
          constraints specified by the `"inequality constraint types"'
          option (default is 0).

            1. To have constraint checking only in the initial
               condition calculation.

            2. To enforce constraint checking during the integration.

            3. To enforce both options 1 and 2.

    `"inequality constraint types"'
          A vector of the same length as the state specifying the type
          of inequality constraint.  Each element of the vector
          corresponds to an element of the state and should be assigned
          one of the following codes

         -2
               Less than zero.

         -1
               Less than or equal to zero.

         0
               Not constrained.

         1
               Greater than or equal to zero.

         2
               Greater than zero.

          This option only has an effect if the `"enforce inequality
          constraints"' option is nonzero.

    `"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize
          (default is computed automatically).

    `"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive (default is 5).

    `"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).
}

#
dasrt
{
`dasrt' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dasrt.oct

 -- Loadable Function: [X, XDOT, T_OUT, ISTAT, MSG] = dasrt (FCN [, G],
          X_0, XDOT_0, T [, T_CRIT])
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     with functional stopping criteria (root solving).

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T_OUT.  The first element of T should be t_0 and correspond
     to the initial state of the system X_0 and its derivative XDOT_0,
     so that the first row of the output X is X_0 and the first row of
     the output XDOT is XDOT_0.

     The vector T provides an upper limit on the length of the
     integration.  If the stopping condition is met, the vector T_OUT
     will be shorter than T, and the final element of T_OUT will be the
     point at which the stopping condition was met, and may not
     correspond to any element of the vector T.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strings, inline functions, or function handles, the first
     element names the function f described above, and the second
     element names a function to compute the modified Jacobian

               df       df
          jac = -- + c ------
               dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)

     The optional second argument names a function that defines the
     constraint functions whose roots are desired during the
     integration.  This function must have the form

          G_OUT = g (X, T)

     and return a vector of the constraint function values.  If the
     value of any of the constraint functions changes sign, DASRT will
     attempt to stop the integration at the point of the sign change.

     If the name of the constraint function is omitted, `dasrt' solves
     the same problem as `daspk' or `dassl'.

     Note that because of numerical errors in the constraint functions
     due to roundoff and integration error, DASRT may return false
     roots, or return the same root at two or more nearly equal values
     of T.  If such false roots are suspected, the user should consider
     smaller error tolerances or higher precision in the evaluation of
     the constraint functions.

     If a root of some constraint function defines the end of the
     problem, the input to DASRT should nevertheless allow integration
     to a point slightly past that root, so that DASRT can locate the
     root by interpolation.

     The third and fourth arguments to `dasrt' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly
     required to be consistent.  In practice, however, DASSL is not
     very good at determining a consistent set for you, so it is best
     if you ensure that the initial values result in the function
     evaluating to zero.

     The sixth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where
     there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be
     greater than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function `dasrt_options' to set optional
     parameters for `dasrt'.

     See also: daspk, dasrt, lsode
}

#
dasrt_options
{
`dasrt_options' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dasrt.oct

 -- Loadable Function:  dasrt_options (OPT, VAL)
     When called with two arguments, this function allows you set
     options parameters for the function `dasrt'.  Given one argument,
     `dasrt_options' returns the value of the corresponding option.  If
     no arguments are supplied, the names of all the available options
     and their current values are displayed.

     Options include

    `"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

    `"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is
                abs (local error in x(i)) <= ...
                    rtol(i) * abs (Y(i)) + atol(i)

    `"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize.

    `"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive.

    `"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions.

    `"step limit"'
          Maximum number of integration steps to attempt on a single
          call to the underlying Fortran code.
}

#
dassl
{
`dassl' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dassl.oct

 -- Loadable Function: [X, XDOT, ISTATE, MSG] = dassl (FCN, X_0,
          XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strings, inline functions, or function handles, the first
     element names the function f described above, and the second
     element names a function to compute the modified Jacobian

               df       df
          jac = -- + c ------
               dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)

     The second and third arguments to `dassl' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly
     required to be consistent.  In practice, however, DASSL is not
     very good at determining a consistent set for you, so it is best
     if you ensure that the initial values result in the function
     evaluating to zero.

     The fifth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where
     there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be
     greater than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function `dassl_options' to set optional
     parameters for `dassl'.

     See also: daspk, dasrt, lsode
}

#
dassl_options
{
`dassl_options' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dassl.oct

 -- Loadable Function:  dassl_options (OPT, VAL)
     When called with two arguments, this function allows you set
     options parameters for the function `dassl'.  Given one argument,
     `dassl_options' returns the value of the corresponding option.  If
     no arguments are supplied, the names of all the available options
     and their current values are displayed.

     Options include

    `"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

    `"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                abs (local error in x(i))
                     <= rtol(i) * abs (Y(i)) + atol(i)

    `"compute consistent initial condition"'
          If nonzero, `dassl' will attempt to compute a consistent set
          of initial conditions.  This is generally not reliable, so it
          is best to provide a consistent set and leave this option set
          to zero.

    `"enforce nonnegativity constraints"'
          If you know that the solutions to your equations will always
          be nonnegative, it may help to set this parameter to a nonzero
          value.  However, it is probably best to try leaving this
          option set to zero first, and only setting it to a nonzero
          value if that doesn't work very well.

    `"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize.

    `"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive.

    `"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions  (default is not specified).

    `"step limit"'
          Maximum number of integration steps to attempt on a single
          call to the underlying Fortran code.
}

#
date
{
`date' is a function from the file /usr/share/octave/3.2.3/m/time/date.m

 -- Function File:  date ()
     Return the date as a character string in the form DD-MMM-YY.  For
     example,

          date ()
               => "20-Aug-93"
}

#
datenum
{
`datenum' is a function from the file /usr/share/octave/3.2.3/m/time/datenum.m

 -- Function File:  datenum (YEAR, MONTH, DAY)
 -- Function File:  datenum (YEAR, MONTH, DAY, HOUR)
 -- Function File:  datenum (YEAR, MONTH, DAY, HOUR, MINUTE)
 -- Function File:  datenum (YEAR, MONTH, DAY, HOUR, MINUTE, SECOND)
 -- Function File:  datenum (`"date"')
 -- Function File:  datenum (`"date"', P)
     Returns the specified local time as a day number, with Jan 1, 0000
     being day 1.  By this reckoning, Jan 1, 1970 is day number 719529.
     The fractional portion, P, corresponds to the portion of the
     specified day.

     Notes:

        * Years can be negative and/or fractional.

        * Months below 1 are considered to be January.

        * Days of the month start at 1.

        * Days beyond the end of the month go into subsequent months.

        * Days before the beginning of the month go to the previous
          month.

        * Days can be fractional.

     *Warning:* this function does not attempt to handle Julian
     calendars so dates before Octave 15, 1582 are wrong by as much as
     eleven days.  Also be aware that only Roman Catholic countries
     adopted the calendar in 1582.  It took until 1924 for it to be
     adopted everywhere.  See the Wikipedia entry on the Gregorian
     calendar for more details.

     *Warning:* leap seconds are ignored.  A table of leap seconds is
     available on the Wikipedia entry for leap seconds.

     See also: date, clock, now, datestr, datevec, calendar, weekday
}

#
datestr
{
`datestr' is a function from the file /usr/share/octave/3.2.3/m/time/datestr.m

 -- Function File: STR = datestr (DATE, [F, [P]])
     Format the given date/time according to the format `f' and return
     the result in STR.  DATE is a serial date number (see `datenum')
     or a date vector (see `datevec').  The value of DATE may also be a
     string or cell array of strings.

     F can be an integer which corresponds to one of the codes in the
     table below, or a date format string.

     P is the year at the start of the century in which two-digit years
     are to be interpreted in.  If not specified, it defaults to the
     current year minus 50.

     For example, the date 730736.65149 (2000-09-07 15:38:09.0934)
     would be formatted as follows:

     Code    Format                         Example
     --------------------------------------------------------------- 
     0       dd-mmm-yyyy HH:MM:SS           07-Sep-2000 15:38:09
     1       dd-mmm-yyyy                    07-Sep-2000
     2       mm/dd/yy                       09/07/00
     3       mmm                            Sep
     4       m                              S
     5       mm                             09
     6       mm/dd                          09/07
     7       dd                             07
     8       ddd                            Thu
     9       d                              T
     10      yyyy                           2000
     11      yy                             00
     12      mmmyy                          Sep00
     13      HH:MM:SS                       15:38:09
     14      HH:MM:SS PM                    03:38:09 PM
     15      HH:MM                          15:38
     16      HH:MM PM                       03:38 PM
     17      QQ-YY                          Q3-00
     18      QQ                             Q3
     19      dd/mm                          13/03
     20      dd/mm/yy                       13/03/95
     21      mmm.dd.yyyy HH:MM:SS           Mar.03.1962 13:53:06
     22      mmm.dd.yyyy                    Mar.03.1962
     23      mm/dd/yyyy                     03/13/1962
     24      dd/mm/yyyy                     12/03/1962
     25      yy/mm/dd                       95/03/13
     26      yyyy/mm/dd                     1995/03/13
     27      QQ-YYYY                        Q4-2132
     28      mmmyyyy                        Mar2047
     29      yyyymmdd                       20470313
     30      yyyymmddTHHMMSS                20470313T132603
     31      yyyy-mm-dd HH:MM:SS            1047-03-13 13:26:03

     If F is a format string, the following symbols are recognized:

     Symbol  Meaning                                         Example
     ---------------------------------------------------------------------- 
     yyyy    Full year                                       2005
     yy      Two-digit year                                  2005
     mmmm    Full month name                                 December
     mmm     Abbreviated month name                          Dec
     mm      Numeric month number (padded with zeros)        01, 08, 12
     m       First letter of month name (capitalized)        D
     dddd    Full weekday name                               Sunday
     ddd     Abbreviated weekday name                        Sun
     dd      Numeric day of month (padded with zeros)        11
     d       First letter of weekday name (capitalized)      S
     HH      Hour of day, padded with zeros if PM is set     09:00
             and not padded with zeros otherwise             9:00 AM
     MM      Minute of hour (padded with zeros)              10:05
     SS      Second of minute (padded with zeros)            10:05:03
     PM      Use 12-hour time format                         11:30 PM

     If F is not specified or is `-1', then use 0, 1 or 16, depending
     on whether the date portion or the time portion of DATE is empty.

     If P is nor specified, it defaults to the current year minus 50.

     If a matrix or cell array of dates is given, a vector of date
     strings is returned.

     See also: datenum, datevec, date, clock, now, datetick
}

#
datetick
{
`datetick' is a function from the file /usr/share/octave/3.2.3/m/time/datetick.m

 -- Function File:  datetick (FORM)
 -- Function File:  datetick (AXIS, FORM)
 -- Function File:  datetick (..., "keeplimits")
 -- Function File:  datetick (..., "keepticks")
 -- Function File:  datetick (...ax, ...)
     Adds date formatted tick labels to an axis.  The axis the apply the
     ticks to is determined by AXIS that can take the values "x", "y"
     or "z".  The default value is "x".  The formatting of the labels is
     determined by the variable FORM, that can either be a string in
     the format needed by `dateform', or a positive integer that can be
     accepted by `datestr'.

     See also: datenum, datestr
}

#
datevec
{
`datevec' is a function from the file /usr/share/octave/3.2.3/m/time/datevec.m

 -- Function File: V = datevec (DATE)
 -- Function File: V = datevec (DATE, F)
 -- Function File: V = datevec (DATE, P)
 -- Function File: V = datevec (DATE, F, P)
 -- Function File: [Y, M, D, H, MI, S] = datevec (...)
     Convert a serial date number (see `datenum') or date string (see
     `datestr') into a date vector.

     A date vector is a row vector with six members, representing the
     year, month, day, hour, minute, and seconds respectively.

     F is the format string used to interpret date strings (see
     `datestr').

     P is the year at the start of the century in which two-digit years
     are to be interpreted in.  If not specified, it defaults to the
     current year minus 50.

     See also: datenum, datestr, date, clock, now
}

#
dbclear
{
`dbclear' is a built-in function

 -- Loadable Function:  dbclear (FUNC, LINE, ...)
     Delete a breakpoint in a function
    `func'
          String representing the function name.  When already in debug
          mode this should be left out and only the line should be
          given.

    `line'
          Line number where you would like to remove the breakpoint.
          Multiple lines might be given as separate arguments or as a
          vector.
     No checking is done to make sure that the line you requested is
     really a breakpoint.  If you get the wrong line nothing will
     happen.

     See also: dbstop, dbstatus, dbwhere
}

#
dbcont
{
`dbcont' is a built-in function

 -- Command:  dbcont ()
     In debugging mode, quit debugging mode and continue execution.

     See also: dbstep, dbstep
}

#
dbdown
{
`dbdown' is a built-in function

 -- Loadable Function:  dbdown (N)
     In debugging mode, move down the execution stack N frames.  If N
     is omitted, move down one frame.

     See also: dbstack
}

#
dblquad
{
`dblquad' is a function from the file /usr/share/octave/3.2.3/m/general/dblquad.m

 -- Function File:  dblquad (F, XA, XB, YA, YB, TOL, QUADF, ...)
     Numerically evaluate a double integral.  The function over with to
     integrate is defined by `F', and the interval for the integration
     is defined by `[XA, XB, YA, YB]'.  The function F must accept a
     vector X and a scalar Y, and return a vector of the same length as
     X.

     If defined, TOL defines the absolute tolerance to which to which
     to integrate each sub-integral.

     Additional arguments, are passed directly to F.  To use the default
     value for TOL one may pass an empty matrix.

     See also: triplequad, quad, quadv, quadl, quadgk, trapz
}

#
dbnext
{
`dbnext' is a built-in function

 -- Command:  dbstep N
 -- Command:  dbstep in
 -- Command:  dbstep out
     In debugging mode, execute the next N lines of code.  If N is
     omitted execute the next line of code.  If the next line of code
     is itself defined in terms of an m-file remain in the existing
     function.

     Using `dbstep in' will cause execution of the next line to step
     into any m-files defined on the next line.  Using `dbstep out'
     with cause execution to continue until the current function
     returns.

     See also: dbcont, dbquit
}

#
dbquit
{
`dbquit' is a built-in function

 -- Command:  dbquit ()
     In debugging mode, quit debugging mode and return to the top level.

     See also: dbstep, dbcont
}

#
dbstack
{
`dbstack' is a built-in function

 -- Loadable Function: [STACK, IDX] dbstack (N)
     Print or return current stack information.  With optional argument
     N, omit the N innermost stack frames.

     See also: dbclear, dbstatus, dbstop
}

#
dbstatus
{
`dbstatus' is a built-in function

 -- Loadable Function: lst = dbstatus (FUNC)
     Return a vector containing the lines on which a function has
     breakpoints set.
    `func'
          String representing the function name.  When already in debug
          mode this should be left out.

     See also: dbclear, dbwhere
}

#
dbstep
{
`dbstep' is a built-in function

 -- Command:  dbstep N
 -- Command:  dbstep in
 -- Command:  dbstep out
     In debugging mode, execute the next N lines of code.  If N is
     omitted execute the next line of code.  If the next line of code
     is itself defined in terms of an m-file remain in the existing
     function.

     Using `dbstep in' will cause execution of the next line to step
     into any m-files defined on the next line.  Using `dbstep out'
     with cause execution to continue until the current function
     returns.

     See also: dbcont, dbquit
}

#
dbstop
{
`dbstop' is a built-in function

 -- Loadable Function: RLINE = dbstop (FUNC, LINE, ...)
     Set a breakpoint in a function
    `func'
          String representing the function name.  When already in debug
          mode this should be left out and only the line should be
          given.

    `line'
          Line number you would like the breakpoint to be set on.
          Multiple lines might be given as separate arguments or as a
          vector.

     The rline returned is the real line that the breakpoint was set at.

     See also: dbclear, dbstatus, dbstep
}

#
dbtype
{
`dbtype' is a built-in function

 -- Loadable Function:  dbtype ()
     List script file with line numbers.

     See also: dbclear, dbstatus, dbstop
}

#
dbup
{
`dbup' is a built-in function

 -- Loadable Function:  dbup (N)
     In debugging mode, move up the execution stack N frames.  If N is
     omitted, move up one frame.

     See also: dbstack
}

#
dbwhere
{
`dbwhere' is a built-in function

 -- Loadable Function:  dbwhere ()
     Show where we are in the code

     See also: dbclear, dbstatus, dbstop
}

#
deal
{
`deal' is a function from the file /usr/share/octave/3.2.3/m/general/deal.m

 -- Function File: [R1, R2, ..., RN] = deal (A)
 -- Function File: [R1, R2, ..., RN] = deal (A1, A2, ..., AN)
     Copy the input parameters into the corresponding output parameters.
     If only one input parameter is supplied, its value is copied to
     each of the outputs.

     For example,

          [a, b, c] = deal (x, y, z);

     is equivalent to

          a = x;
          b = y;
          c = z;

     and

          [a, b, c] = deal (x);

     is equivalent to

          a = b = c = x;
}

#
deblank
{
`deblank' is a function from the file /usr/share/octave/3.2.3/m/strings/deblank.m

 -- Function File:  deblank (S)
     Remove trailing blanks and nulls from S.  If S is a matrix,
     DEBLANK trims each row to the length of longest string.  If S is a
     cell array, operate recursively on each element of the cell array.
}

#
debug
{
`debug' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/debug.m

 -- Function File:  debug ()
     Summary of the debugging commands.  The debugging commands that are
     available in Octave are

    `keyboard'
          Force entry into debug mode.

    `dbstop'
          Add a breakpoint.

    `dbclear'
          Remove a breakpoint.

    `dbstatus'
          List all breakpoints.

    `dbcont'
          Continue execution from the debug prompt.

    `dbstack'
          Print a backtrace of the execution stack.

    `dbstep'
          Execute one or more lines and re-enter debug mode

    `dbtype'
          List the function where execution is currently stopped,
          enumerating the lines.

    `dbup'
          The workspace up the execution stack.

    `dbdown'
          The workspace down the execution stack.

    `dbquit'
          Quit debugging mode and return to the main prompt.

    `debug_on_error'
          Flag whether to enter debug mode in case Octave encounters an
          error.

    `debug_on_warning'
          Flag whether to enter debug mode in case Octave encounters a
          warning.

    `debug_on_interrupt'
          Flag whether to enter debug mode in case Octave encounters an
          interupt.


     when Octave encounters a breakpoint or other reason to enter debug
     mode, the prompt changes to `"debug>"'.  The workspace of the
     function where the breakpoint was encountered becomes available
     and any Octave command that works within that workspace may be
     executed.

     See also: dbstop, dbclear, dbstatus, dbcont, dbstack, dbstep,
     dbtype, dbup, dbdown, dbquit, debug_on_error, debug_on_warning,
     debug_on_interrupt
}

#
debug_on_error
{
`debug_on_error' is a built-in function

 -- Built-in Function: VAL = debug_on_error ()
 -- Built-in Function: OLD_VAL = debug_on_error (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when an error is encountered.  This
     will also inhibit printing of the normal traceback message (you
     will only see the top-level error message).
}

#
debug_on_interrupt
{
`debug_on_interrupt' is a built-in function

 -- Built-in Function: VAL = debug_on_interrupt ()
 -- Built-in Function: OLD_VAL = debug_on_interrupt (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will try to enter debugging mode when it receives an interrupt
     signal (typically generated with `C-c').  If a second interrupt
     signal is received before reaching the debugging mode, a normal
     interrupt will occur.
}

#
debug_on_warning
{
`debug_on_warning' is a built-in function

 -- Built-in Function: VAL = debug_on_warning ()
 -- Built-in Function: OLD_VAL = debug_on_warning (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when a warning is encountered.
}

#
dec2base
{
`dec2base' is a function from the file /usr/share/octave/3.2.3/m/strings/dec2base.m

 -- Function File:  dec2base (N, B, LEN)
     Return a string of symbols in base B corresponding to the
     non-negative integer N.

          dec2base (123, 3)
               => "11120"

     If N is a vector, return a string matrix with one row per value,
     padded with leading zeros to the width of the largest value.

     If B is a string then the characters of B are used as the symbols
     for the digits of N.  Space (' ') may not be used as a symbol.

          dec2base (123, "aei")
               => "eeeia"

     The optional third argument, LEN, specifies the minimum number of
     digits in the result.

     See also: base2dec, dec2bin, bin2dec, hex2dec, dec2hex
}

#
dec2bin
{
`dec2bin' is a function from the file /usr/share/octave/3.2.3/m/strings/dec2bin.m

 -- Function File:  dec2bin (N, LEN)
     Return a binary number corresponding to the non-negative decimal
     number N, as a string of ones and zeros.  For example,

          dec2bin (14)
               => "1110"

     If N is a vector, returns a string matrix, one row per value,
     padded with leading zeros to the width of the largest value.

     The optional second argument, LEN, specifies the minimum number of
     digits in the result.

     See also: bin2dec, dec2base, base2dec, hex2dec, dec2hex
}

#
dec2hex
{
`dec2hex' is a function from the file /usr/share/octave/3.2.3/m/strings/dec2hex.m

 -- Function File:  dec2hex (N, LEN)
     Return the hexadecimal string corresponding to the non-negative
     integer N.  For example,

          dec2hex (2748)
               => "ABC"

     If N is a vector, returns a string matrix, one row per value,
     padded with leading zeros to the width of the largest value.

     The optional second argument, LEN, specifies the minimum number of
     digits in the result.

     See also: hex2dec, dec2base, base2dec, bin2dec, dec2bin
}

#
deconv
{
`deconv' is a function from the file /usr/share/octave/3.2.3/m/polynomial/deconv.m

 -- Function File:  deconv (Y, A)
     Deconvolve two vectors.

     `[b, r] = deconv (y, a)' solves for B and R such that `y = conv
     (a, b) + r'.

     If Y and A are polynomial coefficient vectors, B will contain the
     coefficients of the polynomial quotient and R will be a remainder
     polynomial of lowest order.

     See also: conv, poly, roots, residue, polyval, polyderiv, polyinteg
}

#
default_save_options
{
`default_save_options' is a built-in function

 -- Built-in Function: VAL = default_save_options ()
 -- Built-in Function: OLD_VAL = default_save_options (NEW_VAL)
     Query or set the internal variable that specifies the default
     options for the `save' command, and defines the default format.
     Typical values include `"-ascii"', `"-text -zip"'.  The default
     value is `-text'.

     See also: save
}

#
del2
{
`del2' is a function from the file /usr/share/octave/3.2.3/m/general/del2.m

 -- Function File: D = del2 (M)
 -- Function File: D = del2 (M, H)
 -- Function File: D = del2 (M, DX, DY, ...)
     Calculate the discrete Laplace operator.  For a 2-dimensional
     matrix M this is defined as

                1    / d^2            d^2         \
          D  = --- * | ---  M(x,y) +  ---  M(x,y) |
                4    \ dx^2           dy^2        /

     For N-dimensional arrays the sum in parentheses is expanded to
     include second derivatives over the additional higher dimensions.

     The spacing between evaluation points may be defined by H, which
     is a scalar defining the equidistant spacing in all dimensions.
     Alternatively, the spacing in each dimension may be defined
     separately by DX, DY, etc.  A scalar spacing argument defines
     equidistant spacing, whereas a vector argument can be used to
     specify variable spacing.  The length of the spacing vectors must
     match the respective dimension of M.  The default spacing value is
     1.

     At least 3 data points are needed for each dimension.  Boundary
     points are calculated from the linear extrapolation of interior
     points.

     See also: gradient, diff
}

#
delaunay
{
`delaunay' is a function from the file /usr/share/octave/3.2.3/m/geometry/delaunay.m

 -- Function File: TRI = delaunay (X, Y)
 -- Function File: TRI = delaunay (X, Y, OPT)
     The return matrix of size [n, 3] contains a set triangles which are
     described by the indices to the data point x and y vector.  The
     triangulation satisfies the Delaunay circum-circle criterion.  No
     other data point is in the circum-circle of the defining triangle.

     A third optional argument, which must be a string, contains extra
     options passed to the underlying qhull command.  See the
     documentation for the Qhull library for details.

          x = rand (1, 10);
          y = rand (size (x));
          T = delaunay (x, y);
          X = [x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1))];
          Y = [y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1))];
          axis ([0,1,0,1]);
          plot (X, Y, "b", x, y, "r*");

     See also: voronoi, delaunay3, delaunayn
}

#
delaunay3
{
`delaunay3' is a function from the file /usr/share/octave/3.2.3/m/geometry/delaunay3.m

 -- Function File: T = delaunay3 (X, Y, Z)
 -- Function File: T = delaunay3 (X, Y, Z, OPT)
     A matrix of size [n, 4] is returned.  Each row contains a set of
     tetrahedron which are described by the indices to the data point
     vectors (x,y,z).

     A fourth optional argument, which must be a string or cell array
     of strings, contains extra options passed to the underlying qhull
     command.  See the documentation for the Qhull library for details.

     See also: delaunay, delaunayn
}

#
delaunayn
{
`delaunayn' is a function from the file /usr/share/octave/3.2.3/m/geometry/delaunayn.m

 -- Function File: T = delaunayn (P)
 -- Function File: T = delaunayn (P, OPT)
     Form the Delaunay triangulation for a set of points.  The Delaunay
     triangulation is a tessellation of the convex hull of the points
     such that no n-sphere defined by the n-triangles contains any
     other points from the set.  The input matrix P of size `[n, dim]'
     contains N points in a space of dimension dim.  The return matrix
     T has the size `[m, dim+1]'.  It contains for each row a set of
     indices to the points, which describes a simplex of dimension dim.
     For example, a 2d simplex is a triangle and 3d simplex is a
     tetrahedron.

     Extra options for the underlying Qhull command can be specified by
     the second argument.  This argument is a cell array of strings.
     The default options depend on the dimension of the input:

        * 2D and 3D: OPT = `{"Qt", "Qbb", "Qc"}'

        * 4D and higher: OPT = `{"Qt", "Qbb", "Qc", "Qz"}'

     If OPT is [], then the default arguments are used.  If OPT is
     `{""}', then none of the default arguments are used by Qhull.  See
     the Qhull documentation for the available options.

     All options can also be specified as single string, for example
     `"Qt Qbb Qc Qz"'.
}

#
delete
{
`delete' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/delete.m

 -- Function File:  delete (FILE)
 -- Function File:  delete (HANDLE)
     Delete the named file or graphics handle.

     Deleting graphics objects is the proper way to remove features
     from a plot without clearing the entire figure.

     See also: clf, cla
}

#
dellistener
{
`dellistener' is a built-in function

 -- Built-in Function:  dellistener (H, PROP, FCN)
     Remove the registration of FCN as a listener for the property PROP
     of the graphics object H.  The function FCN must be the same
     variable (not just the same value), as was passed to the original
     call to `addlistener'.

     If FCN is not defined then all listener functions of PROP are
     removed.

     Example:

          function my_listener (h, dummy, p1)
           fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          c = {@my_listener, "my string"};
          addlistener (gcf, "position", c);
          dellistener (gcf, "position", c);
}

#
demo
{
`demo' is a function from the file /usr/share/octave/3.2.3/m/testfun/demo.m

 -- Function File:  demo ('NAME',N)
     Runs any examples associated with the function 'NAME'.  Examples
     are stored in the script file, or in a file with the same name but
     no extension somewhere on your path.  To keep them separate from
     the usual script code, all lines are prefixed by `%!'.  Each
     example is introduced by the keyword 'demo' flush left to the
     prefix, with no intervening spaces.  The remainder of the example
     can contain arbitrary Octave code.  For example:

             %!demo
             %! t=0:0.01:2*pi; x = sin(t);
             %! plot(t,x)
             %! %-------------------------------------------------
             %! % the figure window shows one cycle of a sine wave

     Note that the code is displayed before it is executed, so a simple
     comment at the end suffices.  It is generally not necessary to use
     disp or printf within the demo.

     Demos are run in a function environment with no access to external
     variables.  This means that all demos in your function must use
     separate initialization code.  Alternatively, you can combine your
     demos into one huge demo, with the code:

             %! input("Press <enter> to continue: ","s");

     between the sections, but this is discouraged.  Other techniques
     include using multiple plots by saying figure between each, or
     using subplot to put multiple plots in the same window.

     Also, since demo evaluates inside a function context, you cannot
     define new functions inside a demo.  Instead you will have to use
     `eval(example('function',n))' to see them.  Because eval only
     evaluates one line, or one statement if the statement crosses
     multiple lines, you must wrap your demo in "if 1 <demo stuff>
     endif" with the 'if' on the same line as 'demo'.  For example,

            %!demo if 1
            %!  function y=f(x)
            %!    y=x;
            %!  endfunction
            %!  f(3)
            %! endif

     See also: test, example
}

#
det
{
`det' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/det.oct

 -- Loadable Function: [D, RCOND] = det (A)
     Compute the determinant of A using LAPACK for full and UMFPACK for
     sparse matrices.  Return an estimate of the reciprocal condition
     number if requested.
}

#
detrend
{
`detrend' is a function from the file /usr/share/octave/3.2.3/m/signal/detrend.m

 -- Function File:  detrend (X, P)
     If X is a vector, `detrend (X, P)' removes the best fit of a
     polynomial of order P from the data X.

     If X is a matrix, `detrend (X, P)' does the same for each column
     in X.

     The second argument is optional.  If it is not specified, a value
     of 1 is assumed.  This corresponds to removing a linear trend.
}

#
diag
{
`diag' is a built-in function

 -- Built-in Function:  diag (V, K)
     Return a diagonal matrix with vector V on diagonal K.  The second
     argument is optional.  If it is positive, the vector is placed on
     the K-th super-diagonal.  If it is negative, it is placed on the
     -K-th sub-diagonal.  The default value of K is 0, and the vector
     is placed on the main diagonal.  For example,

          diag ([1, 2, 3], 1)
              =>  0  1  0  0
                  0  0  2  0
                  0  0  0  3
                  0  0  0  0

     Given a matrix argument, instead of a vector, `diag' extracts the
     K-th diagonal of the matrix.
}

#
diary
{
`diary' is a built-in function

 -- Command: diary options
     Record a list of all commands _and_ the output they produce, mixed
     together just as you see them on your terminal.  Valid options are:

    `on'
          Start recording your session in a file called `diary' in your
          current working directory.

    `off'
          Stop recording your session in the diary file.

    `FILE'
          Record your session in the file named FILE.

     With no arguments, `diary' toggles the current diary state.
}

#
diff
{
`diff' is a function from the file /usr/share/octave/3.2.3/m/general/diff.m

 -- Function File:  diff (X, K, DIM)
     If X is a vector of length N, `diff (X)' is the vector of first
     differences  X(2) - X(1), ..., X(n) - X(n-1).

     If X is a matrix, `diff (X)' is the matrix of column differences
     along the first non-singleton dimension.

     The second argument is optional.  If supplied, `diff (X, K)',
     where K is a non-negative integer, returns the K-th differences.
     It is possible that K is larger than then first non-singleton
     dimension of the matrix.  In this case, `diff' continues to take
     the differences along the next non-singleton dimension.

     The dimension along which to take the difference can be explicitly
     stated with the optional variable DIM.  In this case the K-th
     order differences are calculated along this dimension.  In the
     case where K exceeds `size (X, DIM)' then an empty matrix is
     returned.
}

#
diffpara
{
`diffpara' is a function from the file /usr/share/octave/3.2.3/m/signal/diffpara.m

 -- Function File: [D, DD] = diffpara (X, A, B)
     Return the estimator D for the differencing parameter of an
     integrated time series.

     The frequencies from [2*pi*a/t, 2*pi*b/T] are used for the
     estimation.  If B is omitted, the interval [2*pi/T, 2*pi*a/T] is
     used.  If both B and A are omitted then a = 0.5 * sqrt (T) and b =
     1.5 * sqrt (T) is used, where T is the sample size.  If X is a
     matrix, the differencing parameter of each column is estimated.

     The estimators for all frequencies in the intervals described
     above is returned in DD.  The value of D is simply the mean of DD.

     Reference: Brockwell, Peter J. & Davis, Richard A. Time Series:
     Theory and Methods Springer 1987.
}

#
diffuse
{
`diffuse' is a function from the file /usr/share/octave/3.2.3/m/plot/diffuse.m

 -- Function File:  diffuse (SX, SY, SZ, L)
     Calculate diffuse reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ.  The light vector can be
     specified using parameter L.  It can be given as 2-element vector
     [azimuth, elevation] in degrees or as 3-element vector [lx, ly,
     lz].

     See also: specular, surfl
}

#
dir
{
`dir' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/dir.m

 -- Function File:  dir (DIRECTORY)
 -- Function File: [LIST] = dir (DIRECTORY)
     Display file listing for directory DIRECTORY.  If a return value
     is requested, return a structure array with the fields

          name
          bytes
          date
          isdir
          statinfo

     in which `statinfo' is the structure returned from `stat'.

     If DIRECTORY is not a directory, return information about the
     named FILENAME.  DIRECTORY may be a list of directories specified
     either by name or with wildcard characters (like * and ?)  which
     will be expanded with glob.

     Note that for symbolic links, `dir' returns information about the
     file that a symbolic link points to instead of the link itself.
     However, if the link points to a nonexistent file, `dir' returns
     information about the link.

     See also: ls, stat, lstat, readdir, glob, filesep
}

#
discrete_cdf
{
`discrete_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/discrete_cdf.m

 -- Function File:  discrete_cdf (X, V, P)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of a univariate discrete distribution which
     assumes the values in V with probabilities P.
}

#
discrete_inv
{
`discrete_inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/discrete_inv.m

 -- Function File:  discrete_inv (X, V, P)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the univariate distribution which assumes the values
     in V with probabilities P.
}

#
discrete_pdf
{
`discrete_pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/discrete_pdf.m

 -- Function File:  discrete_pdf (X, V, P)
     For each element of X, compute the probability density function
     (PDF) at X of a univariate discrete distribution which assumes the
     values in V with probabilities P.
}

#
discrete_rnd
{
`discrete_rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/discrete_rnd.m

 -- Function File:  discrete_rnd (N, V, P)
 -- Function File:  discrete_rnd (V, P, R, C)
 -- Function File:  discrete_rnd (V, P, SZ)
     Generate a row vector containing a random sample of size N from
     the univariate distribution which assumes the values in V with
     probabilities P.  N must be a scalar.

     If R and C are given create a matrix with R rows and C columns.
     Or if SZ is a vector, create a matrix of size SZ.
}

#
disp
{
`disp' is a built-in function

 -- Built-in Function:  disp (X)
     Display the value of X.  For example,

          disp ("The value of pi is:"), disp (pi)

              -| the value of pi is:
              -| 3.1416

     Note that the output from `disp' always ends with a newline.

     If an output value is requested, `disp' prints nothing and returns
     the formatted output in a string.

     See also: fdisp
}

#
dispatch
{
`dispatch' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dispatch.oct

 -- Loadable Function:  dispatch (F, R, TYPE)
     Replace the function F with a dispatch so that function R is
     called when F is called with the first argument of the named TYPE.
     If the type is ANY then call R if no other type matches.  The
     original function F is accessible using `builtin (F, ...)'.

     If R is omitted, clear dispatch function associated with TYPE.

     If both R and TYPE are omitted, list dispatch functions for F.

     See also: builtin
}

#
display
{
`display' is a function from the file /usr/share/octave/3.2.3/m/general/display.m

 -- Function File:  display (A)
     Display the contents of an object.  If A is an object of the class
     "myclass", then `display' is called in a case like

          myclass (...)

     where Octave is required to display the contents of a variable of
     the type "myclass".

     See also: class, subsref, subsasgn
}

#
dlmread
{
`dlmread' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dlmread.oct

 -- Loadable Function: DATA = dlmread (FILE)
 -- Loadable Function: DATA = dlmread (FILE, SEP)
 -- Loadable Function: DATA = dlmread (FILE, SEP, R0, C0)
 -- Loadable Function: DATA = dlmread (FILE, SEP, RANGE)
     Read the matrix DATA from a text file.  If not defined the
     separator between fields is determined from the file itself.
     Otherwise the separation character is defined by SEP.

     Given two scalar arguments R0 and C0, these define the starting
     row and column of the data to be read.  These values are indexed
     from zero, such that the first row corresponds to an index of zero.

     The RANGE parameter must be a 4 element vector containing the upper
     left and lower right corner `[R0,C0,R1,C1]' or a spreadsheet style
     range such as 'A2..Q15'.  The lowest index value is zero.
}

#
dlmwrite
{
`dlmwrite' is a function from the file /usr/share/octave/3.2.3/m/io/dlmwrite.m

 -- Function File:  dlmwrite (FILE, A)
 -- Function File:  dlmwrite (FILE, A, DELIM, R, C)
 -- Function File:  dlmwrite (FILE, A, KEY, VAL ...)
 -- Function File:  dlmwrite (FILE, A, "-append", ...)
     Write the matrix A to the named file using delimiters.

     The parameter DELIM specifies the delimiter to use to separate
     values on a row.

     The value of R specifies the number of delimiter-only lines to add
     to the start of the file.

     The value of C specifies the number of delimiters to prepend to
     each line of data.

     If the argument `"-append"' is given, append to the end of the
     FILE.

     In addition, the following keyword value pairs may appear at the
     end of the argument list:
    `"append"'
          Either `"on"' or `"off"'.  See `"-append"' above.

    `"delimiter"'
          See DELIM above.

    `"newline"'
          The character(s) to use to separate each row.  Three special
          cases exist for this option.  `"unix"' is changed into '\n',
          `"pc"' is changed into '\r\n', and `"mac"' is changed into
          '\r'.  Other values for this option are kept as is.

    `"roffset"'
          See R above.

    `"coffset"'
          See C above.

    `"precision"'
          The precision to use when writing the file.  It can either be
          a format string (as used by fprintf) or a number of
          significant digits.

          dlmwrite ("file.csv", reshape (1:16, 4, 4));

          dlmwrite ("file.tex", a, "delimiter", "&", "newline", "\\n")

     See also: dlmread, csvread, csvwrite
}

#
dmperm
{
`dmperm' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dmperm.oct

 -- Loadable Function: P = dmperm (S)
 -- Loadable Function: [P, Q, R, S] = dmperm (S)
     Perform a Dulmage-Mendelsohn permutation on the sparse matrix S.
     With a single output argument "dmperm" performs the row
     permutations P such that `S (P,:)' has no zero elements on the
     diagonal.

     Called with two or more output arguments, returns the row and
     column permutations, such that `S (P, Q)' is in block triangular
     form.  The values of R and S define the boundaries of the blocks.
     If S is square then `R == S'.

     The method used is described in: A. Pothen & C.-J. Fan. Computing
     the block triangular form of a sparse matrix. ACM Trans. Math.
     Software, 16(4):303-324, 1990.

     See also: colamd, ccolamd
}

#
dmult
{
`dmult' is a function from the file /usr/share/octave/3.2.3/m/deprecated/dmult.m

 -- Function File:  dmult (A, B)
     This function has been deprecated.  Use the direct syntax
     `diag(A)*B' which is more readable and now also more efficient.
}

#
do
{

 -- Keyword: do
     Begin a do-until loop.  This differs from a do-while loop in that
     the body of the loop is executed at least once.

     See also: while
}

#
do_string_escapes
{
`do_string_escapes' is a built-in function

 -- Built-in Function:  do_string_escapes (STRING)
     Convert special characters in STRING to their escaped forms.
}

#
doc
{
`doc' is a function from the file /usr/share/octave/3.2.3/m/help/doc.m

 -- Command: doc FUNCTION_NAME
     Display documentation for the function FUNCTION_NAME directly from
     an on-line version of the printed manual, using the GNU Info
     browser.  If invoked without any arguments, the manual is shown
     from the beginning.

     For example, the command `doc rand' starts the GNU Info browser at
     the `rand' node in the on-line version of the manual.

     Once the GNU Info browser is running, help for using it is
     available using the command `C-h'.

     See also: help
}

#
doc_cache_file
{
`doc_cache_file' is a built-in function

 -- Built-in Function: VAL = doc_cache_file ()
 -- Built-in Function: OLD_VAL = doc_cache_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     Octave documentation cache file.  A cache file significantly
     improves the performance of the `lookfor' command.  The default
     value is `OCTAVE-HOME/share/octave/VERSION/etc/doc-cache', in
     which OCTAVE-HOME is the root directory of the Octave installation,
     and VERSION is the Octave version number.  The default value may
     be overridden by the environment variable `OCTAVE_DOC_CACHE_FILE',
     or the command line argument `--doc-cache-file NAME'.

     See also: lookfor, info_program, doc, help, makeinfo_program
}

#
dos
{
`dos' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/dos.m

 -- Function File: [STATUS, TEXT] = dos (COMMAND)
 -- Function File: [STATUS, TEXT] = dos (COMMAND, "-echo")
     Execute a system command if running under a Windows-like operating
     system, otherwise do nothing.  Return the exit status of the
     program in STATUS and any output sent to the standard output in
     TEXT.  If the optional second argument `"-echo"' is given, then
     also send the output from the command to the standard output.

     See also: unix, isunix, ispc, system
}

#
dot
{
`dot' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/dot.m

 -- Function File:  dot (X, Y, DIM)
     Computes the dot product of two vectors.  If X and Y are matrices,
     calculate the dot-product along the first non-singleton dimension.
     If the optional argument DIM is given, calculate the dot-product
     along this dimension.
}

#
double
{
`double' is a built-in function

 -- Built-in Function:  double (X)
     Convert X to double precision type.

     See also: single
}

#
drawnow
{
`drawnow' is a built-in function

 -- Built-in Function:  drawnow ()
 -- Built-in Function:  drawnow ("expose")
 -- Built-in Function:  drawnow (TERM, FILE, MONO, DEBUG_FILE)
     Update figure windows and their children.  The event queue is
     flushed and any callbacks generated are executed.  With the
     optional argument `"expose"', only graphic objects are updated and
     no other events or callbacks are processed.  The third calling
     form of `drawnow' is for debugging and is undocumented.
}

#
dsearch
{
`dsearch' is a function from the file /usr/share/octave/3.2.3/m/geometry/dsearch.m

 -- Function File: IDX = dsearch (X, Y, TRI, XI, YI)
 -- Function File: IDX = dsearch (X, Y, TRI, XI, YI, S)
     Returns the index IDX or the closest point in `X, Y' to the
     elements `[XI(:), YI(:)]'.  The variable S is accepted but ignored
     for compatibility.

     See also: dsearchn, tsearch
}

#
dsearchn
{
`dsearchn' is a function from the file /usr/share/octave/3.2.3/m/geometry/dsearchn.m

 -- Function File: IDX = dsearchn (X, TRI, XI)
 -- Function File: IDX = dsearchn (X, TRI, XI, OUTVAL)
 -- Function File: IDX = dsearchn (X, XI)
 -- Function File: [IDX, D] = dsearchn (...)
     Returns the index IDX or the closest point in X to the elements
     XI.  If OUTVAL is supplied, then the values of XI that are not
     contained within one of the simplicies TRI are set to OUTVAL.
     Generally, TRI is returned from `delaunayn (X)'.

     See also: dsearch, tsearch
}

#
dump_prefs
{
`dump_prefs' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/dump_prefs.m

 -- Function File:  dump_prefs (FILE)
     Have Octave dump all the current user preference variables to FILE
     in a format that can be parsed by Octave later.  If FILE is
     omitted, the listing is printed to stdout.
}

#
dup2
{
`dup2' is a built-in function

 -- Built-in Function: [FID, MSG] = dup2 (OLD, NEW)
     Duplicate a file descriptor.

     If successful, FID is greater than zero and contains the new file
     ID.  Otherwise, FID is negative and MSG contains a
     system-dependent error message.
}

#
duplication_matrix
{
`duplication_matrix' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/duplication_matrix.m

 -- Function File:  duplication_matrix (N)
     Return the duplication matrix  Dn  which is the unique  n^2 by
     n*(n+1)/2  matrix such that  Dn vech (A) = vec (A)  for all
     symmetric  n by n  matrices  A.

     See Magnus and Neudecker (1988), Matrix differential calculus with
     applications in statistics and econometrics.
}

#
durbinlevinson
{
`durbinlevinson' is a function from the file /usr/share/octave/3.2.3/m/signal/durbinlevinson.m

 -- Function File:  durbinlevinson (C, OLDPHI, OLDV)
     Perform one step of the Durbin-Levinson algorithm.

     The vector C specifies the autocovariances `[gamma_0, ...,
     gamma_t]' from lag 0 to T, OLDPHI specifies the coefficients based
     on C(T-1) and OLDV specifies the corresponding error.

     If OLDPHI and OLDV are omitted, all steps from 1 to T of the
     algorithm are performed.
}

#
e
{
`e' is a built-in function

 -- Built-in Function:  e
 -- Built-in Function:  e (N)
 -- Built-in Function:  e (N, M)
 -- Built-in Function:  e (N, M, K, ...)
 -- Built-in Function:  e (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the base of natural logarithms.  The constant `e'
     satisfies the equation `log' (e) = 1.

     When called with no arguments, return a scalar with the value e.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".
}

#
echo
{
`echo' is a built-in function

 -- Command: echo options
     Control whether commands are displayed as they are executed.  Valid
     options are:

    `on'
          Enable echoing of commands as they are executed in script
          files.

    `off'
          Disable echoing of commands as they are executed in script
          files.

    `on all'
          Enable echoing of commands as they are executed in script
          files and functions.

    `off all'
          Disable echoing of commands as they are executed in script
          files and functions.

     With no arguments, `echo' toggles the current echo state.
}

#
echo_executing_commands
{
`echo_executing_commands' is a built-in function

 -- Built-in Function: VAL = echo_executing_commands ()
 -- Built-in Function: OLD_VAL = echo_executing_commands (NEW_VAL)
     Query or set the internal variable that controls the echo state.
     It may be the sum of the following values:

    1
          Echo commands read from script files.

    2
          Echo commands from functions.

    4
          Echo commands read from command line.

     More than one state can be active at once.  For example, a value
     of 3 is equivalent to the command `echo on all'.

     The value of `echo_executing_commands' may be set by the `echo'
     command or the command line option `--echo-commands'.
}

#
edit
{
`edit' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/edit.m

 -- Command: edit NAME
 -- Command: edit FIELD VALUE
 -- Command: VALUE = edit get FIELD
     Edit the named function, or change editor settings.

     If `edit' is called with the name of a file or function as its
     argument it will be opened in a text editor.

        * If the function NAME is available in a file on your path and
          that file is modifiable, then it will be edited in place.  If
          it is a system function, then it will first be copied to the
          directory `HOME' (see further down) and then edited.  If no
          file is found, then the m-file variant, ending with ".m",
          will be considered.  If still no file is found, then variants
          with a leading "@" and then with both a leading "@" and
          trailing ".m" will be considered.

        * If NAME is the name of a function defined in the interpreter
          but not in an m-file, then an m-file will be created in `HOME'
          to contain that function along with its current definition.

        * If `name.cc' is specified, then it will search for `name.cc'
          in the path and try to modify it, otherwise it will create a
          new `.cc' file in `HOME'.  If NAME happens to be an m-file or
          interpreter defined function, then the text of that function
          will be inserted into the .cc file as a comment.

        * If NAME.EXT is on your path then it will be edited, otherwise
          the editor will be started with `HOME/name.ext' as the
          filename.  If `name.ext' is not modifiable, it will be copied
          to `HOME' before editing.

          *WARNING!* You may need to clear name before the new
          definition is available.  If you are editing a .cc file, you
          will need to mkoctfile `name.cc' before the definition will
          be available.

     If `edit' is called with FIELD and VALUE variables, the value of
     the control field FIELD will be VALUE.  If an output argument is
     requested and the first argument is `get' then `edit' will return
     the value of the control field FIELD.  If the control field does
     not exist, edit will return a structure containing all fields and
     values.  Thus, `edit get all' returns a complete control structure.
     The following control fields are used:

    `editor'
          This is the editor to use to modify the functions.  By
          default it uses Octave's `EDITOR' built-in function, which
          comes from `getenv("EDITOR")' and defaults to `emacs'.  Use
          `%s' In place of the function name.  For example,
         `[EDITOR, " %s"]'
               Use the editor which Octave uses for `bug_report'.

         `"xedit %s &"'
               pop up simple X11 editor in a separate window

         `"gnudoit -q \"(find-file \\\"%s\\\")\""'
               Send it to current Emacs; must have `(gnuserv-start)' in
               `.emacs'.

          See also field 'mode', which controls how the editor is run
          by Octave.

          On Cygwin, you will need to convert the Cygwin path to a
          Windows path if you are using a native Windows editor.  For
          example
               '"C:/Program Files/Good Editor/Editor.exe" "$(cygpath -wa %s)"'

    `home'
          This is the location of user local m-files.  Be be sure it is
          in your path.  The default is `~/octave'.

    `author'
          This is the name to put after the "## Author:" field of new
          functions.  By default it guesses from the `gecos' field of
          password database.

    `email'
          This is the e-mail address to list after the name in the
          author field.  By default it guesses `<$LOGNAME@$HOSTNAME>',
          and if `$HOSTNAME' is not defined it uses `uname -n'.  You
          probably want to override this.  Be sure to use `<user@host>'
          as your format.

    `license'

         `gpl'
               GNU General Public License (default).

         `bsd'
               BSD-style license without advertising clause.

         `pd'
               Public domain.

         `"text"'
               Your own default copyright and license.

          Unless you specify `pd', edit will prepend the copyright
          statement with "Copyright (C) yyyy Function Author".

    `mode'
          This value determines whether the editor should be started in
          async mode (editor is started in the background and Octave
          continues) or sync mode (Octave waits until the editor
          exits).  Set it to "async" to start the editor in async mode.
          The default is "sync" (see also "system").

    `editinplace'
          Determines whether files should be edited in place, without
          regard to whether they are modifiable or not.  The default is
          `false'.
}

#
edit_history
{
`edit_history' is a built-in function

 -- Command: edit_history [FIRST] [LAST]
     If invoked with no arguments, `edit_history' allows you to edit the
     history list using the editor named by the variable `EDITOR'.  The
     commands to be edited are first copied to a temporary file.  When
     you exit the editor, Octave executes the commands that remain in
     the file.  It is often more convenient to use `edit_history' to
     define functions rather than attempting to enter them directly on
     the command line.  By default, the block of commands is executed
     as soon as you exit the editor.  To avoid executing any commands,
     simply delete all the lines from the buffer before exiting the
     editor.

     The `edit_history' command takes two optional arguments specifying
     the history numbers of first and last commands to edit.  For
     example, the command

          edit_history 13

     extracts all the commands from the 13th through the last in the
     history list.  The command

          edit_history 13 169

     only extracts commands 13 through 169.  Specifying a larger number
     for the first command than the last command reverses the list of
     commands before placing them in the buffer to be edited.  If both
     arguments are omitted, the previous command in the history list is
     used.

     See also: run_history
}

#
eig
{
`eig' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/eig.oct

 -- Loadable Function: LAMBDA = eig (A)
 -- Loadable Function: LAMBDA = eig (A, B)
 -- Loadable Function: [V, LAMBDA] = eig (A)
 -- Loadable Function: [V, LAMBDA] = eig (A, B)
     The eigenvalues (and eigenvectors) of a matrix are computed in a
     several step process which begins with a Hessenberg decomposition,
     followed by a Schur decomposition, from which the eigenvalues are
     apparent.  The eigenvectors, when desired, are computed by further
     manipulations of the Schur decomposition.

     The eigenvalues returned by `eig' are not ordered.

     See also: eigs
}

#
eigs
{
`eigs' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/eigs.oct

 -- Loadable Function: D = eigs (A)
 -- Loadable Function: D = eigs (A, K)
 -- Loadable Function: D = eigs (A, K, SIGMA)
 -- Loadable Function: D = eigs (A, K, SIGMA,OPTS)
 -- Loadable Function: D = eigs (A, B)
 -- Loadable Function: D = eigs (A, B, K)
 -- Loadable Function: D = eigs (A, B, K, SIGMA)
 -- Loadable Function: D = eigs (A, B, K, SIGMA, OPTS)
 -- Loadable Function: D = eigs (AF, N)
 -- Loadable Function: D = eigs (AF, N, B)
 -- Loadable Function: D = eigs (AF, N, K)
 -- Loadable Function: D = eigs (AF, N, B, K)
 -- Loadable Function: D = eigs (AF, N, K, SIGMA)
 -- Loadable Function: D = eigs (AF, N, B, K, SIGMA)
 -- Loadable Function: D = eigs (AF, N, K, SIGMA, OPTS)
 -- Loadable Function: D = eigs (AF, N, B, K, SIGMA, OPTS)
 -- Loadable Function: [V, D] = eigs (A, ...)
 -- Loadable Function: [V, D] = eigs (AF, N, ...)
 -- Loadable Function: [V, D, FLAG] = eigs (A, ...)
 -- Loadable Function: [V, D, FLAG] = eigs (AF, N, ...)
     Calculate a limited number of eigenvalues and eigenvectors of A,
     based on a selection criteria.  The number eigenvalues and
     eigenvectors to calculate is given by K whose default value is 6.

     By default `eigs' solve the equation `A * v = lambda * v' , where
     `lambda' is a scalar representing one of the eigenvalues, and `v'
     is the corresponding eigenvector.  If given the positive definite
     matrix B then `eigs' solves the general eigenvalue equation `A * v
     = lambda * B * v' .

     The argument SIGMA determines which eigenvalues are returned.
     SIGMA can be either a scalar or a string.  When SIGMA is a scalar,
     the K eigenvalues closest to SIGMA are returned.  If SIGMA is a
     string, it must have one of the values

    'lm'
          Largest magnitude (default).

    'sm'
          Smallest magnitude.

    'la'
          Largest Algebraic (valid only for real symmetric problems).

    'sa'
          Smallest Algebraic (valid only for real symmetric problems).

    'be'
          Both ends, with one more from the high-end if K is odd (valid
          only for real symmetric problems).

    'lr'
          Largest real part (valid only for complex or unsymmetric
          problems).

    'sr'
          Smallest real part (valid only for complex or unsymmetric
          problems).

    'li'
          Largest imaginary part (valid only for complex or unsymmetric
          problems).

    'si'
          Smallest imaginary part (valid only for complex or
          unsymmetric problems).

     If OPTS is given, it is a structure defining some of the options
     that `eigs' should use.  The fields of the structure OPTS are

    `issym'
          If AF is given, then flags whether the function AF defines a
          symmetric problem.  It is ignored if A is given.  The default
          is false.

    `isreal'
          If AF is given, then flags whether the function AF defines a
          real problem.  It is ignored if A is given.  The default is
          true.

    `tol'
          Defines the required convergence tolerance, given as `tol *
          norm (A)'.  The default is `eps'.

    `maxit'
          The maximum number of iterations.  The default is 300.

    `p'
          The number of Lanzcos basis vectors to use.  More vectors
          will result in faster convergence, but a larger amount of
          memory.  The optimal value of 'p' is problem dependent and
          should be in the range K to N.  The default value is `2 * K'.

    `v0'
          The starting vector for the computation.  The default is to
          have ARPACK randomly generate a starting vector.

    `disp'
          The level of diagnostic printout.  If `disp' is 0 then there
          is no printout.  The default value is 1.

    `cholB'
          Flag if `chol (B)' is passed rather than B.  The default is
          false.

    `permB'
          The permutation vector of the Cholesky factorization of B if
          `cholB' is true.  That is `chol ( B (permB, permB))'.  The
          default is `1:N'.


     It is also possible to represent A by a function denoted AF.  AF
     must be followed by a scalar argument N defining the length of the
     vector argument accepted by AF.  AF can be passed either as an
     inline function, function handle or as a string.  In the case where
     AF is passed as a string, the name of the string defines the
     function to use.

     AF is a function of the form `function y = af (x), y = ...;
     endfunction', where the required return value of AF is determined
     by the value of SIGMA, and are

    `A * x'
          If SIGMA is not given or is a string other than 'sm'.

    `A \ x'
          If SIGMA is 'sm'.

    `(A - sigma * I) \ x'
          for standard eigenvalue problem, where `I' is the identity
          matrix of the same size as `A'.  If SIGMA is zero, this
          reduces the `A \ x'.

    `(A - sigma * B) \ x'
          for the general eigenvalue problem.

     The return arguments of `eigs' depends on the number of return
     arguments.  With a single return argument, a vector D of length K
     is returned, represent the K eigenvalues that have been found.
     With two return arguments, V is a N-by-K matrix whose columns are
     the K eigenvectors corresponding to the returned eigenvalues.  The
     eigenvalues themselves are then returned in D in the form of a
     N-by-K matrix, where the elements on the diagonal are the
     eigenvalues.

     Given a third return argument FLAG, `eigs' also returns the status
     of the convergence.  If FLAG is 0, then all eigenvalues have
     converged, otherwise not.

     This function is based on the ARPACK package, written by R Lehoucq,
     K Maschhoff, D Sorensen and C Yang.  For more information see
     `http://www.caam.rice.edu/software/ARPACK/'.


   See also: eig, svds
}

#
ellipsoid
{
`ellipsoid' is a function from the file /usr/share/octave/3.2.3/m/plot/ellipsoid.m

 -- Function File: [X, Y, Z] = ellipsoid (XC,YC, ZC, XR, YR, ZR, N)
 -- Function File:  ellipsoid (H, ...)
     Generate three matrices in `meshgrid' format that define an
     ellipsoid.  Called with no return arguments, `ellipsoid' calls
     directly `surf (X, Y, Z)'.  If an axes handle is passed as the
     first argument, the surface is plotted to this set of axes.

     See also: sphere
}

#
else
{

 -- Keyword: else
     Alternate action for an if block.  See `if' for an example.

     See also: if
}

#
elseif
{

 -- Keyword: elseif (CONDITION)
     Alternate conditional test for an if block.  See `if' for an
     example.

     See also: if
}

#
empirical_cdf
{
`empirical_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/empirical_cdf.m

 -- Function File:  empirical_cdf (X, DATA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the empirical distribution obtained from
     the univariate sample DATA.
}

#
empirical_inv
{
`empirical_inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/empirical_inv.m

 -- Function File:  empirical_inv (X, DATA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the empirical distribution obtained from the
     univariate sample DATA.
}

#
empirical_pdf
{
`empirical_pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/empirical_pdf.m

 -- Function File:  empirical_pdf (X, DATA)
     For each element of X, compute the probability density function
     (PDF) at X of the empirical distribution obtained from the
     univariate sample DATA.
}

#
empirical_rnd
{
`empirical_rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/empirical_rnd.m

 -- Function File:  empirical_rnd (N, DATA)
 -- Function File:  empirical_rnd (DATA, R, C)
 -- Function File:  empirical_rnd (DATA, SZ)
     Generate a bootstrap sample of size N from the empirical
     distribution obtained from the univariate sample DATA.

     If R and C are given create a matrix with R rows and C columns.
     Or if SZ is a vector, create a matrix of size SZ.
}

#
end
{

 -- Keyword: end
     Mark the end of any `for', `if', `do', `while', or `function'
     block.

     See also: for, if, do, while, function
}

#
end_try_catch
{

 -- Keyword: end_try_catch
     Mark the end of an `try-catch' block.

     See also: try, catch
}

#
end_unwind_protect
{

 -- Keyword: end_unwind_protect
     Mark the end of an unwind_protect block.

     See also: unwind_protect
}

#
endfor
{

 -- Keyword: endfor
     Mark the end of a for loop.  See `for' for an example.

     See also: for
}

#
endfunction
{

 -- Keyword: endfunction
     Mark the end of a function.

     See also: function
}

#
endgrent
{
`endgrent' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getgrent.oct

 -- Loadable Function:  endgrent ()
     Close the group database.
}

#
endif
{

 -- Keyword: endif
     Mark the end of an if block.  See `if' for an example.

     See also: if
}

#
endpwent
{
`endpwent' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getpwent.oct

 -- Loadable Function:  endpwent ()
     Close the password database.
}

#
endswitch
{

 -- Keyword: endswitch
     Mark the end of a switch block.  See `switch' for an example.

     See also: switch
}

#
endwhile
{

 -- Keyword: endwhile
     Mark the end of a while loop.  See `while' for an example.

     See also: do, while
}

#
eomday
{
`eomday' is a function from the file /usr/share/octave/3.2.3/m/time/eomday.m

 -- Function File: E = eomday (Y, M)
     Return the last day of the month M for the year Y.

     See also: datenum, datevec, weekday
}

#
eps
{
`eps' is a built-in function

 -- Built-in Function:  eps
 -- Built-in Function:  eps (X)
 -- Built-in Function:  eps (N, M)
 -- Built-in Function:  eps (N, M, K, ...)
 -- Built-in Function:  eps (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all eps, the machine precision.  More precisely, `eps' is the
     relative spacing between any two adjacent numbers in the machine's
     floating point system.  This number is obviously system dependent.
     On machines that support IEEE floating point arithmetic, `eps' is
     approximately 2.2204e-16 for double precision and 1.1921e-07 for
     single precision.

     When called with no arguments, return a scalar with the value
     `eps(1.0)'.  Given a single argument X, return the distance
     between X and the next largest value.  When called with more than
     one argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".
}

#
eq
{
`eq' is a built-in function

 -- Built-in Function:  eq (X, Y)
     This function is equivalent to `x == y'.
}

#
erf
{
`erf' is a built-in function

 -- Mapping Function:  erf (Z)
     Computes the error function,

                                  z
                                 /
          erf (z) = (2/sqrt (pi)) | e^(-t^2) dt
                                 /
                              t=0

     See also: erfc, erfinv
}

#
erfc
{
`erfc' is a built-in function

 -- Mapping Function:  erfc (Z)
     Computes the complementary error function, `1 - erf (Z)'.

     See also: erf, erfinv
}

#
erfinv
{
`erfinv' is a function from the file /usr/share/octave/3.2.3/m/specfun/erfinv.m

 -- Mapping Function:  erfinv (Z)
     Computes the inverse of the error function.

     See also: erf, erfc
}

#
errno
{
`errno' is a built-in function

 -- Built-in Function: ERR = errno ()
 -- Built-in Function: ERR = errno (VAL)
 -- Built-in Function: ERR = errno (NAME)
     Return the current value of the system-dependent variable errno,
     set its value to VAL and return the previous value, or return the
     named error code given NAME as a character string, or -1 if NAME
     is not found.
}

#
errno_list
{
`errno_list' is a built-in function

 -- Built-in Function:  errno_list ()
     Return a structure containing the system-dependent errno values.
}

#
error
{
`error' is a built-in function

 -- Built-in Function:  error (TEMPLATE, ...)
 -- Built-in Function:  error (ID, TEMPLATE, ...)
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the `printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the `stderr' stream.  The message is prefixed by the
     character string `error: '.

     Calling `error' also sets Octave's internal error state such that
     control will return to the top level without evaluating any more
     commands.  This is useful for aborting from functions or scripts.

     If the error message does not end with a new line character,
     Octave will print a traceback of all the function calls leading to
     the error.  For example, given the following function definitions:

          function f () g (); end
          function g () h (); end
          function h () nargin == 1 || error ("nargin != 1"); end

     calling the function `f' will result in a list of messages that
     can help you to quickly locate the exact location of the error:

          f ()
          error: nargin != 1
          error: called from:
          error:   error at line -1, column -1
          error:   h at line 1, column 27
          error:   g at line 1, column 15
          error:   f at line 1, column 15

     If the error message ends in a new line character, Octave will
     print the message but will not display any traceback messages as
     it returns control to the top level.  For example, modifying the
     error message in the previous example to end in a new line causes
     Octave to only print a single message:

          function h () nargin == 1 || error ("nargin != 1\n"); end
          f ()
          error: nargin != 1
}

#
error_text
{
`error_text' is a built-in function

 -- Built-in Function: [MSG, MSGID] = lasterr (MSG, MSGID)
     Without any arguments, return the last error message.  With one
     argument, set the last error message to MSG.  With two arguments,
     also set the last message identifier.
}

#
errorbar
{
`errorbar' is a function from the file /usr/share/octave/3.2.3/m/plot/errorbar.m

 -- Function File:  errorbar (ARGS)
     This function produces two-dimensional plots with errorbars.  Many
     different combinations of arguments are possible.  The simplest
     form is

          errorbar (Y, EY)

     where the first argument is taken as the set of Y coordinates and
     the second argument EY is taken as the errors of the Y values.  X
     coordinates are taken to be the indices of the elements, starting
     with 1.

     If more than two arguments are given, they are interpreted as

          errorbar (X, Y, ..., FMT, ...)

     where after X and Y there can be up to four error parameters such
     as EY, EX, LY, UY, etc., depending on the plot type.  Any number
     of argument sets may appear, as long as they are separated with a
     format string FMT.

     If Y is a matrix, X and error parameters must also be matrices
     having same dimensions.  The columns of Y are plotted versus the
     corresponding columns of X and errorbars are drawn from the
     corresponding columns of error parameters.

     If FMT is missing, yerrorbars ("~") plot style is assumed.

     If the FMT argument is supplied, it is interpreted as in normal
     plots.  In addition the following plot styles are supported by
     errorbar:

    `~'
          Set yerrorbars plot style (default).

    `>'
          Set xerrorbars plot style.

    `~>'
          Set xyerrorbars plot style.

    `#'
          Set boxes plot style.

    `#~'
          Set boxerrorbars plot style.

    `#~>'
          Set boxxyerrorbars plot style.

     Examples:

          errorbar (X, Y, EX, ">")

     produces an xerrorbar plot of Y versus X with X errorbars drawn
     from X-EX to X+EX.

          errorbar (X, Y1, EY, "~",
                    X, Y2, LY, UY)

     produces yerrorbar plots with Y1 and Y2 versus X.  Errorbars for
     Y1 are drawn from Y1-EY to Y1+EY, errorbars for Y2 from Y2-LY to
     Y2+UY.

          errorbar (X, Y, LX, UX,
                    LY, UY, "~>")

     produces an xyerrorbar plot of Y versus X in which X errorbars are
     drawn from X-LX to X+UX and Y errorbars from Y-LY to Y+UY.

     See also: semilogxerr, semilogyerr, loglogerr
}

#
etime
{
`etime' is a function from the file /usr/share/octave/3.2.3/m/time/etime.m

 -- Function File:  etime (T1, T2)
     Return the difference (in seconds) between two time values
     returned from `clock'.  For example:

          t0 = clock ();
          # many computations later...
          elapsed_time = etime (clock (), t0);

     will set the variable `elapsed_time' to the number of seconds since
     the variable `t0' was set.

     See also: tic, toc, clock, cputime
}

#
etree
{
`etree' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/colamd.oct

 -- Loadable Function: P = etree (S)
 -- Loadable Function: P = etree (S, TYP)
 -- Loadable Function: [P, Q] = etree (S, TYP)
     Returns the elimination tree for the matrix S.  By default S is
     assumed to be symmetric and the symmetric elimination tree is
     returned.  The argument TYP controls whether a symmetric or column
     elimination tree is returned.  Valid values of TYP are 'sym' or
     'col', for symmetric or column elimination tree respectively

     Called with a second argument, "etree" also returns the postorder
     permutations on the tree.
}

#
etreeplot
{
`etreeplot' is a function from the file /usr/share/octave/3.2.3/m/sparse/etreeplot.m

 -- Function File:  etreeplot (TREE)
 -- Function File:  etreeplot (TREE, NODE_STYLE, EDGE_STYLE)
     Plot the elimination tree of the matrix S or `S+S''  if S in
     non-symmetric.  The optional parameters LINE_STYLE and EDGE_STYLE
     define the output style.

     See also: treeplot, gplot
}

#
eval
{
`eval' is a built-in function

 -- Built-in Function:  eval (TRY, CATCH)
     Parse the string TRY and evaluate it as if it were an Octave
     program.  If that fails, evaluate the optional string CATCH.  The
     string TRY is evaluated in the current context, so any results
     remain available after `eval' returns.

     The following example makes the variable A with the approximate
     value 3.1416 available.

          eval("a = acos(-1);");

     If an error occurs during the evaluation of TRY the CATCH string
     is evaluated, as the following example shows:

          eval ('error ("This is a bad example");',
               'printf ("This error occurred:\n%s\n", lasterr ());');
              -| This error occurred:
                 This is a bad example
}

#
evalin
{
`evalin' is a built-in function

 -- Built-in Function:  evalin (CONTEXT, TRY, CATCH)
     Like `eval', except that the expressions are evaluated in the
     context CONTEXT, which may be either `"caller"' or `"base"'.
}

#
example
{
`example' is a function from the file /usr/share/octave/3.2.3/m/testfun/example.m

 -- Function File:  example ('NAME',N)
 -- Function File: [X, IDX] = example ('NAME',N)
     Display the code for example N associated with the function
     'NAME', but do not run it.  If N is not given, all examples are
     displayed.

     Called with output arguments, the examples are returned in the
     form of a string X, with IDX indicating the ending position of the
     various examples.

     See `demo' for a complete explanation.

     See also: demo, test
}

#
exec
{
`exec' is a built-in function

 -- Built-in Function: [ERR, MSG] = exec (FILE, ARGS)
     Replace current process with a new process.  Calling `exec' without
     first calling `fork' will terminate your current Octave process and
     replace it with the program named by FILE.  For example,

          exec ("ls" "-l")

     will run `ls' and return you to your shell prompt.

     If successful, `exec' does not return.  If `exec' does return, ERR
     will be nonzero, and MSG will contain a system-dependent error
     message.
}

#
exist
{
`exist' is a built-in function

 -- Built-in Function:  exist (NAME, TYPE)
     Return 1 if the name exists as a variable, 2 if the name is an
     absolute file name, an ordinary file in Octave's `path', or (after
     appending `.m') a function file in Octave's `path', 3 if the name
     is a `.oct' or `.mex' file in Octave's `path', 5 if the name is a
     built-in function, 7 if the name is a directory, or 103 if the
     name is a function not associated with a file (entered on the
     command line).

     Otherwise, return 0.

     This function also returns 2 if a regular file called NAME exists
     in Octave's search path.  If you want information about other
     types of files, you should use some combination of the functions
     `file_in_path' and `stat' instead.

     If the optional argument TYPE is supplied, check only for symbols
     of the specified type.  Valid types are

    `"var"'
          Check only for variables.

    `"builtin"'
          Check only for built-in functions.

    `"file"'
          Check only for files.

    `"dir"'
          Check only for directories.
}

#
exit
{
`exit' is a built-in function

 -- Built-in Function:  exit (STATUS)
 -- Built-in Function:  quit (STATUS)
     Exit the current Octave session.  If the optional integer value
     STATUS is supplied, pass that value to the operating system as the
     Octave's exit status.  The default value is zero.
}

#
exp
{
`exp' is a built-in function

 -- Mapping Function:  exp (X)
     Compute `e^x' for each element of X.  To compute the matrix
     exponential, see *note Linear Algebra::.

     See also: log
}

#
expcdf
{
`expcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/expcdf.m

 -- Function File:  expcdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the exponential distribution with mean
     LAMBDA.

     The arguments can be of common size or scalar.
}

#
expinv
{
`expinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/expinv.m

 -- Function File:  expinv (X, LAMBDA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the exponential distribution with mean LAMBDA.
}

#
expm
{
`expm' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/expm.m

 -- Function File:  expm (A)
     Return the exponential of a matrix, defined as the infinite Taylor
     series

          expm(a) = I + a + a^2/2! + a^3/3! + ...

     The Taylor series is _not_ the way to compute the matrix
     exponential; see Moler and Van Loan, `Nineteen Dubious Ways to
     Compute the Exponential of a Matrix', SIAM Review, 1978.  This
     routine uses Ward's diagonal Pade' approximation method with three
     step preconditioning (SIAM Journal on Numerical Analysis, 1977).
     Diagonal Pade'  approximations are rational polynomials of matrices

               -1
          D (a)   N (a)

     whose Taylor series matches the first `2q+1' terms of the Taylor
     series above; direct evaluation of the Taylor series (with the
     same preconditioning steps) may be desirable in lieu of the Pade'
     approximation when `Dq(a)' is ill-conditioned.
}

#
expm1
{
`expm1' is a built-in function

 -- Mapping Function:  expm1 (X)
     Compute `exp (X) - 1' accurately in the neighborhood of zero.

     See also: exp
}

#
exponential_cdf
{
`exponential_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/exponential_cdf.m

 -- Function File:  exponential_cdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the exponential distribution with parameter
     LAMBDA.

     The arguments can be of common size or scalar.
}

#
exponential_inv
{
`exponential_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/exponential_inv.m

 -- Function File:  exponential_inv (X, LAMBDA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the exponential distribution with parameter LAMBDA.
}

#
exponential_pdf
{
`exponential_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/exponential_pdf.m

 -- Function File:  exponential_pdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) of the exponential distribution with parameter LAMBDA.
}

#
exponential_rnd
{
`exponential_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/exponential_rnd.m

 -- Function File:  exponential_rnd (LAMBDA, R, C)
 -- Function File:  exponential_rnd (LAMBDA, SZ)
     Return an R by C matrix of random samples from the exponential
     distribution with parameter LAMBDA, which must be a scalar or of
     size R by C.  Or if SZ is a vector, create a matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the size
     of LAMBDA.
}

#
exppdf
{
`exppdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/exppdf.m

 -- Function File:  exppdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) of the exponential distribution with mean LAMBDA.
}

#
exprnd
{
`exprnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/exprnd.m

 -- Function File:  exprnd (LAMBDA, R, C)
 -- Function File:  exprnd (LAMBDA, SZ)
     Return an R by C matrix of random samples from the exponential
     distribution with mean LAMBDA, which must be a scalar or of size R
     by C.  Or if SZ is a vector, create a matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the size
     of LAMBDA.
}

#
eye
{
`eye' is a built-in function

 -- Built-in Function:  eye (X)
 -- Built-in Function:  eye (N, M)
 -- Built-in Function:  eye (..., CLASS)
     Return an identity matrix.  If invoked with a single scalar
     argument, `eye' returns a square matrix with the dimension
     specified.  If you supply two scalar arguments, `eye' takes them
     to be the number of rows and columns.  If given a vector with two
     elements, `eye' uses the values of the elements as the number of
     rows and columns, respectively.  For example,

          eye (3)
              =>  1  0  0
                  0  1  0
                  0  0  1

     The following expressions all produce the same result:

          eye (2)
          ==
          eye (2, 2)
          ==
          eye (size ([1, 2; 3, 4])

     The optional argument CLASS, allows `eye' to return an array of
     the specified type, like

          val = zeros (n,m, "uint8")

     Calling `eye' with no arguments is equivalent to calling it with
     an argument of 1.  This odd definition is for compatibility with
     MATLAB.
}

#
ezcontour
{
`ezcontour' is a function from the file /usr/share/octave/3.2.3/m/plot/ezcontour.m

 -- Function File:  ezcontour (F)
 -- Function File:  ezcontour (..., DOM)
 -- Function File:  ezcontour (..., N)
 -- Function File:  ezcontour (H, ...)
 -- Function File: H = ezcontour (...)
     Plots the contour lines of a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain `-2*pi < X <
     2*pi' and `-2*pi < Y < 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontour (f, [-3, 3]);

     See also: ezplot, ezcontourf, ezsurfc, ezmeshc
}

#
ezcontourf
{
`ezcontourf' is a function from the file /usr/share/octave/3.2.3/m/plot/ezcontourf.m

 -- Function File:  ezcontourf (F)
 -- Function File:  ezcontourf (..., DOM)
 -- Function File:  ezcontourf (..., N)
 -- Function File:  ezcontourf (H, ...)
 -- Function File: H = ezcontourf (...)
     Plots the filled contour lines of a function.  F is a string,
     inline function or function handle with two arguments defining the
     function.  By default the plot is over the domain `-2*pi < X <
     2*pi' and `-2*pi < Y < 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
          ezcontourf (f, [-3, 3]);

     See also: ezplot, ezcontour, ezsurfc, ezmeshc
}

#
ezmesh
{
`ezmesh' is a function from the file /usr/share/octave/3.2.3/m/plot/ezmesh.m

 -- Function File:  ezmesh (F)
 -- Function File:  ezmesh (FX, FY, FZ)
 -- Function File:  ezmesh (..., DOM)
 -- Function File:  ezmesh (..., N)
 -- Function File:  ezmesh (..., 'circ')
 -- Function File:  ezmesh (H, ...)
 -- Function File: H = ezmesh (...)
     Plots the mesh defined by a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain `-2*pi < X <
     2*pi' and `-2*pi < Y < 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument 'circ' is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
          ezmesh (f, [-3, 3]);

     An example of a parametrically defined function is

          fx = @(s,t) cos (s) .* cos(t);
          fy = @(s,t) sin (s) .* cos(t);
          fz = @(s,t) sin(t);
          ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: ezplot, ezsurf, ezsurfc, ezmeshc
}

#
ezmeshc
{
`ezmeshc' is a function from the file /usr/share/octave/3.2.3/m/plot/ezmeshc.m

 -- Function File:  ezmeshc (F)
 -- Function File:  ezmeshc (FX, FY, FZ)
 -- Function File:  ezmeshc (..., DOM)
 -- Function File:  ezmeshc (..., N)
 -- Function File:  ezmeshc (..., 'circ')
 -- Function File:  ezmeshc (H, ...)
 -- Function File: H = ezmeshc (...)
     Plots the mesh and contour lines defined by a function.  F is a
     string, inline function or function handle with two arguments
     defining the function.  By default the plot is over the domain
     `-2*pi < X < 2*pi' and `-2*pi < Y < 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument 'circ' is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
          ezmeshc (f, [-3, 3]);

     See also: ezplot, ezsurfc, ezsurf, ezmesh
}

#
ezplot
{
`ezplot' is a function from the file /usr/share/octave/3.2.3/m/plot/ezplot.m

 -- Function File:  ezplot (F)
 -- Function File:  ezplot (FX, FY)
 -- Function File:  ezplot (..., DOM)
 -- Function File:  ezplot (..., N)
 -- Function File:  ezplot (H, ...)
 -- Function File: H = ezplot (...)
     Plots in two-dimensions the curve defined by F.  The function F
     may be a string, inline function or function handle and can have
     either one or two variables.  If F has one variable, then the
     function is plotted over the domain `-2*pi < X < 2*pi' with 500
     points.

     If F has two variables then `F(X,Y) = 0' is calculated over the
     meshed domain `-2*pi < X | Y < 2*pi' with 60 by 60 in the mesh.
     For example

          ezplot (@(X, Y) X .^ 2 - Y .^ 2 - 1)

     If two functions are passed as strings, inline functions or
     function handles, then the parametric function

          X = FX (T)
          Y = FY (T)

     is plotted over the domain `-2*pi < T < 2*pi' with 500 points.

     If DOM is a two element vector, it represents the minimum and
     maximum value of X, Y and T.  If it is a four element vector, then
     the minimum and maximum values of X and T are determined by the
     first two elements and the minimum and maximum of Y by the second
     pair of elements.

     N is a scalar defining the number of points to use in plotting the
     function.

     The optional return value H provides a list of handles to the the
     line objects plotted.

     See also: plot, ezplot3
}

#
ezplot3
{
`ezplot3' is a function from the file /usr/share/octave/3.2.3/m/plot/ezplot3.m

 -- Function File:  ezplot3 (FX, FY, FZ)
 -- Function File:  ezplot3 (..., DOM)
 -- Function File:  ezplot3 (..., N)
 -- Function File:  ezplot3 (H, ...)
 -- Function File: H = ezplot3 (...)
     Plots in three-dimensions the curve defined parametrically.  FX,
     FY, and FZ are strings, inline functions or function handles with
     one arguments defining the function.  By default the plot is over
     the domain `-2*pi < X < 2*pi' with 60 points.

     If DOM is a two element vector, it represents the minimum and
     maximum value of T.  N is a scalar defining the number of points
     to use.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          fx = @(t) cos (t);
          fy = @(t) sin (t);
          fz = @(t) t;
          ezplot3 (fx, fy, fz, [0, 10*pi], 100);

     See also: plot3, ezplot, ezsurf, ezmesh
}

#
ezpolar
{
`ezpolar' is a function from the file /usr/share/octave/3.2.3/m/plot/ezpolar.m

 -- Function File:  ezpolar (F)
 -- Function File:  ezpolar (..., DOM)
 -- Function File:  ezpolar (..., N)
 -- Function File:  ezpolar (H, ...)
 -- Function File: H = ezpolar (...)
     Plots in polar plot defined by a function.  The function F is
     either a string, inline function or function handle with one
     arguments defining the function.  By default the plot is over the
     domain `0 < X < 2*pi' with 60 points.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both T.  N is a scalar defining the number of
     points to use.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          ezpolar (@(t) 1 + sin (t));

     See also: polar, ezplot, ezsurf, ezmesh
}

#
ezsurf
{
`ezsurf' is a function from the file /usr/share/octave/3.2.3/m/plot/ezsurf.m

 -- Function File:  ezsurf (F)
 -- Function File:  ezsurf (FX, FY, FZ)
 -- Function File:  ezsurf (..., DOM)
 -- Function File:  ezsurf (..., N)
 -- Function File:  ezsurf (..., 'circ')
 -- Function File:  ezsurf (H, ...)
 -- Function File: H = ezsurf (...)
     Plots the surface defined by a function.  F is a string, inline
     function or function handle with two arguments defining the
     function.  By default the plot is over the domain `-2*pi < X <
     2*pi' and `-2*pi < Y < 2*pi' with 60 points in each dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument 'circ' is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurf (f, [-3, 3]);

     An example of a parametrically defined function is

          fx = @(s,t) cos (s) .* cos(t);
          fy = @(s,t) sin (s) .* cos(t);
          fz = @(s,t) sin(t);
          ezsurf (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);

     See also: ezplot, ezmesh, ezsurfc, ezmeshc
}

#
ezsurfc
{
`ezsurfc' is a function from the file /usr/share/octave/3.2.3/m/plot/ezsurfc.m

 -- Function File:  ezsurfc (F)
 -- Function File:  ezsurfc (FX, FY, FZ)
 -- Function File:  ezsurfc (..., DOM)
 -- Function File:  ezsurfc (..., N)
 -- Function File:  ezsurfc (..., 'circ')
 -- Function File:  ezsurfc (H, ...)
 -- Function File: H = ezsurfc (...)
     Plots the surface and contour lines defined by a function.  F is a
     string, inline function or function handle with two arguments
     defining the function.  By default the plot is over the domain
     `-2*pi < X < 2*pi' and `-2*pi < Y < 2*pi' with 60 points in each
     dimension.

     If DOM is a two element vector, it represents the minimum and
     maximum value of both X and Y.  If DOM is a four element vector,
     then the minimum and maximum value of X and Y are specify
     separately.

     N is a scalar defining the number of points to use in each
     dimension.

     If three functions are passed, then plot the parametrically defined
     function `[FX (S, T), FY (S, T), FZ (S, T)]'.

     If the argument 'circ' is given, then the function is plotted over
     a disk centered on the middle of the domain DOM.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
          ezsurfc (f, [-3, 3]);

     See also: ezplot, ezmeshc, ezsurf, ezmesh
}

#
f_cdf
{
`f_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/f_cdf.m

 -- Function File:  f_cdf (X, M, N)
     For each element of X, compute the CDF at X of the F distribution
     with M and N degrees of freedom, i.e., PROB (F (M, N) <= X).
}

#
f_inv
{
`f_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/f_inv.m

 -- Function File:  f_inv (X, M, N)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the F distribution with parameters M and N.
}

#
f_pdf
{
`f_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/f_pdf.m

 -- Function File:  f_pdf (X, M, N)
     For each element of X, compute the probability density function
     (PDF) at X of the F distribution with M and N degrees of freedom.
}

#
f_rnd
{
`f_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/f_rnd.m

 -- Function File:  f_rnd (M, N, R, C)
 -- Function File:  f_rnd (M, N, SZ)
     Return an R by C matrix of random samples from the F distribution
     with M and N degrees of freedom.  Both M and N must be scalar or
     of size R by C.  If SZ is a vector the random samples are in a
     matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of M and N.
}

#
f_test_regression
{
`f_test_regression' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/f_test_regression.m

 -- Function File: [PVAL, F, DF_NUM, DF_DEN] = f_test_regression (Y, X,
          RR, R)
     Perform an F test for the null hypothesis rr * b = r in a classical
     normal regression model y = X * b + e.

     Under the null, the test statistic F follows an F distribution
     with DF_NUM and DF_DEN degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is
     returned in PVAL.

     If not given explicitly, R = 0.

     If no output argument is given, the p-value is displayed.
}

#
factor
{
`factor' is a function from the file /usr/share/octave/3.2.3/m/specfun/factor.m

 -- Function File: P = factor (Q)
 -- Function File: [P, N] = factor (Q)
     Return prime factorization of Q.  That is, `prod (P) == Q' and
     every element of P is a prime number.  If `Q == 1', returns 1.

     With two output arguments, return the unique primes P and their
     multiplicities.  That is, `prod (P .^ N) == Q'.

     See also: gcd, lcm
}

#
factorial
{
`factorial' is a function from the file /usr/share/octave/3.2.3/m/specfun/factorial.m

 -- Function File:  factorial (N)
     Return the factorial of N where N is a positive integer.  If N is
     a scalar, this is equivalent to `prod (1:N)'.  For vector or
     matrix arguments, return the factorial of each element in the
     array.  For non-integers see the generalized factorial function
     `gamma'.

     See also: prod, gamma
}

#
fail
{
`fail' is a function from the file /usr/share/octave/3.2.3/m/testfun/fail.m

 -- Function File:  fail (CODE,PATTERN)
 -- Function File:  fail (CODE,'warning',PATTERN)
     Return true if CODE fails with an error message matching PATTERN,
     otherwise produce an error.  Note that CODE is a string and if
     CODE runs successfully, the error produced is:

                    expected error but got none

     If the code fails with a different error, the message produced is:

                    expected <pattern>
                    but got <text of actual error>

     The angle brackets are not part of the output.

     Called with three arguments, the behavior is similar to
     `fail(CODE, PATTERN)', but produces an error if no warning is
     given during code execution or if the code fails.
}

#
false
{
`false' is a built-in function

 -- Built-in Function:  false (X)
 -- Built-in Function:  false (N, M)
 -- Built-in Function:  false (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 0.  The arguments are handled the same as the arguments
     for `eye'.
}

#
fcdf
{
`fcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/fcdf.m

 -- Function File:  fcdf (X, M, N)
     For each element of X, compute the CDF at X of the F distribution
     with M and N degrees of freedom, i.e., PROB (F (M, N) <= X).
}

#
fclear
{
`fclear' is a built-in function

 -- Built-in Function:  fclear (FID)
     Clear the stream state for the specified file.
}

#
fclose
{
`fclose' is a built-in function

 -- Built-in Function:  fclose (FID)
     Closes the specified file.  If successful, `fclose' returns 0,
     otherwise, it returns -1.

     See also: fopen, fseek, ftell
}

#
fcntl
{
`fcntl' is a built-in function

 -- Built-in Function: [ERR, MSG] = fcntl (FID, REQUEST, ARG)
     Change the properties of the open file FID.  The following values
     may be passed as REQUEST:

    `F_DUPFD'
          Return a duplicate file descriptor.

    `F_GETFD'
          Return the file descriptor flags for FID.

    `F_SETFD'
          Set the file descriptor flags for FID.

    `F_GETFL'
          Return the file status flags for FID.  The following codes
          may be returned (some of the flags may be undefined on some
          systems).

         `O_RDONLY'
               Open for reading only.

         `O_WRONLY'
               Open for writing only.

         `O_RDWR'
               Open for reading and writing.

         `O_APPEND'
               Append on each write.

         `O_CREAT'
               Create the file if it does not exist.

         `O_NONBLOCK'
               Nonblocking mode.

         `O_SYNC'
               Wait for writes to complete.

         `O_ASYNC'
               Asynchronous I/O.

    `F_SETFL'
          Set the file status flags for FID to the value specified by
          ARG.  The only flags that can be changed are `O_APPEND' and
          `O_NONBLOCK'.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.
}

#
fdisp
{
`fdisp' is a built-in function

 -- Built-in Function:  fdisp (FID, X)
     Display the value of X on the stream FID.  For example,

          fdisp (stdout, "The value of pi is:"), fdisp (stdout, pi)

              -| the value of pi is:
              -| 3.1416

     Note that the output from `fdisp' always ends with a newline.

     See also: disp
}

#
feather
{
`feather' is a function from the file /usr/share/octave/3.2.3/m/plot/feather.m

 -- Function File:  feather (U, V)
 -- Function File:  feather (Z)
 -- Function File:  feather (..., STYLE)
 -- Function File:  feather (H, ...)
 -- Function File: H = feather (...)
     Plot the `(U, V)' components of a vector field emanating from
     equidistant points on the x-axis.  If a single complex argument Z
     is given, then `U = real (Z)' and `V = imag (Z)'.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the `plot'
     command.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

          phi = [0 : 15 : 360] * pi / 180;
          feather (sin (phi), cos (phi))

     See also: plot, quiver, compass
}

#
feof
{
`feof' is a built-in function

 -- Built-in Function:  feof (FID)
     Return 1 if an end-of-file condition has been encountered for a
     given file and 0 otherwise.  Note that it will only return 1 if
     the end of the file has already been encountered, not if the next
     read operation will result in an end-of-file condition.

     See also: fread, fopen, fclose
}

#
ferror
{
`ferror' is a built-in function

 -- Built-in Function:  ferror (FID)
     Return 1 if an error condition has been encountered for a given
     file and 0 otherwise.  Note that it will only return 1 if an error
     has already been encountered, not if the next operation will
     result in an error condition.
}

#
feval
{
`feval' is a built-in function

 -- Built-in Function:  feval (NAME, ...)
     Evaluate the function named NAME.  Any arguments after the first
     are passed on to the named function.  For example,

          feval ("acos", -1)
              => 3.1416

     calls the function `acos' with the argument `-1'.

     The function `feval' is necessary in order to be able to write
     functions that call user-supplied functions, because Octave does
     not have a way to declare a pointer to a function (like C) or to
     declare a special kind of variable that can be used to hold the
     name of a function (like `EXTERNAL' in Fortran).  Instead, you
     must refer to functions by name, and use `feval' to call them.
}

#
fflush
{
`fflush' is a built-in function

 -- Built-in Function:  fflush (FID)
     Flush output to FID.  This is useful for ensuring that all pending
     output makes it to the screen before some other event occurs.  For
     example, it is always a good idea to flush the standard output
     stream before calling `input'.

     `fflush' returns 0 on success and an OS dependent error value (-1
     on unix) on error.

     See also: fopen, fclose
}

#
fft
{
`fft' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fft.oct

 -- Loadable Function:  fft (A, N, DIM)
     Compute the FFT of A using subroutines from FFTW.  The FFT is
     calculated along the first non-singleton dimension of the array.
     Thus if A is a matrix, `fft (A)' computes the FFT for each column
     of A.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of A to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the FFT is calculated, then A is resized
     and padded with zeros.  Otherwise, if N is smaller than the
     dimension along which the FFT is calculated, then A is truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the FFT is performed

     See also: ifft, fft2, fftn, fftw
}

#
fft2
{
`fft2' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fft2.oct

 -- Loadable Function:  fft2 (A, N, M)
     Compute the two-dimensional FFT of A using subroutines from FFTW.
     The optional arguments N and M may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately

     See also: ifft2, fft, fftn, fftw
}

#
fftconv
{
`fftconv' is a function from the file /usr/share/octave/3.2.3/m/signal/fftconv.m

 -- Function File:  fftconv (A, B, N)
     Return the convolution of the vectors A and B, as a vector with
     length equal to the `length (a) + length (b) - 1'.  If A and B are
     the coefficient vectors of two polynomials, the returned value is
     the coefficient vector of the product polynomial.

     The computation uses the FFT by calling the function `fftfilt'.  If
     the optional argument N is specified, an N-point FFT is used.
}

#
fftfilt
{
`fftfilt' is a function from the file /usr/share/octave/3.2.3/m/signal/fftfilt.m

 -- Function File:  fftfilt (B, X, N)
     With two arguments, `fftfilt' filters X with the FIR filter B
     using the FFT.

     Given the optional third argument, N, `fftfilt' uses the
     overlap-add method to filter X with B using an N-point FFT.

     If X is a matrix, filter each column of the matrix.
}

#
fftn
{
`fftn' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fftn.oct

 -- Loadable Function:  fftn (A, SIZE)
     Compute the N-dimensional FFT of A using subroutines from FFTW.
     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension, then the dimension is
     truncated prior to performing the FFT.  Otherwise if an element of
     SIZE is larger than the corresponding dimension A is resized and
     padded with zeros.

     See also: ifftn, fft, fft2, fftw
}

#
fftshift
{
`fftshift' is a function from the file /usr/share/octave/3.2.3/m/signal/fftshift.m

 -- Function File:  fftshift (V)
 -- Function File:  fftshift (V, DIM)
     Perform a shift of the vector V, for use with the `fft' and `ifft'
     functions, in order the move the frequency 0 to the center of the
     vector or matrix.

     If V is a vector of N elements corresponding to N time samples
     spaced of Dt each, then `fftshift (fft (V))' corresponds to
     frequencies

          f = ((1:N) - ceil(N/2)) / N / Dt

     If V is a matrix, the same holds for rows and columns.  If V is an
     array, then the same holds along each dimension.

     The optional DIM argument can be used to limit the dimension along
     which the permutation occurs.
}

#
fftw
{
`fftw' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fftw.oct

 -- Loadable Function: METHOD = fftw ('planner')
 -- Loadable Function:  fftw ('planner', METHOD)
 -- Loadable Function: WISDOM = fftw ('dwisdom')
 -- Loadable Function: WISDOM = fftw ('dwisdom', WISDOM)
     Manage FFTW wisdom data.  Wisdom data can be used to significantly
     accelerate the calculation of the FFTs but implies an initial cost
     in its calculation.  When the FFTW libraries are initialized, they
     read a system wide wisdom file (typically in `/etc/fftw/wisdom'),
     allowing wisdom to be shared between applications other than
     Octave.  Alternatively, the `fftw' function can be used to import
     wisdom.  For example

          WISDOM = fftw ('dwisdom')

     will save the existing wisdom used by Octave to the string WISDOM.
     This string can then be saved to a file and restored using the
     `save' and `load' commands respectively.  This existing wisdom can
     be reimported as follows

          fftw ('dwisdom', WISDOM)

     If WISDOM is an empty matrix, then the wisdom used is cleared.

     During the calculation of Fourier transforms further wisdom is
     generated.  The fashion in which this wisdom is generated is
     equally controlled by the `fftw' function.  There are five
     different manners in which the wisdom can be treated, these being

    'estimate'
          This specifies that no run-time measurement of the optimal
          means of calculating a particular is performed, and a simple
          heuristic is used to pick a (probably sub-optimal) plan.  The
          advantage of this method is that there is little or no
          overhead in the generation of the plan, which is appropriate
          for a Fourier transform that will be calculated once.

    'measure'
          In this case a range of algorithms to perform the transform
          is considered and the best is selected based on their
          execution time.

    'patient'
          This is like 'measure', but a wider range of algorithms is
          considered.

    'exhaustive'
          This is like 'measure', but all possible algorithms that may
          be used to treat the transform are considered.

    'hybrid'
          As run-time measurement of the algorithm can be expensive,
          this is a compromise where 'measure' is used for transforms
          up to the size of 8192 and beyond that the 'estimate' method
          is used.

     The default method is 'estimate', and the method currently being
     used can be probed with

          METHOD = fftw ('planner')

     and the method used can be set using

          fftw ('planner', METHOD)

     Note that calculated wisdom will be lost when restarting Octave.
     However, the wisdom data can be reloaded if it is saved to a file
     as described above.  Saved wisdom files should not be used on
     different platforms since they will not be efficient and the point
     of calculating the wisdom is lost.

     See also: fft, ifft, fft2, ifft2, fftn, ifftn
}

#
fgetl
{
`fgetl' is a built-in function

 -- Built-in Function:  fgetl (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, excluding the
     possible trailing newline, are returned as a string.

     If LEN is omitted, `fgetl' reads until the next newline character.

     If there are no more characters to read, `fgetl' returns -1.

     See also: fread, fscanf
}

#
fgets
{
`fgets' is a built-in function

 -- Built-in Function:  fgets (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, including the
     possible trailing newline, are returned as a string.

     If LEN is omitted, `fgets' reads until the next newline character.

     If there are no more characters to read, `fgets' returns -1.

     See also: fputs, fopen, fread, fscanf
}

#
fieldnames
{
`fieldnames' is a built-in function

 -- Built-in Function:  fieldnames (STRUCT)
     Return a cell array of strings naming the elements of the structure
     STRUCT.  It is an error to call `fieldnames' with an argument that
     is not a structure.
}

#
figure
{
`figure' is a function from the file /usr/share/octave/3.2.3/m/plot/figure.m

 -- Function File:  figure (N)
 -- Function File:  figure (N, PROPERTY, VALUE, ...)
     Set the current plot window to plot window N.  If no arguments are
     specified, the next available window number is chosen.

     Multiple property-value pairs may be specified for the figure, but
     they must appear in pairs.
}

#
file_in_loadpath
{
`file_in_loadpath' is a built-in function

 -- Built-in Function:  file_in_loadpath (FILE)
 -- Built-in Function:  file_in_loadpath (FILE, "all")
     Return the absolute name of FILE if it can be found in the list of
     directories specified by `path'.  If no file is found, return an
     empty matrix.

     If the first argument is a cell array of strings, search each
     directory of the loadpath for element of the cell array and return
     the first that matches.

     If the second optional argument `"all"' is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_path, path
}

#
file_in_path
{
`file_in_path' is a built-in function

 -- Built-in Function:  file_in_path (PATH, FILE)
 -- Built-in Function:  file_in_path (PATH, FILE, "all")
     Return the absolute name of FILE if it can be found in PATH.  The
     value of PATH should be a colon-separated list of directories in
     the format described for `path'.  If no file is found, return an
     empty matrix.  For example,

          file_in_path (EXEC_PATH, "sh")
              => "/bin/sh"

     If the second argument is a cell array of strings, search each
     directory of the path for element of the cell array and return the
     first that matches.

     If the third optional argument `"all"' is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_loadpath
}

#
fileattrib
{
`fileattrib' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/fileattrib.m

 -- Function File: [STATUS, MSG, MSGID] = fileattrib (FILE)
     Return information about FILE.

     If successful, STATUS is 1, with RESULT containing a structure
     with the following fields:

    `Name'
          Full name of FILE.

    `archive'
          True if FILE is an archive (Windows).

    `system'
          True if FILE is a system file (Windows).

    `hidden'
          True if FILE is a hidden file (Windows).

    `directory'
          True if FILE is a directory.

    `UserRead'
    `GroupRead'
    `OtherRead'
          True if the user (group; other users) has read permission for
          FILE.

    `UserWrite'
    `GroupWrite'
    `OtherWrite'
          True if the user (group; other users) has write permission for
          FILE.

    `UserExecute'
    `GroupExecute'
    `OtherExecute'
          True if the user (group; other users) has execute permission
          for FILE.
     If an attribute does not apply (i.e., archive on a Unix system)
     then the field is set to NaN.

     With no input arguments, return information about the current
     directory.

     If FILE contains globbing characters, return information about all
     the matching files.

     See also: glob
}

#
filemarker
{
`filemarker' is a built-in function

 -- Built-in Function:  filemarker ()
     Returns or sets the character used to separate filename from the
     the subfunction names contained within the file.  This can be used
     in a generic manner to interact with subfunctions.  For example

          help (["myfunc", filemarker, "mysubfunc"])

     returns the help string associated with the sub-function
     `mysubfunc' of the function `myfunc'.  Another use of `filemarker'
     is when debugging it allows easier placement of breakpoints within
     sub-functions.  For example

          dbstop (["myfunc", filemarker, "mysubfunc"])

     will set a breakpoint at the first line of the subfunction
     `mysubfunc'.
}

#
fileparts
{
`fileparts' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/fileparts.m

 -- Function File: [DIR, NAME, EXT, VER] = fileparts (FILENAME)
     Return the directory, name, extension, and version components of
     FILENAME.

     See also: fullfile
}

#
filesep
{
`filesep' is a built-in function

 -- Built-in Function:  filesep ()
 -- Built-in Function:  filesep ('all')
     Return the system-dependent character used to separate directory
     names.

     If 'all' is given, the function return all valid file separators in
     the form of a string.  The list of file separators is
     system-dependent.  It is / (forward slash) under UNIX or Mac OS X,
     / and \ (forward and backward slashes) under Windows.

     See also: pathsep, dir, ls
}

#
fill
{
`fill' is a function from the file /usr/share/octave/3.2.3/m/plot/fill.m

 -- Function File:  fill (X, Y, C)
 -- Function File:  fill (X1, Y1, C1, X2, Y2, C2)
 -- Function File:  fill (..., PROP, VAL)
 -- Function File:  fill (H, ...)
 -- Function File: H = fill (...)
     Create one or more filled patch objects, returning a patch object
     for each.
}

#
filter
{
`filter' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/filter.oct

 -- Loadable Function: y = filter (B, A, X)
 -- Loadable Function: [Y, SF] = filter (B, A, X, SI)
 -- Loadable Function: [Y, SF] = filter (B, A, X, [], DIM)
 -- Loadable Function: [Y, SF] = filter (B, A, X, SI, DIM)
     Return the solution to the following linear, time-invariant
     difference equation:

            N                   M
           SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)
           k=0                 k=0

     where N=length(a)-1 and M=length(b)-1.  over the first
     non-singleton dimension of X or over DIM if supplied.  An
     equivalent form of this equation is:

                     N                   M
           y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
                    k=1                 k=0

     where c = a/a(1) and d = b/a(1).

     If the fourth argument SI is provided, it is taken as the initial
     state of the system and the final state is returned as SF.  The
     state vector is a column vector whose length is equal to the
     length of the longest coefficient vector minus one.  If SI is not
     supplied, the initial state vector is set to all zeros.

     In terms of the z-transform, y is the result of passing the
     discrete- time signal x through a system characterized by the
     following rational system function:

                      M
                     SUM d(k+1) z^(-k)
                     k=0
           H(z) = ----------------------
                        N
                   1 + SUM c(k+1) z^(-k)
                       k=1
}

#
filter2
{
`filter2' is a function from the file /usr/share/octave/3.2.3/m/signal/filter2.m

 -- Function File: Y = filter2 (B, X)
 -- Function File: Y = filter2 (B, X, SHAPE)
     Apply the 2-D FIR filter B to X.  If the argument SHAPE is
     specified, return an array of the desired shape.  Possible values
     are:

    'full'
          pad X with zeros on all sides before filtering.

    'same'
          unpadded X (default)

    'valid'
          trim X after filtering so edge effects are no included.

     Note this is just a variation on convolution, with the parameters
     reversed and B rotated 180 degrees.

     See also: conv2
}

#
find
{
`find' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/find.oct

 -- Loadable Function:  find (X)
 -- Loadable Function:  find (X, N)
 -- Loadable Function:  find (X, N, DIRECTION)
     Return a vector of indices of nonzero elements of a matrix, as a
     row if X is a row or as a column otherwise.  To obtain a single
     index for each matrix element, Octave pretends that the columns of
     a matrix form one long vector (like Fortran arrays are stored).
     For example,

          find (eye (2))
              => [ 1; 4 ]

     If two outputs are requested, `find' returns the row and column
     indices of nonzero elements of a matrix.  For example,

          [i, j] = find (2 * eye (2))
              => i = [ 1; 2 ]
              => j = [ 1; 2 ]

     If three outputs are requested, `find' also returns a vector
     containing the nonzero values.  For example,

          [i, j, v] = find (3 * eye (2))
              => i = [ 1; 2 ]
              => j = [ 1; 2 ]
              => v = [ 3; 3 ]

     If two inputs are given, N indicates the maximum number of
     elements to find from the beginning of the matrix or vector.

     If three inputs are given, DIRECTION should be one of "first" or
     "last", requesting only the first or last N indices, respectively.
     However, the indices are always returned in ascending order.

     Note that this function is particularly useful for sparse
     matrices, as it extracts the non-zero elements as vectors, which
     can then be used to create the original matrix.  For example,

          sz = size(a);
          [i, j, v] = find (a);
          b = sparse(i, j, v, sz(1), sz(2));

     See also: sparse
}

#
find_dir_in_path
{
`find_dir_in_path' is a built-in function

 -- Built-in Function:  find_dir_in_path (DIR)
     Return the full name of the path element matching DIR.  The match
     is performed at the end of each path element.  For example, if DIR
     is `"foo/bar"', it matches the path element `"/some/dir/foo/bar"',
     but not `"/some/dir/foo/bar/baz"' or `"/some/dir/allfoo/bar"'.
}

#
findall
{
`findall' is a function from the file /usr/share/octave/3.2.3/m/plot/findall.m

 -- Function File: H = findall ()
 -- Function File: H = findall (PROP_NAME, PROP_VALUE)
 -- Function File: H = findall (H, ...)
 -- Function File: H = findall (H, "-depth", D, ...)
     Find object with specified property values including hidden
     handles.

     This function performs the same function as `findobj', but it
     includes hidden objects in its search.  For full documentation, see
     `findobj'.

     See also: get, set, findobj, allchild
}

#
findobj
{
`findobj' is a function from the file /usr/share/octave/3.2.3/m/plot/findobj.m

 -- Function File: H = findobj ()
 -- Function File: H = findobj (PROP_NAME, PROP_VALUE)
 -- Function File: H = findobj ('-property', PROP_NAME)
 -- Function File: H = findobj ('-regexp', PROP_NAME, PATTERN)
 -- Function File: H = findobj ('flat', ...)
 -- Function File: H = findobj (H, ...)
 -- Function File: H = findobj (H, '-depth', D, ...)
     Find object with specified property values.  The simplest form is

          findobj (PROP_NAME, PROP_VALUE)

     which returns all of the handles to the objects with the name
     PROP_NAME and the name PROP_VALUE.  The search can be limited to a
     particular object or set of objects and their descendants by
     passing a handle or set of handles H as the first argument to
     `findobj'.

     The depth of hierarchy of objects to which to search to can be
     limited with the '-depth' argument.  To limit the number depth of
     the hierarchy to search to D generations of children, and example
     is

          findobj (H, '-depth', D, PROP_NAME, PROP_VALUE)

     Specifying a depth D of 0, limits the search to the set of object
     passed in H.  A depth D of 0 is equivalent to the '-flat' argument.

     A specified logical operator may be applied to the pairs of
     PROP_NAME and PROP_VALUE.  The supported logical operators are
     '-and', '-or', '-xor', '-not'.

     The objects may also be matched by comparing a regular expression
     to the property values, where property values that match `regexp
     (PROP_VALUE, PATTERN)' are returned.  Finally, objects may be
     matched by property name only, using the '-property' option.

     See also: get, set
}

#
findstr
{
`findstr' is a function from the file /usr/share/octave/3.2.3/m/strings/findstr.m

 -- Function File:  findstr (S, T, OVERLAP)
     Return the vector of all positions in the longer of the two strings
     S and T where an occurrence of the shorter of the two starts.  If
     the optional argument OVERLAP is nonzero, the returned vector can
     include overlapping positions (this is the default).  For example,

          findstr ("ababab", "a")
               => [1, 3, 5]
          findstr ("abababa", "aba", 0)
               => [1, 5]

     See also: strfind, strmatch, strcmp, strncmp, strcmpi, strncmpi,
     find
}

#
finite
{
`finite' is a built-in function

 -- Mapping Function:  finite (X)
     Return 1 for elements of X that are finite values and zero
     otherwise.  For example,

          finite ([13, Inf, NA, NaN])
              => [ 1, 0, 0, 0 ]
}

#
finv
{
`finv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/finv.m

 -- Function File:  finv (X, M, N)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the F distribution with parameters M and N.
}

#
fix
{
`fix' is a built-in function

 -- Mapping Function:  fix (X)
     Truncate fractional portion of X and return the integer portion.
     This is equivalent to rounding towards zero.  If X is complex,
     return `fix (real (X)) + fix (imag (X)) * I'.
          fix ([-2.7, 2.7])
            => -2   2

     See also: ceil, floor, round
}

#
fixed_point_format
{
`fixed_point_format' is a built-in function

 -- Built-in Function: VAL = fixed_point_format ()
 -- Built-in Function: OLD_VAL = fixed_point_format (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will use a scaled format to print matrix values such that the
     largest element may be written with a single leading digit with
     the scaling factor is printed on the first line of output.  For
     example,

          octave:1> logspace (1, 7, 5)'
          ans =

           1.0e+07  *

           0.00000
           0.00003
           0.00100
           0.03162
           1.00000

     Notice that first value appears to be zero when it is actually 1.
     For this reason, you should be careful when setting
     `fixed_point_format' to a nonzero value.
}

#
flag
{
`flag' is a function from the file /usr/share/octave/3.2.3/m/image/flag.m

 -- Function File:  flag (N)
     Create color colormap.  This colormap cycles through red, white,
     blue and black.  The argument N should be a scalar.  If it is
     omitted, the length of the current colormap or 64 is assumed.

     See also: colormap
}

#
flipdim
{
`flipdim' is a function from the file /usr/share/octave/3.2.3/m/general/flipdim.m

 -- Function File:  flipdim (X, DIM)
     Return a copy of X flipped about the dimension DIM.  For example

          flipdim ([1, 2; 3, 4], 2)
               =>  2  1
                   4  3

     See also: fliplr, flipud, rot90, rotdim
}

#
fliplr
{
`fliplr' is a function from the file /usr/share/octave/3.2.3/m/general/fliplr.m

 -- Function File:  fliplr (X)
     Return a copy of X with the order of the columns reversed.  For
     example,

          fliplr ([1, 2; 3, 4])
               =>  2  1
                   4  3

     Note that `fliplr' only work with 2-D arrays.  To flip N-d arrays
     use `flipdim' instead.

     See also: flipud, flipdim, rot90, rotdim
}

#
flipud
{
`flipud' is a function from the file /usr/share/octave/3.2.3/m/general/flipud.m

 -- Function File:  flipud (X)
     Return a copy of X with the order of the rows reversed.  For
     example,

          flipud ([1, 2; 3, 4])
               =>  3  4
                   1  2

     Due to the difficulty of defining which axis about which to flip
     the matrix `flipud' only work with 2-d arrays.  To flip N-d arrays
     use `flipdim' instead.

     See also: fliplr, flipdim, rot90, rotdim
}

#
floor
{
`floor' is a built-in function

 -- Mapping Function:  floor (X)
     Return the largest integer not greater than X.  This is equivalent
     to rounding towards negative infinity.  If X is complex, return
     `floor (real (X)) + floor (imag (X)) * I'.
          floor ([-2.7, 2.7])
              => -3   2

     See also: ceil, round, fix
}

#
flops
{
`flops' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/flops.m

 -- Function File:  flops ()
     This function is provided for MATLAB compatibility, but it doesn't
     actually do anything.
}

#
fltk_backend
{
No documented.
}

#
fminunc
{
`fminunc' is a function from the file /usr/share/octave/3.2.3/m/optimization/fminunc.m

 -- Function File:  fminunc (FCN, X0, OPTIONS)
 -- Function File: [X, FVEC, INFO, OUTPUT, FJAC] = fminunc (FCN, ...)
     Solve a unconstrained optimization problem defined by the function
     FCN.  FCN should accepts a vector (array) defining the unknown
     variables, and return the objective function value, optionally
     with gradient.  In other words, this function attempts to
     determine a vector X such that `FCN (X)' is a local minimum.  X0
     determines a starting guess. The shape of X0 is preserved in all
     calls to FCN, but otherwise it is treated as a column vector.
     OPTIONS is a structure specifying additional options.  Currently,
     `fminunc' recognizes these options: `"FunValCheck"',
     `"OutputFcn"', `"TolX"', `"TolFun"', `"MaxIter"', `"MaxFunEvals"',
     `"GradObj"', `"FinDiffType"'.

     If `"GradObj"' is `"on"', it specifies that FCN, called with 2
     output arguments, also returns the Jacobian matrix of right-hand
     sides at the requested point.  `"TolX"' specifies the termination
     tolerance in the unknown variables, while `"TolFun"' is a
     tolerance for equations. Default is `1e-7' for both `"TolX"' and
     `"TolFun"'.

     For description of the other options, see `optimset'.

     On return, FVAL contains the value of the function FCN evaluated
     at X, and INFO may be one of the following values:

    1
          Converged to a solution point. Relative gradient error is
          less than specified by TolFun.

    2
          Last relative step size was less that TolX.

    3
          Last relative decrease in func value was less than TolF.

    0
          Iteration limit exceeded.

    -3
          The trust region radius became excessively small.

     Note: If you only have a single nonlinear equation of one
     variable, using `fminbnd' is usually a much better idea.

     See also: fminbnd, optimset
}

#
fmod
{
`fmod' is a built-in function

 -- Mapping Function:  fmod (X, Y)
     Compute the floating point remainder of dividing X by Y using the
     C library function `fmod'.  The result has the same sign as X.  If
     Y is zero, the result is implementation-dependent.

     See also: mod, rem
}

#
fnmatch
{
`fnmatch' is a built-in function

 -- Built-in Function:  fnmatch (PATTERN, STRING)
     Return 1 or zero for each element of STRING that matches any of
     the elements of the string array PATTERN, using the rules of
     filename pattern matching.  For example,

          fnmatch ("a*b", {"ab"; "axyzb"; "xyzab"})
              => [ 1; 1; 0 ]
}

#
fopen
{
`fopen' is a built-in function

 -- Built-in Function: [FID, MSG] = fopen (NAME, MODE, ARCH)
 -- Built-in Function: FID_LIST = fopen ("all")
 -- Built-in Function: [FILE, MODE, ARCH] = fopen (FID)
     The first form of the `fopen' function opens the named file with
     the specified mode (read-write, read-only, etc.) and architecture
     interpretation (IEEE big endian, IEEE little endian, etc.), and
     returns an integer value that may be used to refer to the file
     later.  If an error occurs, FID is set to -1 and MSG contains the
     corresponding system error message.  The MODE is a one or two
     character string that specifies whether the file is to be opened
     for reading, writing, or both.

     The second form of the `fopen' function returns a vector of file
     ids corresponding to all the currently open files, excluding the
     `stdin', `stdout', and `stderr' streams.

     The third form of the `fopen' function returns information about
     the open file given its file id.

     For example,

          myfile = fopen ("splat.dat", "r", "ieee-le");

     opens the file `splat.dat' for reading.  If necessary, binary
     numeric values will be read assuming they are stored in IEEE
     format with the least significant bit first, and then converted to
     the native representation.

     Opening a file that is already open simply opens it again and
     returns a separate file id.  It is not an error to open a file
     several times, though writing to the same file through several
     different file ids may produce unexpected results.

     The possible values `mode' may have are

    `r'
          Open a file for reading.

    `w'
          Open a file for writing.  The previous contents are discarded.

    `a'
          Open or create a file for writing at the end of the file.

    `r+'
          Open an existing file for reading and writing.

    `w+'
          Open a file for reading or writing.  The previous contents are
          discarded.

    `a+'
          Open or create a file for reading or writing at the end of the
          file.

     Append a "t" to the mode string to open the file in text mode or a
     "b" to open in binary mode.  On Windows and Macintosh systems, text
     mode reading and writing automatically converts linefeeds to the
     appropriate line end character for the system (carriage-return
     linefeed on Windows, carriage-return on Macintosh).  The default
     if no mode is specified is binary mode.

     Additionally, you may append a "z" to the mode string to open a
     gzipped file for reading or writing.  For this to be successful,
     you must also open the file in binary mode.

     The parameter ARCH is a string specifying the default data format
     for the file.  Valid values for ARCH are:

          `native' The format of the current machine (this is the
          default).

          `ieee-be' IEEE big endian format.

          `ieee-le' IEEE little endian format.

          `vaxd' VAX D floating format.

          `vaxg' VAX G floating format.

          `cray' Cray floating format.

     however, conversions are currently only supported for `native'
     `ieee-be', and `ieee-le' formats.

     See also: fclose, fgets, fputs, fread, fseek, ferror, fprintf,
     fscanf, ftell, fwrite
}

#
for
{

 -- Keyword: for I = RANGE
     Begin a for loop.
          for i = 1:10
           i
          endfor

     See also: do, while
}

#
fork
{
`fork' is a built-in function

 -- Built-in Function: [PID, MSG] = fork ()
     Create a copy of the current process.

     Fork can return one of the following values:

    > 0
          You are in the parent process.  The value returned from
          `fork' is the process id of the child process.  You should
          probably arrange to wait for any child processes to exit.

    0
          You are in the child process.  You can call `exec' to start
          another process.  If that fails, you should probably call
          `exit'.

    < 0
          The call to `fork' failed for some reason.  You must take
          evasive action.  A system dependent error message will be
          waiting in MSG.
}

#
format
{
`format' is a built-in function

 -- Command: format
 -- Command: format options
     Reset or specify the format of the output produced by `disp' and
     Octave's normal echoing mechanism.  This command only affects the
     display of numbers but not how they are stored or computed.  To
     change the internal representation from the default double use one
     of the conversion functions such as `single', `uint8', `int64',
     etc.

     By default, Octave displays 5 significant digits in a human
     readable form (option `short' paired with `loose' format for
     matrices).  If `format' is invoked without any options, this
     default format is restored.

     Valid formats for floating point numbers are listed in the
     following table.

    `short'
          Fixed point format with 5 significant figures in a field that
          is a maximum of 10 characters wide.  (default).

          If Octave is unable to format a matrix so that columns line
          up on the decimal point and all numbers fit within the
          maximum field width then it switches to an exponential `e'
          format.

    `long'
          Fixed point format with 15 significant figures in a field
          that is a maximum of 20 characters wide.

          As with the `short' format, Octave will switch to an
          exponential `e' format if it is unable to format a matrix
          properly using the current format.

    `short e'
    `long e'
          Exponential format.  The number to be represented is split
          between a mantissa and an exponent (power of 10).  The
          mantissa has 5 significant digits in the short format and 15
          digits in the long format.  For example, with the `short e'
          format, `pi' is displayed as `3.1416e+00'.

    `short E'
    `long E'
          Identical to `short e' or `long e' but displays an uppercase
          `E' to indicate the exponent.  For example, with the `long E'
          format, `pi' is displayed as `3.14159265358979E+00'.

    `short g'
    `long g'
          Optimally choose between fixed point and exponential format
          based on the magnitude of the number.  For example, with the
          `short g' format, `pi .^ [2; 4; 8; 16; 32]' is displayed as

               ans =

                    9.8696
                    97.409
                    9488.5
                9.0032e+07
                8.1058e+15

    `long G'
    `short G'
          Identical to `short g' or `long g' but displays an uppercase
          `E' to indicate the exponent.

    `free'
    `none'
          Print output in free format, without trying to line up
          columns of matrices on the decimal point.  This also causes
          complex numbers to be formatted as numeric pairs like this
          `(0.60419, 0.60709)' instead of like this `0.60419 +
          0.60709i'.

     The following formats affect all numeric output (floating point and
     integer types).

    `+'
    `+ CHARS'
    `plus'
    `plus CHARS'
          Print a `+' symbol for nonzero matrix elements and a space
          for zero matrix elements.  This format can be very useful for
          examining the structure of a large sparse matrix.

          The optional argument CHARS specifies a list of 3 characters
          to use for printing values greater than zero, less than zero
          and equal to zero.  For example, with the `+ "+-."' format,
          `[1, 0, -1; -1, 0, 1]' is displayed as

               ans =

               +.-
               -.+

    `bank'
          Print in a fixed format with two digits to the right of the
          decimal point.

    `native-hex'
          Print the hexadecimal representation of numbers as they are
          stored in memory.  For example, on a workstation which stores
          8 byte real values in IEEE format with the least significant
          byte first, the value of `pi' when printed in `native-hex'
          format is `400921fb54442d18'.

    `hex'
          The same as `native-hex', but always print the most
          significant byte first.

    `native-bit'
          Print the bit representation of numbers as stored in memory.
          For example, the value of `pi' is

               01000000000010010010000111111011
               01010100010001000010110100011000

          (shown here in two 32 bit sections for typesetting purposes)
          when printed in native-bit format on a workstation which
          stores 8 byte real values in IEEE format with the least
          significant byte first.

    `bit'
          The same as `native-bit', but always print the most
          significant bits first.

    `rat'
          Print a rational approximation, i.e., values are approximated
          as the ratio of small integers.  For example, with the `rat'
          format, `pi' is displayed as `355/113'.

     The following two options affect the display of all matrices.

    `compact'
          Remove extra blank space around column number labels
          producing more compact output with more data per page.

    `loose'
          Insert blank lines above and below column number labels to
          produce a more readable output with less data per page.
          (default).
}

#
formula
{
`formula' is a built-in function

 -- Built-in Function:  formula (FUN)
     Return a character string representing the inline function FUN.
     Note that `char (FUN)' is equivalent to `formula (FUN)'.

     See also: argnames, inline, vectorize
}

#
fpdf
{
`fpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/fpdf.m

 -- Function File:  fpdf (X, M, N)
     For each element of X, compute the probability density function
     (PDF) at X of the F distribution with M and N degrees of freedom.
}

#
fplot
{
`fplot' is a function from the file /usr/share/octave/3.2.3/m/plot/fplot.m

 -- Function File:  fplot (FN, LIMITS)
 -- Function File:  fplot (FN, LIMITS, TOL)
 -- Function File:  fplot (FN, LIMITS, N)
 -- Function File:  fplot (..., FMT)
     Plot a function FN, within the defined limits.  FN an be either a
     string, a function handle or an inline function.  The limits of
     the plot are given by LIMITS of the form `[XLO, XHI]' or `[XLO,
     XHI, YLO, YHI]'.  TOL is the default tolerance to use for the
     plot, and if TOL is an integer it is assumed that it defines the
     number points to use in the plot.  The FMT argument is passed to
     the plot command.

             fplot ("cos", [0, 2*pi])
             fplot ("[cos(x), sin(x)]", [0, 2*pi])

     See also: plot
}

#
fprintf
{
`fprintf' is a built-in function

 -- Built-in Function:  fprintf (FID, TEMPLATE, ...)
     This function is just like `printf', except that the output is
     written to the stream FID instead of `stdout'.  If FID is omitted,
     the output is written to `stdout'.

     See also: printf, sprintf, fread, fscanf, fopen, fclose
}

#
fputs
{
`fputs' is a built-in function

 -- Built-in Function:  fputs (FID, STRING)
     Write a string to a file with no formatting.

     Return a non-negative number on success and EOF on error.

     See also: scanf, sscanf, fread, fprintf, fgets, fscanf
}

#
fractdiff
{
`fractdiff' is a function from the file /usr/share/octave/3.2.3/m/signal/fractdiff.m

 -- Function File:  fractdiff (X, D)
     Compute the fractional differences (1-L)^d x where L denotes the
     lag-operator and d is greater than -1.
}

#
fread
{
`fread' is a built-in function

 -- Built-in Function: [VAL, COUNT] = fread (FID, SIZE, PRECISION,
          SKIP, ARCH)
     Read binary data of type PRECISION from the specified file ID FID.

     The optional argument SIZE specifies the amount of data to read
     and may be one of

    `Inf'
          Read as much as possible, returning a column vector.

    `NR'
          Read up to NR elements, returning a column vector.

    `[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.
          If the number of elements read is not an exact multiple of
          NR, the last column is padded with zeros.

    `[NR, NC]'
          Read up to `NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of `Inf' is assumed.

     The optional argument PRECISION is a string specifying the type of
     data to read and may be one of

    `"schar"'
    `"signed char"'
          Signed character.

    `"uchar"'
    `"unsigned char"'
          Unsigned character.

    `"int8"'
    `"integer*1"'
          8-bit signed integer.

    `"int16"'
    `"integer*2"'
          16-bit signed integer.

    `"int32"'
    `"integer*4"'
          32-bit signed integer.

    `"int64"'
    `"integer*8"'
          64-bit signed integer.

    `"uint8"'
          8-bit unsigned integer.

    `"uint16"'
          16-bit unsigned integer.

    `"uint32"'
          32-bit unsigned integer.

    `"uint64"'
          64-bit unsigned integer.

    `"single"'
    `"float32"'
    `"real*4"'
          32-bit floating point number.

    `"double"'
    `"float64"'
    `"real*8"'
          64-bit floating point number.

    `"char"'
    `"char*1"'
          Single character.

    `"short"'
          Short integer (size is platform dependent).

    `"int"'
          Integer (size is platform dependent).

    `"long"'
          Long integer (size is platform dependent).

    `"ushort"'
    `"unsigned short"'
          Unsigned short integer (size is platform dependent).

    `"uint"'
    `"unsigned int"'
          Unsigned integer (size is platform dependent).

    `"ulong"'
    `"unsigned long"'
          Unsigned long integer (size is platform dependent).

    `"float"'
          Single precision floating point number (size is platform
          dependent).

     The default precision is `"uchar"'.

     The PRECISION argument may also specify an optional repeat count.
     For example, `32*single' causes `fread' to read a block of 32
     single precision floating point numbers.  Reading in blocks is
     useful in combination with the SKIP argument.

     The PRECISION argument may also specify a type conversion.  For
     example, `int16=>int32' causes `fread' to read 16-bit integer
     values and return an array of 32-bit integer values.  By default,
     `fread' returns a double precision array.  The special form
     `*TYPE' is shorthand for `TYPE=>TYPE'.

     The conversion and repeat counts may be combined.  For example, the
     specification `32*single=>single' causes `fread' to read blocks of
     single precision floating point values and return an array of
     single precision values instead of the default array of double
     precision values.

     The optional argument SKIP specifies the number of bytes to skip
     after each element (or block of elements) is read.  If it is not
     specified, a value of 0 is assumed.  If the final block read is not
     complete, the final skip is omitted.  For example,

          fread (f, 10, "3*single=>single", 8)

     will omit the final 8-byte skip because the last read will not be
     a complete block of 3 values.

     The optional argument ARCH is a string specifying the data format
     for the file.  Valid values are

    `"native"'
          The format of the current machine.

    `"ieee-be"'
          IEEE big endian.

    `"ieee-le"'
          IEEE little endian.

    `"vaxd"'
          VAX D floating format.

    `"vaxg"'
          VAX G floating format.

    `"cray"'
          Cray floating format.

     Conversions are currently only supported for `"ieee-be"' and
     `"ieee-le"' formats.

     The data read from the file is returned in VAL, and the number of
     values read is returned in `count'

     See also: fwrite, fopen, fclose
}

#
freport
{
`freport' is a built-in function

 -- Built-in Function:  freport ()
     Print a list of which files have been opened, and whether they are
     open for reading, writing, or both.  For example,

          freport ()

              -|  number  mode  name
              -|
              -|       0     r  stdin
              -|       1     w  stdout
              -|       2     w  stderr
              -|       3     r  myfile
}

#
freqz
{
`freqz' is a function from the file /usr/share/octave/3.2.3/m/signal/freqz.m

 -- Function File: [H, W] = freqz (B, A, N, "whole")
     Return the complex frequency response H of the rational IIR filter
     whose numerator and denominator coefficients are B and A,
     respectively.  The response is evaluated at N angular frequencies
     between 0 and  2*pi.

     The output value W is a vector of the frequencies.

     If the fourth argument is omitted, the response is evaluated at
     frequencies between 0 and  pi.

     If N is omitted, a value of 512 is assumed.

     If A is omitted, the denominator is assumed to be 1 (this
     corresponds to a simple FIR filter).

     For fastest computation, N should factor into a small number of
     small primes.

 -- Function File: H = freqz (B, A, W)
     Evaluate the response at the specific frequencies in the vector W.
     The values for W are measured in radians.

 -- Function File: [...] = freqz (..., FS)
     Return frequencies in Hz instead of radians assuming a sampling
     rate FS.  If you are evaluating the response at specific
     frequencies W, those frequencies should be requested in Hz rather
     than radians.

 -- Function File:  freqz (...)
     Plot the pass band, stop band and phase response of H rather than
     returning them.
}

#
freqz_plot
{
`freqz_plot' is a function from the file /usr/share/octave/3.2.3/m/signal/freqz_plot.m

 -- Function File:  freqz_plot (W, H)
     Plot the pass band, stop band and phase response of H.
}

#
frewind
{
`frewind' is a built-in function

 -- Built-in Function:  frewind (FID)
     Move the file pointer to the beginning of the file FID, returning
     0 for success, and -1 if an error was encountered.  It is
     equivalent to `fseek (FID, 0, SEEK_SET)'.
}

#
frnd
{
`frnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/frnd.m

 -- Function File:  frnd (M, N, R, C)
 -- Function File:  frnd (M, N, SZ)
     Return an R by C matrix of random samples from the F distribution
     with M and N degrees of freedom.  Both M and N must be scalar or
     of size R by C.  If SZ is a vector the random samples are in a
     matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of M and N.
}

#
fscanf
{
`fscanf' is a built-in function

 -- Built-in Function: [VAL, COUNT] = fscanf (FID, TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT] = fscanf (FID, TEMPLATE,
          "C")
     In the first form, read from FID according to TEMPLATE, returning
     the result in the matrix VAL.

     The optional argument SIZE specifies the amount of data to read
     and may be one of

    `Inf'
          Read as much as possible, returning a column vector.

    `NR'
          Read up to NR elements, returning a column vector.

    `[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.
          If the number of elements read is not an exact multiple of
          NR, the last column is padded with zeros.

    `[NR, NC]'
          Read up to `NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of `Inf' is assumed.

     A string is returned if TEMPLATE specifies only character
     conversions.

     The number of items successfully read is returned in COUNT.

     In the second form, read from FID according to TEMPLATE, with each
     conversion specifier in TEMPLATE corresponding to a single scalar
     return value.  This form is more `C-like', and also compatible
     with previous versions of Octave.  The number of successful
     conversions is returned in COUNT

     See the Formatted Input section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: scanf, sscanf, fread, fprintf, fgets, fputs
}

#
fseek
{
`fseek' is a built-in function

 -- Built-in Function:  fseek (FID, OFFSET, ORIGIN)
     Set the file pointer to any location within the file FID.

     The pointer is positioned OFFSET characters from the ORIGIN, which
     may be one of the predefined variables `SEEK_CUR' (current
     position), `SEEK_SET' (beginning), or `SEEK_END' (end of file) or
     strings "cof", "bof" or "eof".  If ORIGIN is omitted, `SEEK_SET'
     is assumed.  The offset must be zero, or a value returned by
     `ftell' (in which case ORIGIN must be `SEEK_SET').

     Return 0 on success and -1 on error.

     See also: ftell, fopen, fclose
}

#
fsolve
{
`fsolve' is a function from the file /usr/share/octave/3.2.3/m/optimization/fsolve.m

 -- Function File:  fsolve (FCN, X0, OPTIONS)
 -- Function File: [X, FVEC, INFO, OUTPUT, FJAC] = fsolve (FCN, ...)
     Solve a system of nonlinear equations defined by the function FCN.
     FCN should accepts a vector (array) defining the unknown variables,
     and return a vector of left-hand sides of the equations.
     Right-hand sides are defined to be zeros.  In other words, this
     function attempts to determine a vector X such that `FCN (X)'
     gives (approximately) all zeros.  X0 determines a starting guess.
     The shape of X0 is preserved in all calls to FCN, but otherwise it
     is treated as a column vector.  OPTIONS is a structure specifying
     additional options.  Currently, `fsolve' recognizes these options:
     `"FunValCheck"', `"OutputFcn"', `"TolX"', `"TolFun"', `"MaxIter"',
     `"MaxFunEvals"', `"Jacobian"', `"Updating"' and `"ComplexEqn"'.

     If `"Jacobian"' is `"on"', it specifies that FCN, called with 2
     output arguments, also returns the Jacobian matrix of right-hand
     sides at the requested point.  `"TolX"' specifies the termination
     tolerance in the unknown variables, while `"TolFun"' is a
     tolerance for equations.  Default is `1e-7' for both `"TolX"' and
     `"TolFun"'.  If `"Updating"' is "on", the function will attempt to
     use Broyden updates to update the Jacobian, in order to reduce the
     amount of jacobian calculations.  If your user function always
     calculates the Jacobian (regardless of number of output
     arguments), this option provides no advantage and should be set to
     false.

     `"ComplexEqn"' is `"on"', `fsolve' will attempt to solve complex
     equations in complex variables, assuming that the equations
     possess a complex derivative (i.e., are holomorphic).  If this is
     not what you want, should unpack the real and imaginary parts of
     the system to get a real system.

     For description of the other options, see `optimset'.

     On return, FVAL contains the value of the function FCN evaluated
     at X, and INFO may be one of the following values:

    1
          Converged to a solution point.  Relative residual error is
          less than specified by TolFun.

    2
          Last relative step size was less that TolX.

    3
          Last relative decrease in residual was less than TolF.

    0
          Iteration limit exceeded.

    -3
          The trust region radius became excessively small.

     Note: If you only have a single nonlinear equation of one
     variable, using `fzero' is usually a much better idea.

     See also: fzero, optimset

     Note about user-supplied jacobians: As an inherent property of the
     algorithm, jacobian is always requested for a solution vector
     whose residual vector is already known, and it is the last
     accepted successful step.  Often this will be one of the last two
     calls, but not always.  If the savings by reusing intermediate
     results from residual calculation in jacobian calculation are
     significant, the best strategy is to employ OutputFcn: After a
     vector is evaluated for residuals, if OutputFcn is called with
     that vector, then the intermediate results should be saved for
     future jacobian evaluation, and should be kept until a jacobian
     evaluation is requested or until outputfcn is called with a
     different vector, in which case they should be dropped in favor of
     this most recent vector.  A short example how this can be achieved
     follows:

          function [fvec, fjac] = user_func (x, optimvalues, state)
          persistent sav = [], sav0 = [];
          if (nargin == 1)
            ## evaluation call
            if (nargout == 1)
              sav0.x = x; # mark saved vector
              ## calculate fvec, save results to sav0.
            elseif (nargout == 2)
              ## calculate fjac using sav.
            endif
          else
            ## outputfcn call.
            if (all (x == sav0.x))
              sav = sav0;
            endif
            ## maybe output iteration status, etc.
          endif
          endfunction

          ## ....

          fsolve (@user_func, x0, optimset ("OutputFcn", @user_func, ...))
}

#
fstat
{
`fstat' is a built-in function

 -- Built-in Function: [INFO, ERR, MSG] = fstat (FID)
     Return information about the open file FID.  See `stat' for a
     description of the contents of INFO.
}

#
ftell
{
`ftell' is a built-in function

 -- Built-in Function:  ftell (FID)
     Return the position of the file pointer as the number of characters
     from the beginning of the file FID.

     See also: fseek, fopen, fclose
}

#
full
{
`full' is a built-in function

 -- Loadable Function: FM = full (SM)
     returns a full storage matrix from a sparse, diagonal, permutation
     matrix or a range.

     See also: sparse
}

#
fullfile
{
`fullfile' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/fullfile.m

 -- Function File: FILENAME = fullfile (DIR1, DIR2, ..., FILE)
     Return a complete filename constructed from the given components.

     See also: fileparts
}

#
func2str
{
`func2str' is a built-in function

 -- Built-in Function:  func2str (FCN_HANDLE)
     Return a string containing the name of the function referenced by
     the function handle FCN_HANDLE.
}

#
function
{

 -- Keyword: function OUTPUTS = function (INPUT, ...)
 -- Keyword: function  function (INPUT, ...)
 -- Keyword: function OUTPUTS = function
     Begin a function body with OUTPUTS as results and INPUTS as
     parameters.

     See also: return
}

#
functions
{
`functions' is a built-in function

 -- Built-in Function:  functions (FCN_HANDLE)
     Return a struct containing information about the function handle
     FCN_HANDLE.
}

#
fwrite
{
`fwrite' is a built-in function

 -- Built-in Function: COUNT = fwrite (FID, DATA, PRECISION, SKIP, ARCH)
     Write data in binary form of type PRECISION to the specified file
     ID FID, returning the number of values successfully written to the
     file.

     The argument DATA is a matrix of values that are to be written to
     the file.  The values are extracted in column-major order.

     The remaining arguments PRECISION, SKIP, and ARCH are optional,
     and are interpreted as described for `fread'.

     The behavior of `fwrite' is undefined if the values in DATA are
     too large to fit in the specified precision.

     See also: fread, fopen, fclose
}

#
fzero
{
`fzero' is a function from the file /usr/share/octave/3.2.3/m/optimization/fzero.m

 -- Function File: [X, FVAL, INFO, OUTPUT] = fzero (FUN, X0, OPTIONS)
     Find a zero point of a univariate function.  FUN should be a
     function handle or name.  X0 specifies a starting point.  OPTIONS
     is a structure specifying additional options.  Currently, `fzero'
     recognizes these options: `"FunValCheck"', `"OutputFcn"',
     `"TolX"', `"MaxIter"', `"MaxFunEvals"'.  For description of these
     options, see *note optimset: doc-optimset.

     On exit, the function returns X, the approximate zero point and
     FVAL, the function value thereof.  INFO is an exit flag that can
     have these values:
        * 1 The algorithm converged to a solution.

        * 0 Maximum number of iterations or function evaluations has
          been exhausted.

        * -1 The algorithm has been terminated from user output
          function.

        * -2 A general unexpected error.

        * -3 A non-real value encountered.

        * -4 A NaN value encountered.

     See also: optimset, fsolve
}

#
gamcdf
{
`gamcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/gamcdf.m

 -- Function File:  gamcdf (X, A, B)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Gamma distribution with parameters A
     and B.

     See also: gamma, gammaln, gammainc, gampdf, gaminv, gamrnd
}

#
gaminv
{
`gaminv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/gaminv.m

 -- Function File:  gaminv (X, A, B)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the Gamma distribution with parameters A and B.

     See also: gamma, gammaln, gammainc, gampdf, gamcdf, gamrnd
}

#
gamma
{
`gamma' is a built-in function

 -- Mapping Function:  gamma (Z)
     Computes the Gamma function,

                     infinity
                     /
          gamma (z) = | t^(z-1) exp (-t) dt.
                     /
                  t=0

     See also: gammainc, lgamma
}

#
gamma_cdf
{
`gamma_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/gamma_cdf.m

 -- Function File:  gamma_cdf (X, A, B)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Gamma distribution with parameters A
     and B.
}

#
gamma_inv
{
`gamma_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/gamma_inv.m

 -- Function File:  gamma_inv (X, A, B)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the Gamma distribution with parameters A and B.
}

#
gamma_pdf
{
`gamma_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/gamma_pdf.m

 -- Function File:  gamma_pdf (X, A, B)
     For each element of X, return the probability density function
     (PDF) at X of the Gamma distribution with parameters A and B.
}

#
gamma_rnd
{
`gamma_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/gamma_rnd.m

 -- Function File:  gamma_rnd (A, B, R, C)
 -- Function File:  gamma_rnd (A, B, SZ)
     Return an R by C or a `size (SZ)' matrix of random samples from
     the Gamma distribution with parameters A and B.  Both A and B must
     be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of A and B.
}

#
gammai
{
`gammai' is a function from the file /usr/share/octave/3.2.3/m/specfun/gammai.m

 -- Function File:  gammai (A, X)
     This function is provided for compatibility with older versions of
     Octave.  New programs should use `gammainc' instead.

     `gammai (A, X)' is the same as `gammainc (X, A)'.
}

#
gammainc
{
`gammainc' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/gammainc.oct

 -- Mapping Function:  gammainc (X, A)
     Compute the normalized incomplete gamma function,

                                         x
                               1        /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                           gamma (a)    /
                                     t=0

     with the limiting value of 1 as X approaches infinity.  The
     standard notation is P(a,x), e.g., Abramowitz and Stegun (6.5.1).

     If A is scalar, then `gammainc (X, A)' is returned for each
     element of X and vice versa.

     If neither X nor A is scalar, the sizes of X and A must agree, and
     GAMMAINC is applied element-by-element.

     See also: gamma, lgamma
}

#
gammaln
{
`gammaln' is a built-in function

 -- Mapping Function:  lgamma (X)
 -- Mapping Function:  gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc
}

#
gampdf
{
`gampdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/gampdf.m

 -- Function File:  gampdf (X, A, B)
     For each element of X, return the probability density function
     (PDF) at X of the Gamma distribution with parameters A and B.

     See also: gamma, gammaln, gammainc, gamcdf, gaminv, gamrnd
}

#
gamrnd
{
`gamrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/gamrnd.m

 -- Function File:  gamrnd (A, B, R, C)
 -- Function File:  gamrnd (A, B, SZ)
     Return an R by C or a `size (SZ)' matrix of random samples from
     the Gamma distribution with parameters A and B.  Both A and B must
     be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of A and B.

     See also: gamma, gammaln, gammainc, gampdf, gamcdf, gaminv
}

#
gca
{
`gca' is a function from the file /usr/share/octave/3.2.3/m/plot/gca.m

 -- Function File:  gca ()
     Return a handle to the current axis object.  If no axis object
     exists, create one and return its handle.  The handle may then be
     used to examine or set properties of the axes.  For example,

          ax = gca ();
          set (ax, "position", [0.5, 0.5, 0.5, 0.5]);

     creates an empty axes object, then changes its location and size in
     the figure window.

     See also: get, set
}

#
gcbf
{
`gcbf' is a function from the file /usr/share/octave/3.2.3/m/plot/gcbf.m

 -- Function File: FIG = gcbf ()
     Return a handle to the figure containing the object whose callback
     is currently executing.  If no callback is executing, this function
     returns the empty matrix.  The handle returned by this function is
     the same as the second output argument of gcbo.

     See also: gcf, gca, gcbo
}

#
gcbo
{
`gcbo' is a function from the file /usr/share/octave/3.2.3/m/plot/gcbo.m

 -- Function File: H = gcbo ()
 -- Function File: [H, FIG] = gcbo ()
     Return a handle to the object whose callback is currently
     executing.  If no callback is executing, this function returns the
     empty matrix.  This handle is obtained from the root object
     property "CallbackObject".

     Additionally return the handle of the figure containing the object
     whose callback is currently executing.  If no callback is
     executing, the second output is also set to the empty matrix.

     See also: gcf, gca, gcbf
}

#
gcd
{
`gcd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/gcd.oct

 -- Loadable Function: G = gcd (A)
 -- Loadable Function: G = gcd (A1, A2, ...)
 -- Loadable Function: [G, V1, ...] = gcd (A1, A2, ...)
     Compute the greatest common divisor of the elements of A.  If more
     than one argument is given all arguments must be the same size or
     scalar.   In this case the greatest common divisor is calculated
     for each element individually.  All elements must be integers.
     For example,

          gcd ([15, 20])
             =>  5

     and

          gcd ([15, 9], [20, 18])
             =>  5  9

     Optional return arguments V1, etc., contain integer vectors such
     that,

          G = V1 .* A1 + V2 .* A2 + ...

     For backward compatibility with previous versions of this
     function, when all arguments are scalar, a single return argument
     V1 containing all of the values of V1, ... is acceptable.

     See also: lcm, factor
}

#
gcf
{
`gcf' is a function from the file /usr/share/octave/3.2.3/m/plot/gcf.m

 -- Function File:  gcf ()
     Return the current figure handle.  If a figure does not exist,
     create one and return its handle.  The handle may then be used to
     examine or set properties of the figure.  For example,

          fplot (@sin, [-10, 10]);
          fig = gcf ();
          set (fig, "visible", "off");

     plots a sine wave, finds the handle of the current figure, and then
     makes that figure invisible.  Setting the visible property of the
     figure to `"on"' will cause it to be displayed again.

     See also: get, set
}

#
ge
{
`ge' is a built-in function

 -- Built-in Function:  ge (X, Y)
     This function is equivalent to `x >= y'.
}

#
gen_doc_cache
{
`gen_doc_cache' is a function from the file /usr/share/octave/3.2.3/m/help/gen_doc_cache.m

 -- Function File: gen_doc_cache (OUT_FILE, DIRECTORY)
     Generate documentation caches for all functions in a given
     directory.

     A documentation cache is generated for all functions in DIRECTORY.
     The resulting cache is saved in the file OUT_FILE.  The cache is
     used to speed up `lookfor'.

     If no directory is given (or it is the empty matrix), a cache for
     builtin operators, etc. is generated.

     See also: lookfor, path
}

#
genpath
{
`genpath' is a built-in function

 -- Built-in Function:  genpath (DIR)
     Return a path constructed from DIR and all its subdirectories.
}

#
genvarname
{
`genvarname' is a function from the file /usr/share/octave/3.2.3/m/general/genvarname.m

 -- Function File: VARNAME = genvarname (STR)
 -- Function File: VARNAME = genvarname (STR, EXCLUSIONS)
     Create unique variable(s) from STR.  If EXCLUSIONS is given, then
     the variable(s) will be unique to each other and to EXCLUSIONS
     (EXCLUSIONS may be either a string or a cellstr).

     If STR is a cellstr, then a unique variable is created for each
     cell in STR.

          x = 3.141;
          genvarname ("x", who ())
          => x1

     If WANTED is a cell array, genvarname will make sure the returned
     strings are distinct:

          genvarname ({"foo", "foo"})
          =>
          {
            [1,1] = foo
            [1,2] = foo1
          }

     Note that the result is a char array/cell array of strings, not the
     variables themselves.  To define a variable, `eval()' can be used.
     The following trivial example sets `x' to `42'.

          name = genvarname ("x");
          eval([name " = 42"]);
          => x =  42

     Also, this can be useful for creating unique struct field names.

          x = struct ();
          for i = 1:3
            x.(genvarname ("a", fieldnames (x))) = i;
          endfor
          =>
          x =
          {
            a =  1
            a1 =  2
            a2 =  3
          }

     Since variable names may only contain letters, digits and
     underscores, genvarname replaces any sequence of disallowed
     characters with an underscore.  Also, variables may not begin with
     a digit; in this case an underscore is added before the variable
     name.

     Variable names beginning and ending with two underscores "__" are
     valid but they are used internally by octave and should generally
     be avoided, therefore genvarname will not generate such names.

     genvarname will also make sure that returned names do not clash
     with keywords such as "for" and "if".  A number will be appended
     if necessary.  Note, however, that this does *not* include
     function names, such as "sin".  Such names should be included in
     AVOID if necessary.

     See also: isvarname, exist, tmpnam, eval
}

#
geocdf
{
`geocdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/geocdf.m

 -- Function File:  geocdf (X, P)
     For each element of X, compute the CDF at X of the geometric
     distribution with parameter P.
}

#
geoinv
{
`geoinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/geoinv.m

 -- Function File:  geoinv (X, P)
     For each element of X, compute the quantile at X of the geometric
     distribution with parameter P.
}

#
geometric_cdf
{
`geometric_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/geometric_cdf.m

 -- Function File:  geometric_cdf (X, P)
     For each element of X, compute the CDF at X of the geometric
     distribution with parameter P.
}

#
geometric_inv
{
`geometric_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/geometric_inv.m

 -- Function File:  geometric_inv (X, P)
     For each element of X, compute the quantile at X of the geometric
     distribution with parameter P.
}

#
geometric_pdf
{
`geometric_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/geometric_pdf.m

 -- Function File:  geometric_pdf (X, P)
     For each element of X, compute the probability density function
     (PDF) at X of the geometric distribution with parameter P.
}

#
geometric_rnd
{
`geometric_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/geometric_rnd.m

 -- Function File:  geometric_rnd (P, R, C)
 -- Function File:  geometric_rnd (P, SZ)
     Return an R by C matrix of random samples from the geometric
     distribution with parameter P, which must be a scalar or of size R
     by C.

     If R and C are given create a matrix with R rows and C columns.
     Or if SZ is a vector, create a matrix of size SZ.
}

#
geopdf
{
`geopdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/geopdf.m

 -- Function File:  geopdf (X, P)
     For each element of X, compute the probability density function
     (PDF) at X of the geometric distribution with parameter P.
}

#
geornd
{
`geornd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/geornd.m

 -- Function File:  geornd (P, R, C)
 -- Function File:  geornd (P, SZ)
     Return an R by C matrix of random samples from the geometric
     distribution with parameter P, which must be a scalar or of size R
     by C.

     If R and C are given create a matrix with R rows and C columns.
     Or if SZ is a vector, create a matrix of size SZ.
}

#
get
{
`get' is a built-in function

 -- Built-in Function:  get (H, P)
     Return the named property P from the graphics handle H.  If P is
     omitted, return the complete property list for H.  If H is a
     vector, return a cell array including the property values or lists
     respectively.
}

#
get_first_help_sentence
{
`get_first_help_sentence' is a function from the file /usr/share/octave/3.2.3/m/help/get_first_help_sentence.m

 -- Function File: [RETVAL, STATUS] = get_first_help_sentence (NAME,
          MAX_LEN)
     Return the first sentence of a function help text.

     The function reads the first sentence of the help text of the
     function NAME.  The first sentence is defined as the text after
     the function declaration until either the first period (".") or
     the first appearance of two consecutive end-lines ("\n\n").  The
     text is truncated to a maximum length of MAX_LEN, which defaults
     to 80.

     The optional output argument STATUS returns the status reported by
     `makeinfo'.  If only one output argument is requested, and STATUS
     is non-zero, a warning is displayed.

     As an example, the first sentence of this help text is

          get_first_help_sentence ("get_first_help_sentence")
          -| ans = Return the first sentence of a function help text.
}

#
get_help_text
{
`get_help_text' is a built-in function

 -- Loadable Function: [TEXT, FORMAT] = get_help_text (NAME)
     Returns the help text of a given function.

     This function returns the raw help text TEXT and an indication of
     its format for the function NAME.  The format indication FORMAT is
     a string that can be either "texinfo", "html", or "plain text".

     To convert the help text to other formats, use the `makeinfo'
     function.

     See also: makeinfo
}

#
getegid
{
`getegid' is a built-in function

 -- Built-in Function: egid = getegid ()
     Return the effective group id of the current process.
}

#
getenv
{
`getenv' is a built-in function

 -- Built-in Function:  getenv (VAR)
     Return the value of the environment variable VAR.  For example,

          getenv ("PATH")

     returns a string containing the value of your path.
}

#
geteuid
{
`geteuid' is a built-in function

 -- Built-in Function: euid = geteuid ()
     Return the effective user id of the current process.
}

#
getfield
{
`getfield' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/getfield.m

 -- Function File: [V1, ...] = getfield (S, KEY, ...)
     Extract fields from a structure.  For example

          ss(1,2).fd(3).b = 5;
          getfield (ss, {1,2}, "fd", {3}, "b")
          => ans = 5

     Note that the function call in the previous example is equivalent
     to the expression

          i1 = {1,2}; i2 = "fd"; i3 = {3}; i4= "b";
          ss(i1{:}).(i2)(i3{:}).(i4)

     See also: setfield, rmfield, isfield, isstruct, fieldnames, struct
}

#
getgid
{
`getgid' is a built-in function

 -- Built-in Function: gid = getgid ()
     Return the real group id of the current process.
}

#
getgrent
{
`getgrent' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getgrent.oct

 -- Loadable Function: GRP_STRUCT = getgrent ()
     Return an entry from the group database, opening it if necessary.
     Once the end of the data has been reached, `getgrent' returns 0.
}

#
getgrgid
{
`getgrgid' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getgrent.oct

 -- Loadable Function: GRP_STRUCT = getgrgid (GID).
     Return the first entry from the group database with the group ID
     GID.  If the group ID does not exist in the database, `getgrgid'
     returns 0.
}

#
getgrnam
{
`getgrnam' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getgrent.oct

 -- Loadable Function: GRP_STRUCT = getgrnam (NAME)
     Return the first entry from the group database with the group name
     NAME.  If the group name does not exist in the database,
     `getgrnam' returns 0.
}

#
getpgrp
{
`getpgrp' is a built-in function

 -- Built-in Function: pgid = getpgrp ()
     Return the process group id of the current process.
}

#
getpid
{
`getpid' is a built-in function

 -- Built-in Function: pid = getpid ()
     Return the process id of the current process.
}

#
getppid
{
`getppid' is a built-in function

 -- Built-in Function: pid = getppid ()
     Return the process id of the parent process.
}

#
getpwent
{
`getpwent' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getpwent.oct

 -- Loadable Function: PW_STRUCT = getpwent ()
     Return a structure containing an entry from the password database,
     opening it if necessary.  Once the end of the data has been
     reached, `getpwent' returns 0.
}

#
getpwnam
{
`getpwnam' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getpwent.oct

 -- Loadable Function: PW_STRUCT = getpwnam (NAME)
     Return a structure containing the first entry from the password
     database with the user name NAME.  If the user name does not exist
     in the database, `getpwname' returns 0.
}

#
getpwuid
{
`getpwuid' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getpwent.oct

 -- Loadable Function: PW_STRUCT = getpwuid (UID).
     Return a structure containing the first entry from the password
     database with the user ID UID.  If the user ID does not exist in
     the database, `getpwuid' returns 0.
}

#
getrusage
{
`getrusage' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getrusage.oct

 -- Loadable Function:  getrusage ()
     Return a structure containing a number of statistics about the
     current Octave process.  Not all fields are available on all
     systems.  If it is not possible to get CPU time statistics, the
     CPU time slots are set to zero.  Other missing data are replaced
     by NaN.  Here is a list of all the possible fields that can be
     present in the structure returned by `getrusage':

    `idrss'
          Unshared data size.

    `inblock'
          Number of block input operations.

    `isrss'
          Unshared stack size.

    `ixrss'
          Shared memory size.

    `majflt'
          Number of major page faults.

    `maxrss'
          Maximum data size.

    `minflt'
          Number of minor page faults.

    `msgrcv'
          Number of messages received.

    `msgsnd'
          Number of messages sent.

    `nivcsw'
          Number of involuntary context switches.

    `nsignals'
          Number of signals received.

    `nswap'
          Number of swaps.

    `nvcsw'
          Number of voluntary context switches.

    `oublock'
          Number of block output operations.

    `stime'
          A structure containing the system CPU time used.  The
          structure has the elements `sec' (seconds) `usec'
          (microseconds).

    `utime'
          A structure containing the user CPU time used.  The structure
          has the elements `sec' (seconds) `usec' (microseconds).
}

#
getuid
{
`getuid' is a built-in function

 -- Built-in Function: uid = getuid ()
     Return the real user id of the current process.
}

#
ginput
{
`ginput' is a function from the file /usr/share/octave/3.2.3/m/plot/ginput.m

 -- Function File: [X, Y, BUTTONS] = ginput (N)
     Return which mouse buttons were pressed and keys were hit on the
     current figure.  If N is defined, then wait for N mouse clicks
     before returning.  If N is not defined, then `ginput' will loop
     until the return key is pressed.
}

#
givens
{
`givens' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/givens.oct

 -- Loadable Function: G = givens (X, Y)
 -- Loadable Function: [C, S] = givens (X, Y)
     Return a 2 by 2 orthogonal matrix `G = [C S; -S' C]' such that `G
     [X; Y] = [*; 0]' with X and Y scalars.

     For example,

          givens (1, 1)
              =>   0.70711   0.70711
                  -0.70711   0.70711
}

#
glob
{
`glob' is a built-in function

 -- Built-in Function:  glob (PATTERN)
     Given an array of strings (as a char array or a cell array) in
     PATTERN, return a cell array of file names that match any of them,
     or an empty cell array if no patterns match.  Tilde expansion is
     performed on each of the patterns before looking for matching file
     names.  For example,

          glob ("/vm*")
              => "/vmlinuz"

     See also: dir, ls, stat, readdir
}

#
global
{

 -- Keyword: global
     Declare variables to have global scope.
          global X;
          if isempty (X)
           x = 1;
          endif

     See also: persistent
}

#
glpk
{
`glpk' is a function from the file /usr/share/octave/3.2.3/m/optimization/glpk.m

 -- Function File: [XOPT, FMIN, STATUS, EXTRA] = glpk (C, A, B, LB, UB,
          CTYPE, VARTYPE, SENSE, PARAM)
     Solve a linear program using the GNU GLPK library.  Given three
     arguments, `glpk' solves the following standard LP:

          min C'*x

     subject to

          A*x  = b
            x >= 0

     but may also solve problems of the form

          [ min | max ] C'*x

     subject to

          A*x [ "=" | "<=" | ">=" ] b
            x >= LB
            x <= UB

     Input arguments:

    C
          A column array containing the objective function coefficients.

    A
          A matrix containing the constraints coefficients.

    B
          A column array containing the right-hand side value for each
          constraint in the constraint matrix.

    LB
          An array containing the lower bound on each of the variables.
          If LB is not supplied, the default lower bound for the
          variables is zero.

    UB
          An array containing the upper bound on each of the variables.
          If UB is not supplied, the default upper bound is assumed to
          be infinite.

    CTYPE
          An array of characters containing the sense of each
          constraint in the constraint matrix.  Each element of the
          array may be one of the following values
         `"F"'
               A free (unbounded) constraint (the constraint is
               ignored).

         `"U"'
               An inequality constraint with an upper bound (`A(i,:)*x
               <= b(i)').

         `"S"'
               An equality constraint (`A(i,:)*x = b(i)').

         `"L"'
               An inequality with a lower bound (`A(i,:)*x >= b(i)').

         `"D"'
               An inequality constraint with both upper and lower bounds
               (`A(i,:)*x >= -b(i)' _and_ (`A(i,:)*x <= b(i)').

    VARTYPE
          A column array containing the types of the variables.
         `"C"'
               A continuous variable.

         `"I"'
               An integer variable.

    SENSE
          If SENSE is 1, the problem is a minimization.  If SENSE is
          -1, the problem is a maximization.  The default value is 1.

    PARAM
          A structure containing the following parameters used to
          define the behavior of solver.  Missing elements in the
          structure take on default values, so you only need to set the
          elements that you wish to change from the default.

          Integer parameters:

         `msglev (`LPX_K_MSGLEV', default: 1)'
               Level of messages output by solver routines:
              0
                    No output.

              1
                    Error messages only.

              2
                    Normal output .

              3
                    Full output (includes informational messages).

         `scale (`LPX_K_SCALE', default: 1)'
               Scaling option:
              0
                    No scaling.

              1
                    Equilibration scaling.

              2
                    Geometric mean scaling, then equilibration scaling.

         `dual	 (`LPX_K_DUAL', default: 0)'
               Dual simplex option:
              0
                    Do not use the dual simplex.

              1
                    If initial basic solution is dual feasible, use the
                    dual simplex.

         `price	 (`LPX_K_PRICE', default: 1)'
               Pricing option (for both primal and dual simplex):
              0
                    Textbook pricing.

              1
                    Steepest edge pricing.

         `round	 (`LPX_K_ROUND', default: 0)'
               Solution rounding option:
              0
                    Report all primal and dual values "as is".

              1
                    Replace tiny primal and dual values by exact zero.

         `itlim	 (`LPX_K_ITLIM', default: -1)'
               Simplex iterations limit.  If this value is positive, it
               is decreased by one each time when one simplex iteration
               has been performed, and reaching zero value signals the
               solver to stop the search.  Negative value means no
               iterations limit.

         `itcnt (`LPX_K_OUTFRQ', default: 200)'
               Output frequency, in iterations.  This parameter
               specifies how frequently the solver sends information
               about the solution to the standard output.

         `branch (`LPX_K_BRANCH', default: 2)'
               Branching heuristic option (for MIP only):
              0
                    Branch on the first variable.

              1
                    Branch on the last variable.

              2
                    Branch using a heuristic by Driebeck and Tomlin.

         `btrack (`LPX_K_BTRACK', default: 2)'
               Backtracking heuristic option (for MIP only):
              0
                    Depth first search.

              1
                    Breadth first search.

              2
                    Backtrack using the best projection heuristic.

         `presol (`LPX_K_PRESOL', default: 1)'
               If this flag is set, the routine lpx_simplex solves the
               problem using the built-in LP presolver.  Otherwise the
               LP presolver is not used.

         `lpsolver (default: 1)'
               Select which solver to use.  If the problem is a MIP
               problem this flag will be ignored.
              1
                    Revised simplex method.

              2
                    Interior point method.

         `save (default: 0)'
               If this parameter is nonzero, save a copy of the problem
               in CPLEX LP format to the file `"outpb.lp"'.  There is
               currently no way to change the name of the output file.

          Real parameters:

         `relax (`LPX_K_RELAX', default: 0.07)'
               Relaxation parameter used in the ratio test.  If it is
               zero, the textbook ratio test is used.  If it is
               non-zero (should be positive), Harris' two-pass ratio
               test is used.  In the latter case on the first pass of
               the ratio test basic variables (in the case of primal
               simplex) or reduced costs of non-basic variables (in the
               case of dual simplex) are allowed to slightly violate
               their bounds, but not more than `relax*tolbnd' or
               `relax*toldj (thus, `relax' is a percentage of `tolbnd'
               or `toldj''.

         `tolbnd (`LPX_K_TOLBND', default: 10e-7)'
               Relative tolerance used to check if the current basic
               solution is primal feasible.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

         `toldj (`LPX_K_TOLDJ', default: 10e-7)'
               Absolute tolerance used to check if the current basic
               solution is dual feasible.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

         `tolpiv (`LPX_K_TOLPIV', default: 10e-9)'
               Relative tolerance used to choose eligible pivotal
               elements of the simplex table.  It is not recommended
               that you change this parameter unless you have a
               detailed understanding of its purpose.

         `objll (`LPX_K_OBJLL', default: -DBL_MAX)'
               Lower limit of the objective function.  If on the phase
               II the objective function reaches this limit and
               continues decreasing, the solver stops the search.  This
               parameter is used in the dual simplex method only.

         `objul (`LPX_K_OBJUL', default: +DBL_MAX)'
               Upper limit of the objective function.  If on the phase
               II the objective function reaches this limit and
               continues increasing, the solver stops the search.  This
               parameter is used in the dual simplex only.

         `tmlim (`LPX_K_TMLIM', default: -1.0)'
               Searching time limit, in seconds.  If this value is
               positive, it is decreased each time when one simplex
               iteration has been performed by the amount of time spent
               for the iteration, and reaching zero value signals the
               solver to stop the search.  Negative value means no time
               limit.

         `outdly (`LPX_K_OUTDLY', default: 0.0)'
               Output delay, in seconds.  This parameter specifies how
               long the solver should delay sending information about
               the solution to the standard output.  Non-positive value
               means no delay.

         `tolint (`LPX_K_TOLINT', default: 10e-5)'
               Relative tolerance used to check if the current basic
               solution is integer feasible.  It is not recommended
               that you change this parameter unless you have a
               detailed understanding of its purpose.

         `tolobj (`LPX_K_TOLOBJ', default: 10e-7)'
               Relative tolerance used to check if the value of the
               objective function is not better than in the best known
               integer feasible solution.  It is not recommended that
               you change this parameter unless you have a detailed
               understanding of its purpose.

     Output values:

    XOPT
          The optimizer (the value of the decision variables at the
          optimum).

    FOPT
          The optimum value of the objective function.

    STATUS
          Status of the optimization.

          Simplex Method:
         180 (`LPX_OPT')
               Solution is optimal.

         181 (`LPX_FEAS')
               Solution is feasible.

         182 (`LPX_INFEAS')
               Solution is infeasible.

         183 (`LPX_NOFEAS')
               Problem has no feasible solution.

         184 (`LPX_UNBND')
               Problem has no unbounded solution.

         185 (`LPX_UNDEF')
               Solution status is undefined.
          Interior Point Method:
         150 (`LPX_T_UNDEF')
               The interior point method is undefined.

         151 (`LPX_T_OPT')
               The interior point method is optimal.
          Mixed Integer Method:
         170 (`LPX_I_UNDEF')
               The status is undefined.

         171 (`LPX_I_OPT')
               The solution is integer optimal.

         172 (`LPX_I_FEAS')
               Solution integer feasible but its optimality has not
               been proven

         173 (`LPX_I_NOFEAS')
               No integer feasible solution.
          If an error occurs, STATUS will contain one of the following
          codes:

         204 (`LPX_E_FAULT')
               Unable to start the search.

         205 (`LPX_E_OBJLL')
               Objective function lower limit reached.

         206 (`LPX_E_OBJUL')
               Objective function upper limit reached.

         207 (`LPX_E_ITLIM')
               Iterations limit exhausted.

         208 (`LPX_E_TMLIM')
               Time limit exhausted.

         209 (`LPX_E_NOFEAS')
               No feasible solution.

         210 (`LPX_E_INSTAB')
               Numerical instability.

         211 (`LPX_E_SING')
               Problems with basis matrix.

         212 (`LPX_E_NOCONV')
               No convergence (interior).

         213 (`LPX_E_NOPFS')
               No primal feasible solution (LP presolver).

         214 (`LPX_E_NODFS')
               No dual feasible solution (LP presolver).

    EXTRA
          A data structure containing the following fields:
         `lambda'
               Dual variables.

         `redcosts'
               Reduced Costs.

         `time'
               Time (in seconds) used for solving LP/MIP problem.

         `mem'
               Memory (in bytes) used for solving LP/MIP problem (this
               is not available if the version of GLPK is 4.15 or
               later).

     Example:

          c = [10, 6, 4]';
          a = [ 1, 1, 1;
               10, 4, 5;
                2, 2, 6];
          b = [100, 600, 300]';
          lb = [0, 0, 0]';
          ub = [];
          ctype = "UUU";
          vartype = "CCC";
          s = -1;

          param.msglev = 1;
          param.itlim = 100;

          [xmin, fmin, status, extra] = ...
             glpk (c, a, b, lb, ub, ctype, vartype, s, param);
}

#
glpkmex
{
`glpkmex' is a function from the file /usr/share/octave/3.2.3/m/optimization/glpkmex.m

 -- Function File: [XOPT, FMIN, STATUS, EXTRA] = glpkmex (SENSE, C, A,
          B, CTYPE, LB, UB, VARTYPE, PARAM, LPSOLVER, SAVE_PB)
     This function is provided for compatibility with the old MATLAB
     interface to the GNU GLPK library.  For Octave code, you should use
     the `glpk' function instead.
}

#
gls
{
`gls' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/gls.m

 -- Function File: [BETA, V, R] = gls (Y, X, O)
     Generalized least squares estimation for the multivariate model y
     = x b + e with mean (e) = 0 and cov (vec (e)) = (s^2) o,  where y
     is a t by p matrix, x is a t by k matrix, b is a k by p matrix, e
     is a t by p matrix, and o is a t p by t p matrix.

     Each row of Y and X is an observation and each column a variable.
     The return values BETA, V, and R are defined as follows.

    BETA
          The GLS estimator for b.

    V
          The GLS estimator for s^2.

    R
          The matrix of GLS residuals, r = y - x beta.
}

#
gmap40
{
`gmap40' is a function from the file /usr/share/octave/3.2.3/m/image/gmap40.m

 -- Function File:  gmap40 (N)
     Create a color colormap.  The colormap is red, green, blue, yellow,
     magenta and cyan.  These are the colors that are allowed with patch
     objects using gnuplot 4.0, and so this colormap function is
     specially designed for users of gnuplot 4.0.  The argument N
     should be a scalar.  If it is omitted, a length of 6 is assumed.
     Larger values of N result in a repetition of the above colors

     See also: colormap
}

#
gmtime
{
`gmtime' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/time.oct

 -- Loadable Function:  gmtime (T)
     Given a value returned from time (or any non-negative integer),
     return a time structure corresponding to CUT.  For example,

          gmtime (time ())
              => {
                    usec = 0
                    year = 97
                    mon = 1
                    mday = 17
                    sec = 6
                    zone = CST
                    min = 15
                    wday = 1
                    hour = 7
                    isdst = 0
                    yday = 47
                  }

     See also: strftime, strptime, localtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday
}

#
gnuplot_binary
{
`gnuplot_binary' is a function from the file /usr/share/octave/3.2.3/m/plot/gnuplot_binary.m

 -- Loadable Function: VAL = gnuplot_binary ()
 -- Loadable Function: OLD_VAL = gnuplot_binary (NEW_VAL)
     Query or set the name of the program invoked by the plot command.
     The default value `\"gnuplot\"'.  *Note Installation::.
}

#
gnuplot_drawnow
{
`gnuplot_drawnow' is a function from the file /usr/share/octave/3.2.3/m/plot/gnuplot_drawnow.m

 -- Function File:  drawnow ()
     Update and display the current graphics.

     Octave automatically calls drawnow just before printing a prompt,
     when `sleep' or `pause' is called, or while waiting for
     command-line input.
}

#
gplot
{
`gplot' is a function from the file /usr/share/octave/3.2.3/m/sparse/gplot.m

 -- Function File:  gplot (A, XY)
 -- Function File:  gplot (A, XY, LINE_STYLE)
 -- Function File: [X, Y] = gplot (A, XY)
     Plot a graph defined by A and XY in the graph theory sense.  A is
     the adjacency matrix of the array to be plotted and XY is an
     N-by-2 matrix containing the coordinates of the nodes of the graph.

     The optional parameter LINE_STYLE defines the output style for the
     plot.  Called with no output arguments the graph is plotted
     directly.  Otherwise, return the coordinates of the plot in X and
     Y.

     See also: treeplot, etreeplot, spy
}

#
gradient
{
`gradient' is a function from the file /usr/share/octave/3.2.3/m/general/gradient.m

 -- Function File: DX = gradient (M)
 -- Function File: [DX, DY, DZ, ...] = gradient (M)
 -- Function File: [...] = gradient (M, S)
 -- Function File: [...] = gradient (M, X, Y, Z, ...)
 -- Function File: [...] = gradient (F, X0)
 -- Function File: [...] = gradient (F, X0, S)
 -- Function File: [...] = gradient (F, X0, X, Y, ...)
     Calculate the gradient of sampled data or a function.  If M is a
     vector, calculate the one-dimensional gradient of M.  If M is a
     matrix the gradient is calculated for each dimension.

     `[DX, DY] = gradient (M)' calculates the one dimensional gradient
     for X and Y direction if M is a matrix.  Additional return
     arguments can be use for multi-dimensional matrices.

     A constant spacing between two points can be provided by the S
     parameter.  If S is a scalar, it is assumed to be the spacing for
     all dimensions.  Otherwise, separate values of the spacing can be
     supplied by the X, ... arguments.  Scalar values specify an
     equidistant spacing.  Vector values for the X, ... arguments
     specify the coordinate for that dimension.  The length must match
     their respective dimension of M.

     At boundary points a linear extrapolation is applied.  Interior
     points are calculated with the first approximation of the
     numerical gradient

          y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).

     If the first argument F is a function handle, the gradient of the
     function at the points in X0 is approximated using central
     difference.  For example, `gradient (@cos, 0)' approximates the
     gradient of the cosine function in the point x0 = 0.  As with
     sampled data, the spacing values between the points from which the
     gradient is estimated can be set via the S or DX, DY, ...
     arguments.  By default a spacing of 1 is used.

     See also: diff, del2
}

#
gray
{
`gray' is a function from the file /usr/share/octave/3.2.3/m/image/gray.m

 -- Function File:  gray (N)
     Return a gray colormap with N entries corresponding to values from
     0 to N-1.  The argument N should be a scalar.  If it is omitted,
     the length of the current colormap or 64 is assumed.
}

#
gray2ind
{
`gray2ind' is a function from the file /usr/share/octave/3.2.3/m/image/gray2ind.m

 -- Function File: [IMG, MAP] = gray2ind (I, N)
     Convert a gray scale intensity image to an Octave indexed image.
     The indexed image will consist of N different intensity values.
     If not given N will default to 64.
}

#
grid
{
`grid' is a function from the file /usr/share/octave/3.2.3/m/plot/grid.m

 -- Function File:  grid (ARG)
 -- Function File:  grid ("minor", ARG2)
 -- Function File:  grid (HAX, ...)
     Force the display of a grid on the plot.  The argument may be
     either `"on"', or `"off"'.  If it is omitted, the current grid
     state is toggled.

     If ARG is `"minor"' then the minor grid is toggled.  When using a
     minor grid a second argument ARG2 is allowed, which can be either
     `"on"' or `"off"' to explicitly set the state of the minor grid.

     If the first argument is an axis handle, HAX, operate on the
     specified axis object.

     See also: plot
}

#
griddata
{
`griddata' is a function from the file /usr/share/octave/3.2.3/m/geometry/griddata.m

 -- Function File: ZI = griddata (X, Y, Z, XI, YI, METHOD)
 -- Function File: [XI, YI, ZI] = griddata (X, Y, Z, XI, YI, METHOD)
     Generate a regular mesh from irregular data using interpolation.
     The function is defined by `Z = f (X, Y)'.  The interpolation
     points are all `(XI, YI)'.  If XI, YI are vectors then they are
     made into a 2D mesh.

     The interpolation method can be `"nearest"', `"cubic"' or
     `"linear"'.  If method is omitted it defaults to `"linear"'.

     See also: delaunay
}

#
griddata3
{
`griddata3' is a function from the file /usr/share/octave/3.2.3/m/geometry/griddata3.m

 -- Function File: VI = griddata3 (X, Y, Z, V XI, YI, ZI, METHOD,
          OPTIONS)
     Generate a regular mesh from irregular data using interpolation.
     The function is defined by `Y = f (X,Y,Z)'.  The interpolation
     points are all XI.

     The interpolation method can be `"nearest"' or `"linear"'.  If
     method is omitted it defaults to `"linear"'.

     See also: griddata, delaunayn
}

#
griddatan
{
`griddatan' is a function from the file /usr/share/octave/3.2.3/m/geometry/griddatan.m

 -- Function File: YI = griddatan (X, Y, XI, METHOD, OPTIONS)
     Generate a regular mesh from irregular data using interpolation.
     The function is defined by `Y = f (X)'.  The interpolation points
     are all XI.

     The interpolation method can be `"nearest"' or `"linear"'.  If
     method is omitted it defaults to `"linear"'.

     See also: griddata, delaunayn
}

#
gt
{
`gt' is a built-in function

 -- Built-in Function:  gt (X, Y)
     This function is equivalent to `x > y'.
}

#
gtext
{
`gtext' is a function from the file /usr/share/octave/3.2.3/m/plot/gtext.m

 -- Function File:  gtext (S)
 -- Function File:  gtext ({S1; S2; ...})
 -- Function File:  gtext (..., PROP, VAL)
     Place text on the current figure using the mouse.  The text is
     defined by the string S.  If S is a cell array, each element of
     the cell array is written to a separate line.  Additional
     arguments are passed to the underlying text object as properties.

     See also: ginput, text
}

#
gunzip
{
`gunzip' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/gunzip.m

 -- Function File:  gunzip (GZFILE, DIR)
     Unpack the gzip archive GZFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.  If the
     GZFILE is a directory, all files in the directory will be
     recursively gunzipped.

     See also: unpack, bunzip2, tar, untar, gzip, gunzip, zip, unzip
}

#
gzip
{
`gzip' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/gzip.m

 -- Function File: ENTRIES = gzip (FILES)
 -- Function File: ENTRIES = gzip (FILES, OUTDIR)
     Compress the list of files and/or directories specified in FILES.
     Each file is compressed separately and a new file with a '.gz'
     extension is created.  The original files are not touched.
     Existing compressed files are silently overwritten.  If OUTDIR is
     defined the compressed versions of the files are placed in this
     directory.

     See also: gunzip, bzip2, zip, tar
}

#
hadamard
{
`hadamard' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/hadamard.m

 -- Function File:  hadamard (N)
     Construct a Hadamard matrix HN of size N-by-N.  The size N must be
     of the form `2 ^ K * P' in which P is one of 1, 12, 20 or 28.  The
     returned matrix is normalized, meaning `Hn(:,1) == 1' and `H(1,:)
     == 1'.

     Some of the properties of Hadamard matrices are:

        * `kron (HM, HN)' is a Hadamard matrix of size M-by-N.

        * `Hn * Hn' == N * eye (N)'.

        * The rows of HN are orthogonal.

        * `det (A) <= abs(det (HN))' for all A with `abs (A (I, J)) <=
          1'.

        * Multiply any row or column by -1 and still have a Hadamard
          matrix.
}

#
hamming
{
`hamming' is a function from the file /usr/share/octave/3.2.3/m/signal/hamming.m

 -- Function File:  hamming (M)
     Return the filter coefficients of a Hamming window of length M.

     For a definition of the Hamming window, see e.g., A. V. Oppenheim &
     R. W. Schafer, `Discrete-Time Signal Processing'.
}

#
hankel
{
`hankel' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/hankel.m

 -- Function File:  hankel (C, R)
     Return the Hankel matrix constructed given the first column C, and
     (optionally) the last row R.  If the last element of C is not the
     same as the first element of R, the last element of C is used.  If
     the second argument is omitted, it is assumed to be a vector of
     zeros with the same size as C.

     A Hankel matrix formed from an m-vector C, and an n-vector R, has
     the elements

          H(i,j) = c(i+j-1),  i+j-1 <= m;
          H(i,j) = r(i+j-m),  otherwise

     See also: vander, sylvester_matrix, hilb, invhilb, toeplitz
}

#
hanning
{
`hanning' is a function from the file /usr/share/octave/3.2.3/m/signal/hanning.m

 -- Function File:  hanning (M)
     Return the filter coefficients of a Hanning window of length M.

     For a definition of this window type, see e.g., A. V. Oppenheim &
     R. W. Schafer, `Discrete-Time Signal Processing'.
}

#
help
{
`help' is a function from the file /usr/share/octave/3.2.3/m/help/help.m

 -- Command: help NAME
     Display the help text for NAME.  If invoked without any arguments,
     `help' prints a list of all the available operators and functions.

     For example, the command `help help' prints a short message
     describing the `help' command.

     The help command can give you information about operators, but not
     the comma and semicolons that are used as command separators.  To
     get help for those, you must type `help comma' or `help semicolon'.

     See also: doc, lookfor, which
}

#
hess
{
`hess' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/hess.oct

 -- Loadable Function: H = hess (A)
 -- Loadable Function: [P, H] = hess (A)
     Compute the Hessenberg decomposition of the matrix A.

     The Hessenberg decomposition is usually used as the first step in
     an eigenvalue computation, but has other applications as well (see
     Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control,
     1979).  The Hessenberg decomposition is `p * h * p' = a' where `p'
     is a square unitary matrix (`p' * p = I', using complex-conjugate
     transposition) and `h' is upper Hessenberg (`i >= j+1 => h (i, j)
     = 0').
}

#
hex2dec
{
`hex2dec' is a function from the file /usr/share/octave/3.2.3/m/strings/hex2dec.m

 -- Function File:  hex2dec (S)
     Return the integer corresponding to the hexadecimal number stored
     in the string S.  For example,

          hex2dec ("12B")
               => 299
          hex2dec ("12b")
               => 299

     If S is a string matrix, returns a column vector of converted
     numbers, one per row of S.  Invalid rows evaluate to NaN.

     See also: dec2hex, base2dec, dec2base, bin2dec, dec2bin
}

#
hex2num
{
`hex2num' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/hex2num.oct

 -- Loadable Function: N = hex2num (S)
     Typecast the 16 character hexadecimal character matrix to an IEEE
     754 double precision number.  If fewer than 16 characters are
     given the strings are right padded with '0' characters.

     Given a string matrix, `hex2num' treats each row as a separate
     number.

          hex2num (["4005bf0a8b145769";"4024000000000000"])
          => [2.7183; 10.000]

     See also: num2hex, hex2dec, dec2hex
}

#
hggroup
{
`hggroup' is a function from the file /usr/share/octave/3.2.3/m/plot/hggroup.m

 -- Function File:  hggroup ()
 -- Function File:  hggroup (H)
 -- Function File:  hggroup (..., PROPERTY, VALUE, ...)
     Create group object with parent H.  If no parent is specified, the
     group is created in the current axes.  Return the handle of the
     group object created.

     Multiple property-value pairs may be specified for the group, but
     they must appear in pairs.
}

#
hidden
{
`hidden' is a function from the file /usr/share/octave/3.2.3/m/plot/hidden.m

 -- Function File:  hidden (MODE)
 -- Function File:  hidden ()
     Manipulation the mesh hidden line removal.  Called with no argument
     the hidden line removal is toggled.  The argument MODE can be
     either 'on' or 'off' and the set of the hidden line removal is set
     accordingly.

     See also: mesh, meshc, surf
}

#
hilb
{
`hilb' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/hilb.m

 -- Function File:  hilb (N)
     Return the Hilbert matrix of order N.  The i, j element of a
     Hilbert matrix is defined as

          H (i, j) = 1 / (i + j - 1)

     See also: hankel, vander, sylvester_matrix, invhilb, toeplitz
}

#
hist
{
`hist' is a function from the file /usr/share/octave/3.2.3/m/plot/hist.m

 -- Function File:  hist (Y, X, NORM)
     Produce histogram counts or plots.

     With one vector input argument, plot a histogram of the values with
     10 bins.  The range of the histogram bins is determined by the
     range of the data.  With one matrix input argument, plot a
     histogram where each bin contains a bar per input column.

     Given a second scalar argument, use that as the number of bins.

     Given a second vector argument, use that as the centers of the
     bins, with the width of the bins determined from the adjacent
     values in the vector.

     If third argument is provided, the histogram is normalized such
     that the sum of the bars is equal to NORM.

     Extreme values are lumped in the first and last bins.

     With two output arguments, produce the values NN and XX such that
     `bar (XX, NN)' will plot the histogram.

     See also: bar
}

#
histc
{
`histc' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/histc.m

 -- Function File: N = histc (Y, EDGES)
 -- Function File: N = histc (Y, EDGES, DIM)
 -- Function File: [N, IDX] = histc (...)
     Produce histogram counts.

     When Y is a vector, the function counts the number of elements of
     Y that fall in the histogram bins defined by EDGES.  This must be
     a vector of monotonically non-decreasing values that define the
     edges of the histogram bins.  So, `N (k)' contains the number of
     elements in Y for which `EDGES (k) <= Y < EDGES (k+1)'.  The final
     element of N contains the number of elements of Y that was equal
     to the last element of EDGES.

     When Y is a N-dimensional array, the same operation as above is
     repeated along dimension DIM.  If this argument is given, the
     operation is performed along the first non-singleton dimension.

     If a second output argument is requested an index matrix is also
     returned.  The IDX matrix has same size as Y.  Each element of IDX
     contains the index of the histogram bin in which the corresponding
     element of Y was counted.

     See also: hist
}

#
history
{
`history' is a built-in function

 -- Command: history options
     If invoked with no arguments, `history' displays a list of commands
     that you have executed.  Valid options are:

    `-w FILE'
          Write the current history to the file FILE.  If the name is
          omitted, use the default history file (normally
          `~/.octave_hist').

    `-r FILE'
          Read the file FILE, replacing the current history list with
          its contents.  If the name is omitted, use the default
          history file (normally `~/.octave_hist').

    `N'
          Display only the most recent N lines of history.

    `-q'
          Don't number the displayed lines of history.  This is useful
          for cutting and pasting commands using the X Window System.

     For example, to display the five most recent commands that you have
     typed without displaying line numbers, use the command `history -q
     5'.
}

#
history_file
{
`history_file' is a built-in function

 -- Built-in Function: VAL = history_file ()
 -- Built-in Function: OLD_VAL = history_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     file used to store command history.  The default value is
     `~/.octave_hist', but may be overridden by the environment
     variable `OCTAVE_HISTFILE'.

     See also: history_size, saving_history,
     history_timestamp_format_string
}

#
history_size
{
`history_size' is a built-in function

 -- Built-in Function: VAL = history_size ()
 -- Built-in Function: OLD_VAL = history_size (NEW_VAL)
     Query or set the internal variable that specifies how many entries
     to store in the history file.  The default value is `1024', but
     may be overridden by the environment variable `OCTAVE_HISTSIZE'.

     See also: history_file, history_timestamp_format_string,
     saving_history
}

#
history_timestamp_format_string
{
`history_timestamp_format_string' is a built-in function

 -- Built-in Function: VAL = history_timestamp_format_string ()
 -- Built-in Function: OLD_VAL = history_timestamp_format_string
          (NEW_VAL)
     Query or set the internal variable that specifies the format string
     for the comment line that is written to the history file when
     Octave exits.  The format string is passed to `strftime'.  The
     default value is

          "# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     See also: strftime, history_file, history_size, saving_history
}

#
hold
{
`hold' is a function from the file /usr/share/octave/3.2.3/m/plot/hold.m

 -- Function File:  hold
 -- Function File:  hold STATE
 -- Function File:  hold (HAX, ...)
     Toggle or set the 'hold' state of the plotting engine which
     determines whether new graphic objects are added to the plot or
     replace the existing objects.

    `hold on'
          Retain plot data and settings so that subsequent plot
          commands are displayed on a single graph.

    `hold off'
          Clear plot and restore default graphics settings before each
          new plot command.  (default).

    `hold'
          Toggle the current 'hold' state.

     When given the additional argument HAX, the hold state is modified
     only for the given axis handle.

     To query the current 'hold' state use the `ishold' function.

     See also: ishold, cla, newplot, clf
}

#
home
{
`home' is a built-in function

 -- Built-in Function:  clc ()
 -- Built-in Function:  home ()
     Clear the terminal screen and move the cursor to the upper left
     corner.
}

#
horzcat
{
`horzcat' is a built-in function

 -- Built-in Function:  horzcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the horizontal concatenation of N-d array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 2.

     See also: cat, vertcat
}

#
hot
{
`hot' is a function from the file /usr/share/octave/3.2.3/m/image/hot.m

 -- Function File:  hot (N)
     Create color colormap.  This colormap is black through dark red,
     red, orange, yellow to white.  The argument N should be a scalar.
     If it is omitted, the length of the current colormap or 64 is
     assumed.

     See also: colormap
}

#
hotelling_test
{
`hotelling_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/hotelling_test.m

 -- Function File: [PVAL, TSQ] = hotelling_test (X, M)
     For a sample X from a multivariate normal distribution with unknown
     mean and covariance matrix, test the null hypothesis that `mean
     (X) == M'.

     Hotelling's T^2 is returned in TSQ.  Under the null, (n-p) T^2 /
     (p(n-1)) has an F distribution with p and n-p degrees of freedom,
     where n and p are the numbers of samples and variables,
     respectively.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
hotelling_test_2
{
`hotelling_test_2' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/hotelling_test_2.m

 -- Function File: [PVAL, TSQ] = hotelling_test_2 (X, Y)
     For two samples X from multivariate normal distributions with the
     same number of variables (columns), unknown means and unknown
     equal covariance matrices, test the null hypothesis `mean (X) ==
     mean (Y)'.

     Hotelling's two-sample T^2 is returned in TSQ.  Under the null,

          (n_x+n_y-p-1) T^2 / (p(n_x+n_y-2))

     has an F distribution with p and n_x+n_y-p-1 degrees of freedom,
     where n_x and n_y are the sample sizes and p is the number of
     variables.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
housh
{
`housh' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/housh.m

 -- Function File: [HOUSV, BETA, ZER] = housh (X, J, Z)
     Compute Householder reflection vector HOUSV to reflect X to be the
     j-th column of identity, i.e.,

          (I - beta*housv*housv')x =  norm(x)*e(j) if x(1) < 0,
          (I - beta*housv*housv')x = -norm(x)*e(j) if x(1) >= 0

     Inputs

    X
          vector

    J
          index into vector

    Z
          threshold for zero  (usually should be the number 0)

     Outputs (see Golub and Van Loan):

    BETA
          If beta = 0, then no reflection need be applied (zer set to 0)

    HOUSV
          householder vector
}

#
hsv
{
`hsv' is a function from the file /usr/share/octave/3.2.3/m/image/hsv.m

 -- Function File:  hsv (N)
     Create color colormap.  This colormap is red through yellow, green,
     cyan, blue, magenta to red.  It is obtained by linearly varying the
     hue through all possible values while keeping constant maximum
     saturation and value and is equivalent to `hsv2rgb
     ([linspace(0,1,N)', ones(N,2)])'.

     The argument N should be a scalar.  If it is omitted, the length
     of the current colormap or 64 is assumed.

     See also: colormap
}

#
hsv2rgb
{
`hsv2rgb' is a function from the file /usr/share/octave/3.2.3/m/image/hsv2rgb.m

 -- Function File: RGB_MAP = hsv2rgb (HSV_MAP)
     Transform a colormap or image from the hsv space to the rgb space.

     See also: rgb2hsv
}

#
hurst
{
`hurst' is a function from the file /usr/share/octave/3.2.3/m/signal/hurst.m

 -- Function File:  hurst (X)
     Estimate the Hurst parameter of sample X via the rescaled range
     statistic.  If X is a matrix, the parameter is estimated for every
     single column.
}

#
hygecdf
{
`hygecdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/hygecdf.m

 -- Function File:  hygecdf (X, T, M, N)
     Compute the cumulative distribution function (CDF) at X of the
     hypergeometric distribution with parameters T, M, and N.  This is
     the probability of obtaining not more than X marked items when
     randomly drawing a sample of size N without replacement from a
     population of total size T containing M marked items.

     The parameters T, M, and N must positive integers with M and N not
     greater than T.
}

#
hygeinv
{
`hygeinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/hygeinv.m

 -- Function File:  hygeinv (X, T, M, N)
     For each element of X, compute the quantile at X of the
     hypergeometric distribution with parameters T, M, and N.

     The parameters T, M, and N must positive integers with M and N not
     greater than T.
}

#
hygepdf
{
`hygepdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/hygepdf.m

 -- Function File:  hygepdf (X, T, M, N)
     Compute the probability density function (PDF) at X of the
     hypergeometric distribution with parameters T, M, and N.  This is
     the probability of obtaining X marked items when randomly drawing
     a sample of size N without replacement from a population of total
     size T containing M marked items.

     The arguments must be of common size or scalar.
}

#
hygernd
{
`hygernd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/hygernd.m

 -- Function File:  hygernd (T, M, N, R, C)
 -- Function File:  hygernd (T, M, N, SZ)
 -- Function File:  hygernd (T, M, N)
     Return an R by C matrix of random samples from the hypergeometric
     distribution with parameters T, M, and N.

     The parameters T, M, and N must positive integers with M and N not
     greater than T.

     The parameter SZ must be scalar or a vector of matrix dimensions.
     If SZ is scalar, then a SZ by SZ matrix of random samples is
     generated.
}

#
hypergeometric_cdf
{
`hypergeometric_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/hypergeometric_cdf.m

 -- Function File:  hypergeometric_cdf (X, M, T, N)
     Compute the cumulative distribution function (CDF) at X of the
     hypergeometric distribution with parameters M, T, and N.  This is
     the probability of obtaining not more than X marked items when
     randomly drawing a sample of size N without replacement from a
     population of total size T containing M marked items.

     The parameters M, T, and N must positive integers with M and N not
     greater than T.
}

#
hypergeometric_inv
{
`hypergeometric_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/hypergeometric_inv.m

 -- Function File:  hypergeometric_inv (X, M, T, N)
     For each element of X, compute the quantile at X of the
     hypergeometric distribution with parameters M, T, and N.

     The parameters M, T, and N must positive integers with M and N not
     greater than T.
}

#
hypergeometric_pdf
{
`hypergeometric_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/hypergeometric_pdf.m

 -- Function File:  hypergeometric_pdf (X, M, T, N)
     Compute the probability density function (PDF) at X of the
     hypergeometric distribution with parameters M, T, and N.  This is
     the probability of obtaining X marked items when randomly drawing
     a sample of size N without replacement from a population of total
     size T containing M marked items.

     The arguments must be of common size or scalar.
}

#
hypergeometric_rnd
{
`hypergeometric_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/hypergeometric_rnd.m

 -- Function File:  hypergeometric_rnd (M, T, N, R, C)
 -- Function File:  hygernd (M, T, N, SZ)
     Return an R by C matrix of random samples from the hypergeometric
     distribution with parameters M, T, and N.

     The parameters M, T, and N must positive integers with M and N not
     greater than T.
}

#
hypot
{
`hypot' is a built-in function

 -- Built-in Function:  hypot (X, Y)
     Compute the element-by-element square root of the sum of the
     squares of X and Y.  This is equivalent to `sqrt (X.^2 + Y.^2)',
     but calculated in a manner that avoids overflows for large values
     of X or Y.
}

#
i
{
`i' is a built-in function

 -- Built-in Function:  I
 -- Built-in Function:  I (N)
 -- Built-in Function:  I (N, M)
 -- Built-in Function:  I (N, M, K, ...)
 -- Built-in Function:  I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as `sqrt (-1)'.  I,
     and its equivalents i, J, and j, are functions so any of the names
     may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".
}

#
idivide
{
`idivide' is a function from the file /usr/share/octave/3.2.3/m/general/idivide.m

 -- Function File:  idivide (X, Y, OP)
     Integer division with different round rules.  The standard
     behavior of the an integer division such as `A ./ B' is to round
     the result to the nearest integer.  This is not always the desired
     behavior and `idivide' permits integer element-by-element division
     to be performed with different treatment for the fractional part
     of the division as determined by the OP flag.  OP is a string with
     one of the values:

    "fix"
          Calculate `A ./ B' with the fractional part rounded towards
          zero.

    "round"
          Calculate `A ./ B' with the fractional part rounded towards
          the nearest integer.

    "floor"
          Calculate `A ./ B' with the fractional part rounded downwards.

    "ceil"
          Calculate `A ./ B' with the fractional part rounded upwards.

     If OP is not given it is assumed that it is `"fix"'.  An example
     demonstrating these rounding rules is

          idivide (int8 ([-3, 3]), int8 (4), "fix")
          => int8 ([0, 0])
          idivide (int8 ([-3, 3]), int8 (4), "round")
          => int8 ([-1, 1])
          idivide (int8 ([-3, 3]), int8 (4), "ceil")
          => int8 ([0, 1])
          idivide (int8 ([-3, 3]), int8 (4), "floor")
          => int8 ([-1, 0])

     See also: ldivide, rdivide
}

#
if
{

 -- Keyword: if (COND) ... endif
 -- Keyword: if (COND) ... else ... endif
 -- Keyword: if (COND) ... elseif (COND) ... endif
 -- Keyword: if (COND) ... elseif (COND) ... else ... endif
     Begin an if block.
          x = 1;
          if (x == 1)
           disp ("one");
          elseif (x == 2)
           disp ("two");
          else
           disp ("not one or two");
          endif

     See also: switch
}

#
ifft
{
`ifft' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fft.oct

 -- Loadable Function:  ifft (A, N, DIM)
     Compute the inverse FFT of A using subroutines from FFTW.  The
     inverse FFT is calculated along the first non-singleton dimension
     of the array.  Thus if A is a matrix, `fft (A)' computes the
     inverse FFT for each column of A.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of A to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the inverse FFT is calculated, then A is
     resized and padded with zeros.  Otherwise, ifN is smaller than the
     dimension along which the inverse FFT is calculated, then A is
     truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the inverse FFT is performed

     See also: fft, ifft2, ifftn, fftw
}

#
ifft2
{
`ifft2' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fft2.oct

 -- Loadable Function:  fft2 (A, N, M)
     Compute the inverse two-dimensional FFT of A using subroutines from
     FFTW.  The optional arguments N and M may be used specify the
     number of rows and columns of A to use.  If either of these is
     larger than the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately

     See also: fft2, ifft, ifftn, fftw
}

#
ifftn
{
`ifftn' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/fftn.oct

 -- Loadable Function:  ifftn (A, SIZE)
     Compute the inverse N-dimensional FFT of A using subroutines from
     FFTW.  The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension, then the dimension is
     truncated prior to performing the inverse FFT.  Otherwise if an
     element of SIZE is larger than the corresponding dimension A is
     resized and padded with zeros.

     See also: fftn, ifft, ifft2, fftw
}

#
ifftshift
{
`ifftshift' is a function from the file /usr/share/octave/3.2.3/m/signal/ifftshift.m

 -- Function File:  ifftshift (V)
 -- Function File:  ifftshift (V, DIM)
     Undo the action of the `fftshift' function.  For even length V,
     `fftshift' is its own inverse, but odd lengths differ slightly.
}

#
ignore_function_time_stamp
{
`ignore_function_time_stamp' is a built-in function

 -- Built-in Function: VAL = ignore_function_time_stamp ()
 -- Built-in Function: OLD_VAL = ignore_function_time_stamp (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     checks the time stamp on files each time it looks up functions
     defined in function files.  If the internal variable is set to
     `"system"', Octave will not automatically recompile function files
     in subdirectories of `OCTAVE-HOME/lib/VERSION' if they have
     changed since they were last compiled, but will recompile other
     function files in the search path if they change.  If set to
     `"all"', Octave will not recompile any function files unless their
     definitions are removed with `clear'.  If set to "none", Octave
     will always check time stamps on files to determine whether
     functions defined in function files need to recompiled.
}

#
imag
{
`imag' is a built-in function

 -- Mapping Function:  imag (Z)
     Return the imaginary part of Z as a real number.

     See also: real, conj
}

#
image
{
`image' is a function from the file /usr/share/octave/3.2.3/m/image/image.m

 -- Function File:  image (IMG)
 -- Function File:  image (X, Y, IMG)
     Display a matrix as a color image.  The elements of X are indices
     into the current colormap, and the colormap will be scaled so that
     the extremes of X are mapped to the extremes of the colormap.

     It first tries to use `gnuplot', then `display' from
     `ImageMagick', then `xv', and then `xloadimage'.  The actual
     program used can be changed using the `image_viewer' function.

     The axis values corresponding to the matrix elements are specified
     in X and Y.  If you're not using gnuplot 4.2 or later, these
     variables are ignored.

     See also: imshow, imagesc, colormap, image_viewer
}

#
image_viewer
{
`image_viewer' is a function from the file /usr/share/octave/3.2.3/m/image/image_viewer.m

 -- Function File: [FCN, DEFAULT_ZOOM] = image_viewer (FCN,
          DEFAULT_ZOOM)
     Change the program or function used for viewing images and return
     the previous values.

     When the `image' or `imshow' function is called it will launch an
     external program to display the image.  The default behavior is to
     use gnuplot if the installed version supports image viewing, and
     otherwise try the programs `display', `xv', and `xloadimage'.
     Using this function it is possible to change that behavior.

     When called with one input argument images will be displayed by
     saving the image to a file and the system command COMMAND will be
     called to view the image.  The COMMAND must be a string containing
     `%s' and possibly `%f'.  The `%s' will be replaced by the filename
     of the image, and the `%f' will (if present) be replaced by the
     zoom factor given to the `image' function.  For example,
          image_viewer ("eog %s");
     changes the image viewer to the `eog' program.

     With two input arguments, images will be displayed by calling the
     function FUNCTION_HANDLE.  For example,
          image_viewer (data, @my_image_viewer);
     sets the image viewer function to `my_image_viewer'.  The image
     viewer function is called with
          my_image_viewer (X, Y, IM, ZOOM, DATA)
     where X and Y are the axis of the image, IM is the image variable,
     and DATA is extra user-supplied data to be passed to the viewer
     function.

     With three input arguments it is possible to change the zooming.
     Some programs (like `xloadimage') require the zoom factor to be
     between 0 and 100, and not 0 and 1 like Octave assumes.  This is
     solved by setting the third argument to 100.

     See also: image, imshow
}

#
imagesc
{
`imagesc' is a function from the file /usr/share/octave/3.2.3/m/image/imagesc.m

 -- Function File:  imagesc (A)
 -- Function File:  imagesc (X, Y, A)
 -- Function File:  imagesc (..., LIMITS)
 -- Function File:  imagesc (H, ...)
 -- Function File: H = imagesc (...)
     Display a scaled version of the matrix A as a color image.  The
     colormap is scaled so that the entries of the matrix occupy the
     entire colormap.  If LIMITS = [LO, HI] are given, then that range
     is set to the 'clim' of the current axes.

     The axis values corresponding to the matrix elements are specified
     in X and Y, either as pairs giving the minimum and maximum values
     for the respective axes, or as values for each row and column of
     the matrix A.

     See also: image, imshow, caxis
}

#
imfinfo
{
`imfinfo' is a function from the file /usr/share/octave/3.2.3/m/image/imfinfo.m

 -- Function File: INFO = imfinfo (FILENAME)
 -- Function File: INFO = imfinfo (URL)
     Read image information from a file.

     `imfinfo' returns a structure containing information about the
     image stored in the file FILENAME.  The output structure contains
     the following fields.

    `Filename'
          The full name of the image file.

    `FileSize'
          Number of bytes of the image on disk

    `FileModDate'
          Date of last modification to the file.

    `Height'
          Image height in pixels.

    `Width'
          Image Width in pixels.

    `BitDepth'
          Number of bits per channel per pixel.

    `Format'
          Image format (e.g., `"jpeg"').

    `LongFormat'
          Long form image format description.

    `XResolution'
          X resolution of the image.

    `YResolution'
          Y resolution of the image.

    `TotalColors'
          Number of unique colors in the image.

    `TileName'
          Tile name.

    `AnimationDelay'
          Time in 1/100ths of a second (0 to 65535) which must expire
          before displaying the next image in an animated sequence.

    `AnimationIterations'
          Number of iterations to loop an animation (e.g., Netscape
          loop extension) for.

    `ByteOrder'
          Endian option for formats that support it.  Is either
          `"little-endian"', `"big-endian"', or `"undefined"'.

    `Gamma'
          Gamma level of the image.  The same color image displayed on
          two different workstations may look different due to
          differences in the display monitor.

    `Matte'
          `true' if the image has transparency.

    `ModulusDepth'
          Image modulus depth (minimum number of bits required to
          support red/green/blue components without loss of accuracy).

    `Quality'
          JPEG/MIFF/PNG compression level.

    `QuantizeColors'
          Preferred number of colors in the image.

    `ResolutionUnits'
          Units of image resolution.  Is either `"pixels per inch"',
          `"pixels per centimeter"', or `"undefined"'.

    `ColorType'
          Image type.  Is either `"grayscale"', `"indexed"',
          `"truecolor"', or `"undefined"'.

    `View'
          FlashPix viewing parameters.

     See also: imread, imwrite
}

#
imread
{
`imread' is a function from the file /usr/share/octave/3.2.3/m/image/imread.m

 -- Function File: [IMG, MAP, ALPHA] = imread (FILENAME)
     Read images from various file formats.

     The size and numeric class of the output depends on the format of
     the image.  A color image is returned as an MxNx3 matrix.
     Grey-level and black-and-white images are of size MxN.  The color
     depth of the image determines the numeric class of the output:
     "uint8" or "uint16" for grey and color, and "logical" for black
     and white.

     See also: imwrite, imfinfo
}

#
imshow
{
`imshow' is a function from the file /usr/share/octave/3.2.3/m/image/imshow.m

 -- Function File:  imshow (IM)
 -- Function File:  imshow (IM, LIMITS)
 -- Function File:  imshow (IM, MAP)
 -- Function File:  imshow (RGB, ...)
 -- Function File:  imshow (FILENAME)
 -- Function File:  imshow (..., STRING_PARAM1, VALUE1, ...)
     Display the image IM, where IM can be a 2-dimensional (gray-scale
     image) or a 3-dimensional (RGB image) matrix.

     If LIMITS is a 2-element vector `[LOW, HIGH]', the image is shown
     using a display range between LOW and HIGH.  If an empty matrix is
     passed for LIMITS, the display range is computed as the range
     between the minimal and the maximal value in the image.

     If MAP is a valid color map, the image will be shown as an indexed
     image using the supplied color map.

     If a file name is given instead of an image, the file will be read
     and shown.

     If given, the parameter STRING_PARAM1 has value VALUE1.
     STRING_PARAM1 can be any of the following:
    `"displayrange"'
          VALUE1 is the display range as described above.

     See also: image, imagesc, colormap, gray2ind, rgb2ind
}

#
imwrite
{
`imwrite' is a function from the file /usr/share/octave/3.2.3/m/image/imwrite.m

 -- Function File:  imwrite (IMG, FILENAME, FMT, P1, V1, ...)
 -- Function File:  imwrite (IMG, MAP, FILENAME, FMT, P1, V1, ...)
     Write images in various file formats.

     If FMT is missing, the file extension (if any) of FILENAME is used
     to determine the format.

     The parameter-value pairs (P1, V1, ...) are optional.  Currently
     the following options are supported for JPEG images

    `Quality'
          Sets the quality of the compression.  The corresponding value
          should be an integer between 0 and 100, with larger values
          meaning higher visual quality and less compression.

     See also: imread, imfinfo
}

#
ind2gray
{
`ind2gray' is a function from the file /usr/share/octave/3.2.3/m/image/ind2gray.m

 -- Function File:  ind2gray (X, MAP)
     Convert an Octave indexed image to a gray scale intensity image.
     If MAP is omitted, the current colormap is used to determine the
     intensities.

     See also: gray2ind, rgb2ntsc, image, colormap
}

#
ind2rgb
{
`ind2rgb' is a function from the file /usr/share/octave/3.2.3/m/image/ind2rgb.m

 -- Function File: RGB = ind2rgb (X, MAP)
 -- Function File: [R, G, B] = ind2rgb (X, MAP)
     Convert an indexed image to red, green, and blue color components.
     If the colormap doesn't contain enough colors, pad it with the
     last color in the map.  If MAP is omitted, the current colormap is
     used for the conversion.

     See also: rgb2ind, image, imshow, ind2gray, gray2ind
}

#
ind2sub
{
`ind2sub' is a function from the file /usr/share/octave/3.2.3/m/general/ind2sub.m

 -- Function File: [S1, S2, ..., SN] = ind2sub (DIMS, IND)
     Convert a linear index into subscripts.

     The following example shows how to convert the linear index `8' in
     a 3-by-3 matrix into a subscript.  The matrix is linearly indexed
     moving from one column to next, filling up all rows in each column.
          [r, c] = ind2sub ([3, 3], 8)
          => r =  2
          c =  3

     See also: sub2ind
}

#
index
{
`index' is a function from the file /usr/share/octave/3.2.3/m/strings/index.m

 -- Function File:  index (S, T)
 -- Function File:  index (S, T, DIRECTION)
     Return the position of the first occurrence of the string T in the
     string S, or 0 if no occurrence is found.  For example,

          index ("Teststring", "t")
               => 4

     If DIRECTION is `"first"', return the first element found.  If
     DIRECTION is `"last"', return the last element found.  The
     `rindex' function is equivalent to `index' with DIRECTION set to
     `"last"'.

     *Caution:*  This function does not work for arrays of character
     strings.

     See also: find, rindex
}

#
inf
{
`inf' is a built-in function

 -- Built-in Function:  Inf
 -- Built-in Function:  Inf (N)
 -- Built-in Function:  Inf (N, M)
 -- Built-in Function:  Inf (N, M, K, ...)
 -- Built-in Function:  Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented
     using the the IEEE floating point format for numbers.  Two common
     examples which produce infinity are division by zero and overflow.
          [1/0 e^800]
          =>
          Inf   Inf

     When called with no arguments, return a scalar with the value
     `Inf'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isinf
}

#
inferiorto
{
`inferiorto' is a built-in function

 -- Built-in Function:  inferiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a lower precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.
}

#
info
{
`info' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/info.m

 -- Function File:  info ()
     Display contact information for the GNU Octave community.
}

#
info_file
{
`info_file' is a built-in function

 -- Built-in Function: VAL = info_file ()
 -- Built-in Function: OLD_VAL = info_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     Octave info file.  The default value is
     `OCTAVE-HOME/info/octave.info', in which OCTAVE-HOME is the root
     directory of the Octave installation.  The default value may be
     overridden by the environment variable `OCTAVE_INFO_FILE', or the
     command line argument `--info-file NAME'.

     See also: info_program, doc, help, makeinfo_program
}

#
info_program
{
`info_program' is a built-in function

 -- Built-in Function: VAL = info_program ()
 -- Built-in Function: OLD_VAL = info_program (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     info program to run.  The default value is
     `OCTAVE-HOME/libexec/octave/VERSION/exec/ARCH/info' in which
     OCTAVE-HOME is the root directory of the Octave installation,
     VERSION is the Octave version number, and ARCH is the system type
     (for example, `i686-pc-linux-gnu').  The default value may be
     overridden by the environment variable `OCTAVE_INFO_PROGRAM', or
     the command line argument `--info-program NAME'.

     See also: info_file, doc, help, makeinfo_program
}

#
inline
{
`inline' is a built-in function

 -- Built-in Function:  inline (STR)
 -- Built-in Function:  inline (STR, ARG1, ...)
 -- Built-in Function:  inline (STR, N)
     Create an inline function from the character string STR.  If
     called with a single argument, the arguments of the generated
     function are extracted from the function itself.  The generated
     function arguments will then be in alphabetical order.  It should
     be noted that i, and j are ignored as arguments due to the
     ambiguity between their use as a variable or their use as an
     inbuilt constant.  All arguments followed by a parenthesis are
     considered to be functions.

     If the second and subsequent arguments are character strings, they
     are the names of the arguments of the function.

     If the second argument is an integer N, the arguments are `"x"',
     `"P1"', ..., `"PN"'.

     See also: argnames, formula, vectorize
}

#
inpolygon
{
`inpolygon' is a function from the file /usr/share/octave/3.2.3/m/geometry/inpolygon.m

 -- Function File: [IN, ON] = inpolygon (X, Y, XV, XY)
     For a polygon defined by `(XV, YV)' points, determine if the
     points `(X, Y)' are inside or outside the polygon.  The variables
     X, Y, must have the same dimension.  The optional output ON gives
     the points that are on the polygon.
}

#
input
{
`input' is a built-in function

 -- Built-in Function:  input (PROMPT)
 -- Built-in Function:  input (PROMPT, "s")
     Print a prompt and wait for user input.  For example,

          input ("Pick a number, any number! ")

     prints the prompt

          Pick a number, any number!

     and waits for the user to enter a value.  The string entered by
     the user is evaluated as an expression, so it may be a literal
     constant, a variable name, or any other valid expression.

     Currently, `input' only returns one value, regardless of the number
     of values produced by the evaluation of the expression.

     If you are only interested in getting a literal string value, you
     can call `input' with the character string `"s"' as the second
     argument.  This tells Octave to return the string entered by the
     user directly, without evaluating it first.

     Because there may be output waiting to be displayed by the pager,
     it is a good idea to always call `fflush (stdout)' before calling
     `input'.  This will ensure that all pending output is written to
     the screen before your prompt.  *Note Input and Output::.
}

#
inputname
{
`inputname' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/inputname.m

 -- Function File:  inputname (N)
     Return the text defining N-th input to the function.
}

#
int16
{
`int16' is a built-in function

 -- Built-in Function:  int16 (X)
     Convert X to 16-bit integer type.
}

#
int2str
{
`int2str' is a function from the file /usr/share/octave/3.2.3/m/general/int2str.m

 -- Function File:  int2str (N)
     Convert an integer (or array of integers) to a string (or a
     character array).


          int2str (123)
               => "123"

          s = int2str ([1, 2, 3; 4, 5, 6])
               => s =
                  1  2  3
                  4  5  6

          whos s
               => s =
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x7                         14  char

     This function is not very flexible.  For better control over the
     results, use `sprintf' (*note Formatted Output::).

     See also: sprintf, num2str, mat2str
}

#
int32
{
`int32' is a built-in function

 -- Built-in Function:  int32 (X)
     Convert X to 32-bit integer type.
}

#
int64
{
`int64' is a built-in function

 -- Built-in Function:  int64 (X)
     Convert X to 64-bit integer type.
}

#
int8
{
`int8' is a built-in function

 -- Built-in Function:  int8 (X)
     Convert X to 8-bit integer type.
}

#
interp1
{
`interp1' is a function from the file /usr/share/octave/3.2.3/m/general/interp1.m

 -- Function File: YI = interp1 (X, Y, XI)
 -- Function File: YI = interp1 (..., METHOD)
 -- Function File: YI = interp1 (..., EXTRAP)
 -- Function File: PP = interp1 (..., 'pp')
     One-dimensional interpolation.  Interpolate Y, defined at the
     points X, at the points XI.  The sample points X must be strictly
     monotonic.  If Y is an array, treat the columns of Y separately.

     Method is one of:

    'nearest'
          Return the nearest neighbor.

    'linear'
          Linear interpolation from nearest neighbors

    'pchip'
          Piece-wise cubic hermite interpolating polynomial

    'cubic'
          Cubic interpolation from four nearest neighbors

    'spline'
          Cubic spline interpolation-smooth first and second derivatives
          throughout the curve

     Appending '*' to the start of the above method forces `interp1' to
     assume that X is uniformly spaced, and only `X (1)' and `X (2)'
     are referenced.  This is usually faster, and is never slower.  The
     default method is 'linear'.

     If EXTRAP is the string 'extrap', then extrapolate values beyond
     the endpoints.  If EXTRAP is a number, replace values beyond the
     endpoints with that number.  If EXTRAP is missing, assume NA.

     If the string argument 'pp' is specified, then XI should not be
     supplied and `interp1' returns the piece-wise polynomial that can
     later be used with `ppval' to evaluate the interpolation.  There
     is an equivalence, such that `ppval (interp1 (X, Y, METHOD, 'pp'),
     XI) == interp1 (X, Y, XI, METHOD, 'extrap')'.

     An example of the use of `interp1' is

          xf = [0:0.05:10];
          yf = sin (2*pi*xf/5);
          xp = [0:10];
          yp = sin (2*pi*xp/5);
          lin = interp1 (xp, yp, xf);
          spl = interp1 (xp, yp, xf, "spline");
          cub = interp1 (xp, yp, xf, "cubic");
          near = interp1 (xp, yp, xf, "nearest");
          plot (xf, yf, "r", xf, lin, "g", xf, spl, "b",
                xf, cub, "c", xf, near, "m", xp, yp, "r*");
          legend ("original", "linear", "spline", "cubic", "nearest")

     See also: interpft
}

#
interp1q
{
`interp1q' is a function from the file /usr/share/octave/3.2.3/m/general/interp1q.m

 -- Function File: YI = interp1q (X, Y, XI)
     One-dimensional linear interpolation without error checking.
     Interpolates Y, defined at the points X, at the points XI.  The
     sample points X must be a strictly monotonically increasing column
     vector.  If Y is an array, treat the columns of Y separately.  If
     Y is a vector, it must be a column vector of the same length as X.

     Values of XI beyond the endpoints of the interpolation result in
     NA being returned.

     Note that the error checking is only a significant portion of the
     execution time of this `interp1' if the size of the input arguments
     is relatively small.  Therefore, the benefit of using `interp1q'
     is relatively small.

     See also: interp1
}

#
interp2
{
`interp2' is a function from the file /usr/share/octave/3.2.3/m/general/interp2.m

 -- Function File: ZI = interp2 (X, Y, Z, XI, YI)
 -- Function File: ZI = interp2 (Z, XI, YI)
 -- Function File: ZI = interp2 (Z, N)
 -- Function File: ZI = interp2 (..., METHOD)
 -- Function File: ZI = interp2 (..., METHOD, EXTRAPVAL)
     Two-dimensional interpolation.  X, Y and Z describe a surface
     function.  If X and Y are vectors their length must correspondent
     to the size of Z.  X and Y must be monotonic.  If they are
     matrices they must have the `meshgrid' format.

    `interp2 (X, Y, Z, XI, YI, ...)'
          Returns a matrix corresponding to the points described by the
          matrices XI, YI.

          If the last argument is a string, the interpolation method can
          be specified.  The method can be 'linear', 'nearest' or
          'cubic'.  If it is omitted 'linear' interpolation is assumed.

    `interp2 (Z, XI, YI)'
          Assumes `X = 1:rows (Z)' and `Y = 1:columns (Z)'

    `interp2 (Z, N)'
          Interleaves the matrix Z n-times.  If N is omitted a value of
          `N = 1' is assumed.

     The variable METHOD defines the method to use for the
     interpolation.  It can take one of the following values

    'nearest'
          Return the nearest neighbor.

    'linear'
          Linear interpolation from nearest neighbors.

    'pchip'
          Piece-wise cubic hermite interpolating polynomial (not
          implemented yet).

    'cubic'
          Cubic interpolation from four nearest neighbors.

    'spline'
          Cubic spline interpolation-smooth first and second derivatives
          throughout the curve.

     If a scalar value EXTRAPVAL is defined as the final value, then
     values outside the mesh as set to this value.  Note that in this
     case METHOD must be defined as well.  If EXTRAPVAL is not defined
     then NA is assumed.

     See also: interp1
}

#
interp3
{
`interp3' is a function from the file /usr/share/octave/3.2.3/m/general/interp3.m

 -- Function File: VI = interp3 (X, Y,Z, V, XI, YI, ZI)
 -- Function File: VI = interp3 (V, XI, YI, ZI)
 -- Function File: VI = interp3 (V, M)
 -- Function File: VI = interp3 (V)
 -- Function File: VI = interp3 (..., METHOD)
 -- Function File: VI = interp3 (..., METHOD, EXTRAPVAL)
     Perform 3-dimensional interpolation.  Each element of the
     3-dimensional array V represents a value at a location given by
     the parameters X, Y, and Z.  The parameters X, X, and Z are either
     3-dimensional arrays of the same size as the array V in the
     'meshgrid' format or vectors.  The parameters XI, etc.  respect a
     similar format to X, etc., and they represent the points at which
     the array VI is interpolated.

     If X, Y, Z are omitted, they are assumed to be `x = 1 : size (V,
     2)', `y = 1 : size (V, 1)' and `z = 1 : size (V, 3)'.  If M is
     specified, then the interpolation adds a point half way between
     each of the interpolation points.  This process is performed M
     times.  If only V is specified, then M is assumed to be `1'.

     Method is one of:

    'nearest'
          Return the nearest neighbor.

    'linear'
          Linear interpolation from nearest neighbors.

    'cubic'
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

    'spline'
          Cubic spline interpolation-smooth first and second derivatives
          throughout the curve.

     The default method is 'linear'.

     If EXTRAP is the string 'extrap', then extrapolate values beyond
     the endpoints.  If EXTRAP is a number, replace values beyond the
     endpoints with that number.  If EXTRAP is missing, assume NA.

     See also: interp1, interp2, spline, meshgrid
}

#
interpft
{
`interpft' is a function from the file /usr/share/octave/3.2.3/m/general/interpft.m

 -- Function File:  interpft (X, N)
 -- Function File:  interpft (X, N, DIM)
     Fourier interpolation.  If X is a vector, then X is resampled with
     N points.  The data in X is assumed to be equispaced.  If X is an
     array, then operate along each column of the array separately.  If
     DIM is specified, then interpolate along the dimension DIM.

     `interpft' assumes that the interpolated function is periodic, and
     so assumptions are made about the end points of the interpolation.

     See also: interp1
}

#
interpn
{
`interpn' is a function from the file /usr/share/octave/3.2.3/m/general/interpn.m

 -- Function File: VI = interpn (X1, X2, ..., V, Y1, Y2, ...)
 -- Function File: VI = interpn (V, Y1, Y2, ...)
 -- Function File: VI = interpn (V, M)
 -- Function File: VI = interpn (V)
 -- Function File: VI = interpn (..., METHOD)
 -- Function File: VI = interpn (..., METHOD, EXTRAPVAL)
     Perform N-dimensional interpolation, where N is at least two.
     Each element of the N-dimensional array V represents a value at a
     location given by the parameters X1, X2, ..., XN.  The parameters
     X1, X2, ..., XN are either N-dimensional arrays of the same size
     as the array V in the 'ndgrid' format or vectors.  The parameters
     Y1, etc. respect a similar format to X1, etc., and they represent
     the points at which the array VI is interpolated.

     If X1, ..., XN are omitted, they are assumed to be `x1 = 1 : size
     (V, 1)', etc.  If M is specified, then the interpolation adds a
     point half way between each of the interpolation points.  This
     process is performed M times.  If only V is specified, then M is
     assumed to be `1'.

     Method is one of:

    'nearest'
          Return the nearest neighbor.

    'linear'
          Linear interpolation from nearest neighbors.

    'cubic'
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

    'spline'
          Cubic spline interpolation-smooth first and second derivatives
          throughout the curve.

     The default method is 'linear'.

     If EXTRAPVAL is the scalar value, use it to replace the values
     beyond the endpoints with that number.  If EXTRAPVAL is missing,
     assume NA.

     See also: interp1, interp2, spline, ndgrid
}

#
intersect
{
`intersect' is a function from the file /usr/share/octave/3.2.3/m/set/intersect.m

 -- Function File:  intersect (A, B)
 -- Function File: [C, IA, IB] = intersect (A, B)
     Return the elements in both A and B, sorted in ascending order.
     If A and B are both column vectors return a column vector,
     otherwise return a row vector.

     Return index vectors IA and IB such that `a(ia)==c' and `b(ib)==c'.


   See also: unique, union, setxor, setdiff, ismember
}

#
intersection
{
`intersection' is a function from the file /usr/share/octave/3.2.3/m/deprecated/intersection.m

 -- Function File:  intersection (X, Y)
     This function has been deprecated.  Use intersect instead.
}

#
intmax
{
`intmax' is a built-in function

 -- Built-in Function:  intmax (TYPE)
     Return the largest integer that can be represented in an integer
     type.  The variable TYPE can be

    `int8'
          signed 8-bit integer.

    `int16'
          signed 16-bit integer.

    `int32'
          signed 32-bit integer.

    `int64'
          signed 64-bit integer.

    `uint8'
          unsigned 8-bit integer.

    `uint16'
          unsigned 16-bit integer.

    `uint32'
          unsigned 32-bit integer.

    `uint64'
          unsigned 64-bit integer.

     The default for TYPE is `uint32'.

     See also: intmin, bitmax
}

#
intmin
{
`intmin' is a built-in function

 -- Built-in Function:  intmin (TYPE)
     Return the smallest integer that can be represented in an integer
     type.  The variable TYPE can be

    `int8'
          signed 8-bit integer.

    `int16'
          signed 16-bit integer.

    `int32'
          signed 32-bit integer.

    `int64'
          signed 64-bit integer.

    `uint8'
          unsigned 8-bit integer.

    `uint16'
          unsigned 16-bit integer.

    `uint32'
          unsigned 32-bit integer.

    `uint64'
          unsigned 64-bit integer.

     The default for TYPE is `uint32'.

     See also: intmax, bitmax
}

#
intwarning
{
`intwarning' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/intwarning.m

 -- Function File:  intwarning (ACTION)
 -- Function File:  intwarning (S)
 -- Function File: S = intwarning (...)
     Control the state of the warning for integer conversions and math
     operations.

    "query"
          The state of the Octave integer conversion and math warnings
          is queried.  If there is no output argument, then the state
          is printed.  Otherwise it is returned in a structure with the
          fields "identifier" and "state".

               intwarning ("query")
               The state of warning "Octave:int-convert-nan" is "off"
               The state of warning "Octave:int-convert-non-int-val" is "off"
               The state of warning "Octave:int-convert-overflow" is "off"
               The state of warning "Octave:int-math-overflow" is "off"

    "on"
          Turn integer conversion and math warnings "on".  If there is
          no output argument, then nothing is printed.  Otherwise the
          original state of the state of the integer conversion and
          math warnings is returned in a structure array.

    "off"
          Turn integer conversion and math warnings "on".  If there is
          no output argument, then nothing is printed.  Otherwise the
          original state of the state of the integer conversion and
          math warnings is returned in a structure array.

     The original state of the integer warnings can be restored by
     passing the structure array returned by `intwarning' to a later
     call to `intwarning'.  For example

          s = intwarning ("off");
          ...
          intwarning (s);

     See also: warning
}

#
inv
{
`inv' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/inv.oct

 -- Loadable Function: [X, RCOND] = inv (A)
 -- Loadable Function: [X, RCOND] = inverse (A)
     Compute the inverse of the square matrix A.  Return an estimate of
     the reciprocal condition number if requested, otherwise warn of an
     ill-conditioned matrix if the reciprocal condition number is small.

     If called with a sparse matrix, then in general X will be a full
     matrix, and so if possible forming the inverse of a sparse matrix
     should be avoided.  It is significantly more accurate and faster
     to do `Y = A \ B', rather than `Y = inv (A) * B'.
}

#
inverse
{
`inverse' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/inv.oct

 -- Loadable Function:  inverse (A)
     See inv.
}

#
invhilb
{
`invhilb' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/invhilb.m

 -- Function File:  invhilb (N)
     Return the inverse of a Hilbert matrix of order N.  This can be
     computed exactly using

                      (i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
           A(i,j) = -1      (i+j-1)(       )(       ) (       )
                                    \ n-j /  \ n-i /   \ i-2 /

                  = p(i) p(j) / (i+j-1)
     where
                       k  /k+n-1\   /n\
              p(k) = -1  (       ) (   )
                          \ k-1 /   \k/

     The validity of this formula can easily be checked by expanding
     the binomial coefficients in both formulas as factorials.  It can
     be derived more directly via the theory of Cauchy matrices: see J.
     W. Demmel, Applied Numerical Linear Algebra, page 92.

     Compare this with the numerical calculation of `inverse (hilb
     (n))', which suffers from the ill-conditioning of the Hilbert
     matrix, and the finite precision of your computer's floating point
     arithmetic.

     See also: hankel, vander, sylvester_matrix, hilb, toeplitz
}

#
ipermute
{
`ipermute' is a built-in function

 -- Built-in Function:  ipermute (A, IPERM)
     The inverse of the `permute' function.  The expression

          ipermute (permute (a, perm), perm)
     returns the original array A.

     See also: permute
}

#
iqr
{
`iqr' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/iqr.m

 -- Function File:  iqr (X, DIM)
     If X is a vector, return the interquartile range, i.e., the
     difference between the upper and lower quartile, of the input data.

     If X is a matrix, do the above for first non-singleton dimension
     of X.  If the option DIM argument is given, then operate along
     this dimension.
}

#
is_absolute_filename
{
`is_absolute_filename' is a built-in function

 -- Built-in Function:  is_absolute_filename (FILE)
     Return true if FILE is an absolute filename.
}

#
is_bool
{
`is_bool' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_bool.m

 -- Function File:  is_bool (A)
     This function has been deprecated.  Use isbool instead.
}

#
is_complex
{
`is_complex' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_complex.m

 -- Function File:  is_complex (A)
     This function has been deprecated.  Use iscomplex instead.
}

#
is_duplicate_entry
{
`is_duplicate_entry' is a function from the file /usr/share/octave/3.2.3/m/general/is_duplicate_entry.m

 -- Function File:  is_duplicate_entry (X)
     Return non-zero if any entries in X are duplicates of one another.
}

#
is_global
{
`is_global' is a built-in function

 -- Built-in Function:  isglobal (NAME)
     This function has been deprecated.  Use isglobal instead.
}

#
is_leap_year
{
`is_leap_year' is a function from the file /usr/share/octave/3.2.3/m/time/is_leap_year.m

 -- Function File:  is_leap_year (YEAR)
     Return 1 if the given year is a leap year and 0 otherwise.  If no
     arguments are provided, `is_leap_year' will use the current year.
     For example,

          is_leap_year (2000)
               => 1
}

#
is_list
{
`is_list' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_list.m

 -- Function File:  is_list (A)
     This function has been deprecated.  Use islist instead.
}

#
is_matrix
{
`is_matrix' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_matrix.m

 -- Function File:  is_matrix (A)
     This function has been deprecated.  Use ismatrix instead.
}

#
is_rooted_relative_filename
{
`is_rooted_relative_filename' is a built-in function

 -- Built-in Function:  is_rooted_relative_filename (FILE)
     Return true if FILE is a rooted-relative filename.
}

#
is_scalar
{
`is_scalar' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_scalar.m

 -- Function File:  is_scalar (A)
     This function has been deprecated.  Use isscalar instead.
}

#
is_square
{
`is_square' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_square.m

 -- Function File:  is_square (X)
     This function has been deprecated.  Use issquare instead.
}

#
is_stream
{
`is_stream' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_stream.m

 -- Function File:  is_stream (A)
     This function has been deprecated.  Use isstream instead.
}

#
is_struct
{
`is_struct' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_struct.m

 -- Function File:  is_struct (A)
     This function has been deprecated.  Use isstruct instead.
}

#
is_symmetric
{
`is_symmetric' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_symmetric.m

 -- Function File:  issymmetric (X, TOL)
     This function has been deprecated.  Use issymmetric instead.
}

#
is_vector
{
`is_vector' is a function from the file /usr/share/octave/3.2.3/m/deprecated/is_vector.m

 -- Function File:  is_vector (A)
     This function has been deprecated.  Use isvector instead.
}

#
isa
{
`isa' is a function from the file /usr/share/octave/3.2.3/m/general/isa.m

 -- Function File:  isa (X, CLASS)
     Return true if X is a value from the class CLASS.
}

#
isalnum
{
`isalnum' is a built-in function

 -- Mapping Function:  isalnum (S)
     Return 1 for characters that are letters or digits (`isalpha (S)'
     or `isdigit (S)' is true).
}

#
isalpha
{
`isalpha' is a built-in function

 -- Mapping Function:  isalpha (S)
 -- Mapping Function:  isletter (S)
     Return true for characters that are letters (`isupper (S)' or
     `islower (S)' is true).
}

#
isascii
{
`isascii' is a built-in function

 -- Mapping Function:  isascii (S)
     Return 1 for characters that are ASCII (in the range 0 to 127
     decimal).
}

#
isbool
{
`isbool' is a built-in function

 -- Built-in Function:  islogical (X)
     Return true if X is a logical object.
}

#
iscell
{
`iscell' is a built-in function

 -- Built-in Function:  iscell (X)
     Return true if X is a cell array object.  Otherwise, return false.
}

#
iscellstr
{
`iscellstr' is a built-in function

 -- Built-in Function:  iscellstr (CELL)
     Return true if every element of the cell array CELL is a character
     string
}

#
ischar
{
`ischar' is a built-in function

 -- Built-in Function:  ischar (A)
     Return 1 if A is a character array.  Otherwise, return 0.
}

#
iscntrl
{
`iscntrl' is a built-in function

 -- Mapping Function:  iscntrl (S)
     Return 1 for control characters.
}

#
iscommand
{
`iscommand' is a function from the file /usr/share/octave/3.2.3/m/deprecated/iscommand.m

 -- Built-in Function:  iscommand (NAME)
     This function is obsolete and will be removed from a future
     version of Octave.
}

#
iscomplex
{
`iscomplex' is a built-in function

 -- Built-in Function:  iscomplex (X)
     Return true if X is a complex-valued numeric object.
}

#
isdebugmode
{
`isdebugmode' is a built-in function

 -- Command:  isdebugmode ()
     Return true if debug mode is on, otherwise false.

     See also: dbstack, dbclear, dbstop, dbstatus
}

#
isdefinite
{
`isdefinite' is a function from the file /usr/share/octave/3.2.3/m/general/isdefinite.m

 -- Function File:  isdefinite (X, TOL)
     Return 1 if X is symmetric positive definite within the tolerance
     specified by TOL or 0 if X is symmetric positive semidefinite.
     Otherwise, return -1.  If TOL is omitted, use a tolerance equal to
     100 times the machine precision.

     See also: issymmetric
}

#
isdigit
{
`isdigit' is a built-in function

 -- Mapping Function:  isdigit (S)
     Return 1 for characters that are decimal digits.
}

#
isdir
{
`isdir' is a function from the file /usr/share/octave/3.2.3/m/general/isdir.m

 -- Function File:  isdir (F)
     Return true if F is a directory.
}

#
isempty
{
`isempty' is a built-in function

 -- Built-in Function:  isempty (A)
     Return 1 if A is an empty matrix (either the number of rows, or
     the number of columns, or both are zero).  Otherwise, return 0.
}

#
isequal
{
`isequal' is a function from the file /usr/share/octave/3.2.3/m/general/isequal.m

 -- Function File:  isequal (X1, X2, ...)
     Return true if all of X1, X2, ... are equal.

     See also: isequalwithequalnans
}

#
isequalwithequalnans
{
`isequalwithequalnans' is a function from the file /usr/share/octave/3.2.3/m/general/isequalwithequalnans.m

 -- Function File:  isequalwithequalnans (X1, X2, ...)
     Assuming NaN == NaN, return true if all of X1, X2, ...  are equal.

     See also: isequal
}

#
isfield
{
`isfield' is a built-in function

 -- Built-in Function:  isfield (EXPR, NAME)
     Return true if the expression EXPR is a structure and it includes
     an element named NAME.  The first argument must be a structure and
     the second must be a string.
}

#
isfigure
{
`isfigure' is a function from the file /usr/share/octave/3.2.3/m/plot/isfigure.m

 -- Function File:  isfigure (H)
     Return true if H is a graphics handle that contains a figure
     object and false otherwise.
}

#
isfinite
{
`isfinite' is a built-in function

 -- Mapping Function:  finite (X)
     Return 1 for elements of X that are finite values and zero
     otherwise.  For example,

          finite ([13, Inf, NA, NaN])
              => [ 1, 0, 0, 0 ]
}

#
isfloat
{
`isfloat' is a built-in function

 -- Built-in Function:  isfloat (X)
     Return true if X is a floating-point numeric object.
}

#
isglobal
{
`isglobal' is a built-in function

 -- Built-in Function:  isglobal (NAME)
     Return 1 if NAME is globally visible.  Otherwise, return 0.  For
     example,

          global x
          isglobal ("x")
              => 1
}

#
isgraph
{
`isgraph' is a built-in function

 -- Mapping Function:  isgraph (S)
     Return 1 for printable characters (but not the space character).
}

#
ishandle
{
`ishandle' is a built-in function

 -- Built-in Function:  ishandle (H)
     Return true if H is a graphics handle and false otherwise.
}

#
ishghandle
{
`ishghandle' is a function from the file /usr/share/octave/3.2.3/m/plot/ishghandle.m

 -- Function File:  ishghandle (H)
     Return true if H is a graphics handle and false otherwise.
}

#
ishold
{
`ishold' is a function from the file /usr/share/octave/3.2.3/m/plot/ishold.m

 -- Function File:  ishold
     Return true if the next line will be added to the current plot, or
     false if the plot device will be cleared before drawing the next
     line.
}

#
isieee
{
`isieee' is a built-in function

 -- Built-in Function:  isieee ()
     Return 1 if your computer claims to conform to the IEEE standard
     for floating point calculations.
}

#
isinf
{
`isinf' is a built-in function

 -- Mapping Function:  isinf (X)
     Return 1 for elements of X that are infinite and zero otherwise.
     For example,

          isinf ([13, Inf, NA, NaN])
              => [ 0, 1, 0, 0 ]
}

#
isinteger
{
`isinteger' is a built-in function

 -- Built-in Function:  isinteger (X)
     Return true if X is an integer object (int8, uint8, int16, etc.).
     Note that `isinteger (14)' is false because numeric constants in
     Octave are double precision floating point values.

     See also: isreal, isnumeric, class, isa
}

#
iskeyword
{
`iskeyword' is a built-in function

 -- Built-in Function:  iskeyword (NAME)
     Return true if NAME is an Octave keyword.  If NAME is omitted,
     return a list of keywords.
}

#
isletter
{
`isletter' is a function from the file /usr/share/octave/3.2.3/m/strings/isletter.m

 -- Function File:  isletter (S)
     Returns true if S is a letter, false otherwise.

     See also: isalpha
}

#
islist
{
`islist' is a built-in function

 -- Built-in Function:  islist (X)
     Return nonzero if X is a list.
}

#
islogical
{
`islogical' is a built-in function

 -- Built-in Function:  islogical (X)
     Return true if X is a logical object.
}

#
islower
{
`islower' is a built-in function

 -- Mapping Function:  islower (S)
     Return 1 for characters that are lower case letters.
}

#
ismac
{
`ismac' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/ismac.m

 -- Function File:  ismac ()
     Return 1 if Octave is running on a Mac OS X system and 0 otherwise.

     See also: ispc, isunix
}

#
ismatrix
{
`ismatrix' is a built-in function

 -- Built-in Function:  ismatrix (A)
     Return 1 if A is a matrix.  Otherwise, return 0.
}

#
ismember
{
`ismember' is a function from the file /usr/share/octave/3.2.3/m/set/ismember.m

 -- Function File: [TF = ismember (A, S)
 -- Function File: [TF, S_IDX] = ismember (A, S)
 -- Function File: [TF, S_IDX] = ismember (A, S, "rows")
     Return a matrix TF with the same shape as A which has a 1 if
     `A(i,j)' is in S and 0 if it is not.  If a second output argument
     is requested, the index into S of each of the matching elements is
     also returned.

          a = [3, 10, 1];
          s = [0:9];
          [tf, s_idx] = ismember (a, s);
               => tf = [1, 0, 1]
               => s_idx = [4, 0, 2]

     The inputs, A and S, may also be cell arrays.

          a = {'abc'};
          s = {'abc', 'def'};
          [tf, s_idx] = ismember (a, s);
               => tf = [1, 0]
               => s_idx = [1, 0]

     With the optional third argument `"rows"', and matrices A and S
     with the same number of columns, compare rows in A with the rows
     in S.

          a = [1:3; 5:7; 4:6];
          s = [0:2; 1:3; 2:4; 3:5; 4:6];
          [tf, s_idx] = ismember(a, s, 'rows');
               => tf = logical ([1; 0; 1])
               => s_idx = [2; 0; 5];

     See also: unique, union, intersect, setxor, setdiff
}

#
ismethod
{
`ismethod' is a built-in function

 -- Built-in Function:  ismethod (X, METHOD)
     Return true if X is a class object and the string METHOD is a
     method of this class.
}

#
isna
{
`isna' is a built-in function

 -- Mapping Function:  isna (X)
     Return 1 for elements of X that are NA (missing) values and zero
     otherwise.  For example,

          isna ([13, Inf, NA, NaN])
              => [ 0, 0, 1, 0 ]

     See also: isnan
}

#
isnan
{
`isnan' is a built-in function

 -- Mapping Function:  isnan (X)
     Return 1 for elements of X that are NaN values and zero otherwise.
     NA values are also considered NaN values.  For example,

          isnan ([13, Inf, NA, NaN])
              => [ 0, 0, 1, 1 ]

     See also: isna
}

#
isnull
{
`isnull' is a built-in function

 -- Built-in Function:  isnull (X)
     Return 1 if X is a special null matrix, string or single quoted
     string.  Indexed assignment with such a value as right-hand side
     should delete array elements.  This function should be used when
     overloading indexed assignment for user-defined classes instead of
     `isempty', to distinguish the cases:
    `A(I) = []'
          This should delete elements if `I' is nonempty.

    `X = []; A(I) = X'
          This should give an error if `I' is nonempty.
}

#
isnumeric
{
`isnumeric' is a built-in function

 -- Built-in Function:  isnumeric (X)
     Return nonzero if X is a numeric object.
}

#
isobject
{
`isobject' is a built-in function

 -- Built-in Function:  isobject (X)
     Return true if X is a class object.
}

#
isocolors
{
`isocolors' is a function from the file /usr/share/octave/3.2.3/m/plot/isocolors.m

 -- Function File: [CD] = isocolors (C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, C, V)
 -- Function File: [CD] = isocolors (X, Y, Z, R, G, B, V)
 -- Function File: [CD] = isocolors (R, G, B, V)
 -- Function File: [CD] = isocolors (..., P)
 -- Function File: isocolors (...)
     If called with one output argument and the first input argument C
     is a three-dimensional array that contains color values and the
     second input argument V keeps the vertices of a geometry then
     return a matrix CD with color data information for the geometry at
     computed points `[x, y, z] = meshgrid (1:l, 1:m, 1:n)'.  The
     output argument CD can be taken to manually set FaceVertexCData of
     a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays of the same size than C then the color
     data is taken at those given points.  Instead of the color data C
     this function can also be called with RGB values R, G, B.  If
     input argumnets X, Y, Z are not given then again `meshgrid'
     computed values are taken.

     Optionally, the patch handle P can be given as the last input
     argument to all variations of function calls instead of the
     vertices data V.  Finally, if no output argument is given then
     directly change the colors of a patch that is given by the patch
     handle P.

     For example,
          function [] = isofinish (p)
            set (gca, "DataAspectRatioMode", "manual", \
                 "DataAspectRatio", [1 1 1]);
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "flat");
            ## light ("Position", [1 1 5]); ## Available with JHandles
          endfunction

          N = 15;    ## Increase number of vertices in each direction
          iso = .4;  ## Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); ## Open another figure window

          subplot (2, 2, 1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = rand (size (c));       ## Compute random patch color data
          isocolors (x, y, z, cdat, p); ## Directly set colors of patch
          isofinish (p);                ## Call user function isofinish

          subplot (2, 2, 2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
          cdat = isocolors (x, y, z, c, v); ## Compute color data vertices
          set (p, "FaceVertexCData", cdat); ## Set color data manually
          isofinish (p);

          subplot (2, 2, 3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = isocolors (r, g, b, c, p); ## Compute color data patch
          set (p, "FaceVertexCData", cdat); ## Set color data manually
          isofinish (p);

          subplot (2, 2, 4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          r = g = b = repmat ([1:N] / N, [N, 1, N]); ## Black to white
          cdat = isocolors (x, y, z, r, g, b, v);
          set (p, "FaceVertexCData", cdat);
          isofinish (p);

     See also: isosurface, isonormals, isocaps
}

#
isonormals
{
`isonormals' is a function from the file /usr/share/octave/3.2.3/m/plot/isonormals.m

 -- Function File: [N] = isonormals (VAL, V)
 -- Function File: [N] = isonormals (VAL, P)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, V)
 -- Function File: [N] = isonormals (X, Y, Z, VAL, P)
 -- Function File: [N] = isonormals (..., "negate")
 -- Function File: isonormals (..., P)
     If called with one output argument and the first input argument
     VAL is a three-dimensional array that contains the data for an
     isosurface geometry and the second input argument V keeps the
     vertices of an isosurface then return the normals N in form of a
     matrix with the same size than V at computed points `[x, y, z] =
     meshgrid (1:l, 1:m, 1:n)'.  The output argument N can be taken to
     manually set VERTEXNORMALS of a patch.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.  Instead of the
     vertices data V a patch handle P can be passed to this function.

     If given the string input argument "negate" as last input argument
     then compute the reverse vector normals of an isosurface geometry.

     If no output argument is given then directly redraw the patch that
     is given by the patch handle P.

     For example,
          function [] = isofinish (p)
            set (gca, "DataAspectRatioMode","manual","DataAspectRatio",[1 1 1]);
            set (p, "VertexNormals", -get(p,"VertexNormals")); ## Revert normals
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "phong");
            ## light ("Position", [1 1 5]); ## Available with JHandles
          endfunction

          N = 15;    ## Increase number of vertices in each direction
          iso = .4;  ## Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); ## Open another figure window

          subplot (2, 2, 1); view (-38, 20);
          [f, v, cdat] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
          	   "FaceColor", "interp", "EdgeColor", "none");
          isofinish (p); ## Call user function isofinish

          subplot (2, 2, 2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
          	   "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, p); ## Directly modify patch
          isofinish (p);

          subplot (2, 2, 3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
          	   "FaceColor", "interp", "EdgeColor", "none");
          n = isonormals (x, y, z, c, v); ## Compute normals of isosurface
          set (p, "VertexNormals", n);    ## Manually set vertex normals
          isofinish (p);

          subplot (2, 2, 4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
          	   "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, v, "negate"); ## Use reverse directly
          isofinish (p);

     See also: isosurface, isocolors, isocaps, marching_cube
}

#
isosurface
{
`isosurface' is a function from the file /usr/share/octave/3.2.3/m/plot/isosurface.m

 -- Function File: [FV] = isosurface (VAL, ISO)
 -- Function File: [FV] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [FV] = isosurface (..., "noshare", "verbose")
 -- Function File: [FVC] = isosurface (..., COL)
 -- Function File: [F, V] = isosurface (X, Y, Z, VAL, ISO)
 -- Function File: [F, V, C] = isosurface (X, Y, Z, VAL, ISO, COL)
 -- Function File:  isosurface (X, Y, Z, VAL, ISO, COL, OPT)
     If called with one output argument and the first input argument
     VAL is a three-dimensional array that contains the data of an
     isosurface geometry and the second input argument ISO keeps the
     isovalue as a scalar value then return a structure array FV that
     contains the fields FACES and VERTICES at computed points `[x, y,
     z] = meshgrid (1:l, 1:m, 1:n)'.  The output argument FV can
     directly be taken as an input argument for the `patch' function.

     If called with further input arguments X, Y and Z which are
     three-dimensional arrays with the same size than VAL then the
     volume data is taken at those given points.

     The string input argument "noshare" is only for compatibility and
     has no effect. If given the string input argument "verbose" then
     print messages to the command line interface about the current
     progress.

     If called with the input argument COL which is a three-dimensional
     array of the same size than VAL then take those values for the
     interpolation of coloring the isosurface geometry.  Add the field
     FACEVERTEXCDATA to the structure array FV.

     If called with two or three output arguments then return the
     information about the faces F, vertices V and color data C as
     seperate arrays instead of a single structure array.

     If called with no output argument then directly process the
     isosurface geometry with the `patch' command.

     For example

          [x, y, z] = meshgrid (1:5, 1:5, 1:5);
          val = rand (5, 5, 5);
          isosurface (x, y, z, val, .5);

     will directly draw a random isosurface geometry in a graphics
     window.  Another example for an isosurface geometry with different
     additional coloring

          N = 15;    ## Increase number of vertices in each direction
          iso = .4;  ## Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); ## Open another figure window

          subplot (2, 2, 1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          set (gca, "DataAspectRatioMode","manual", "DataAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "green", "FaceLighting", "phong");
          # light ("Position", [1 1 5]); ## Available with the JHandles package

          subplot (2, 2, 2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
          set (gca, "DataAspectRatioMode","manual", "DataAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "none", "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

          subplot (2, 2, 3); view (-38, 20);
          [f, v, c] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
                     "FaceColor", "interp", "EdgeColor", "none");
          set (gca, "DataAspectRatioMode","manual", "DataAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

          subplot (2, 2, 4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, \
                     "FaceColor", "interp", "EdgeColor", "blue");
          set (gca, "DataAspectRatioMode","manual", "DataAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);

     See also: isocolors, isonormals, isocaps
}

#
ispc
{
`ispc' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/ispc.m

 -- Function File:  ispc ()
     Return 1 if Octave is running on a Windows system and 0 otherwise.

     See also: ismac, isunix
}

#
isprime
{
`isprime' is a function from the file /usr/share/octave/3.2.3/m/specfun/isprime.m

 -- Function File:  isprime (N)
     Return true if N is a prime number, false otherwise.

     Something like the following is much faster if you need to test a
     lot of small numbers:

             T = ismember (N, primes (max (N (:))));

     If max(n) is very large, then you should be using special purpose
     factorization code.

     See also: primes, factor, gcd, lcm
}

#
isprint
{
`isprint' is a built-in function

 -- Mapping Function:  isprint (S)
     Return 1 for printable characters (including the space character).
}

#
ispunct
{
`ispunct' is a built-in function

 -- Mapping Function:  ispunct (S)
     Return 1 for punctuation characters.
}

#
israwcommand
{
`israwcommand' is a function from the file /usr/share/octave/3.2.3/m/deprecated/israwcommand.m

 -- Built-in Function:  israwcommand (NAME)
     This function is obsolete and will be removed from a future
     version of Octave.
}

#
isreal
{
`isreal' is a built-in function

 -- Built-in Function:  isreal (X)
     Return true if X is a real-valued numeric object.
}

#
isscalar
{
`isscalar' is a function from the file /usr/share/octave/3.2.3/m/general/isscalar.m

 -- Function File:  isscalar (A)
     Return 1 if A is a scalar.  Otherwise, return 0.

     See also: size, rows, columns, length, isscalar, ismatrix
}

#
issorted
{
`issorted' is a built-in function

 -- Built-in Function:  issorted (A, ROWS)
     Returns true if the array is sorted, ascending or descending.
     NaNs are treated as by `sort'.  If ROWS is supplied and has the
     value "rows", checks whether the array is sorted by rows as if
     output by `sortrows' (with no options).

     This function does not yet support sparse matrices.

     See also: sortrows, sort
}

#
isspace
{
`isspace' is a built-in function

 -- Mapping Function:  isspace (S)
     Return 1 for whitespace characters (space, formfeed, newline,
     carriage return, tab, and vertical tab).
}

#
issparse
{
`issparse' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/sparse.oct

 -- Loadable Function:  issparse (EXPR)
     Return 1 if the value of the expression EXPR is a sparse matrix.
}

#
issquare
{
`issquare' is a function from the file /usr/share/octave/3.2.3/m/general/issquare.m

 -- Function File:  issquare (X)
     If X is a square matrix, then return the dimension of X.
     Otherwise, return 0.

     See also: size, rows, columns, length, ismatrix, isscalar, isvector
}

#
isstr
{
`isstr' is a function from the file /usr/share/octave/3.2.3/m/deprecated/isstr.m

 -- Function File:  isstr (A)
     This function has been deprecated.  Use ischar instead.
}

#
isstrprop
{
`isstrprop' is a function from the file /usr/share/octave/3.2.3/m/strings/isstrprop.m

 -- Function File:  isstrprop (STR, PRED)
     Test character string properties.  For example,

          isstrprop ("abc123", "alpha")
          => [1, 1, 1, 0, 0, 0]

     If STR is a cell array, `isstrpop' is applied recursively to each
     element of the cell array.

     Numeric arrays are converted to character strings.

     The second argument PRED may be one of

    `"alpha"'
          True for characters that are alphabetic

    `"alnum"'
    `"alphanum"'
          True for characters that are alphabetic or digits.

    `"ascii"'
          True for characters that are in the range of ASCII encoding.

    `"cntrl"'
          True for control characters.

    `"digit"'
          True for decimal digits.

    `"graph"'
    `"graphic"'
          True for printing characters except space.

    `"lower"'
          True for lower-case letters.

    `"print"'
          True for printing characters including space.

    `"punct"'
          True for printing characters except space or letter or digit.

    `"space"'
    `"wspace"'
          True for whitespace characters (space, formfeed, newline,
          carriage return, tab, vertical tab).

    `"upper"'
          True for upper-case letters.

    `"xdigit"'
          True for hexadecimal digits.

     See also: isalnum, isalpha, isascii, iscntrl, isdigit, isgraph,
     islower, isprint, ispunct, isspace, isupper, isxdigit
}

#
isstruct
{
`isstruct' is a built-in function

 -- Built-in Function:  isstruct (EXPR)
     Return 1 if the value of the expression EXPR is a structure.
}

#
issymmetric
{
`issymmetric' is a function from the file /usr/share/octave/3.2.3/m/general/issymmetric.m

 -- Function File:  issymmetric (X, TOL)
     If X is symmetric within the tolerance specified by TOL, then
     return the dimension of X.  Otherwise, return 0.  If TOL is
     omitted, use a tolerance equal to the machine precision.  Matrix X
     is considered symmetric if `norm (X - X.', inf) / norm (X, inf) <
     TOL'.

     See also: size, rows, columns, length, ismatrix, isscalar,
     issquare, isvector
}

#
isunix
{
`isunix' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/isunix.m

 -- Function File:  isunix ()
     Return 1 if Octave is running on a Unix-like system and 0
     otherwise.

     See also: ismac, ispc
}

#
isupper
{
`isupper' is a built-in function

 -- Mapping Function:  isupper (S)
     Return 1 for upper case letters.
}

#
isvarname
{
`isvarname' is a built-in function

 -- Built-in Function:  isvarname (NAME)
     Return true if NAME is a valid variable name
}

#
isvector
{
`isvector' is a function from the file /usr/share/octave/3.2.3/m/general/isvector.m

 -- Function File:  isvector (A)
     Return 1 if A is a vector.  Otherwise, return 0.

     See also: size, rows, columns, length, isscalar, ismatrix
}

#
isxdigit
{
`isxdigit' is a built-in function

 -- Mapping Function:  isxdigit (S)
     Return 1 for characters that are hexadecimal digits.
}

#
j
{
`j' is a built-in function

 -- Built-in Function:  I
 -- Built-in Function:  I (N)
 -- Built-in Function:  I (N, M)
 -- Built-in Function:  I (N, M, K, ...)
 -- Built-in Function:  I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as `sqrt (-1)'.  I,
     and its equivalents i, J, and j, are functions so any of the names
     may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with
     the dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".
}

#
jet
{
`jet' is a function from the file /usr/share/octave/3.2.3/m/image/jet.m

 -- Function File:  jet (N)
     Create color colormap.  This colormap is dark blue through blue,
     cyan, green, yellow, red to dark red.  The argument N should be a
     scalar.  If it is omitted, the length of the current colormap or
     64 is assumed.

     See also: colormap
}

#
kbhit
{
`kbhit' is a built-in function

 -- Built-in Function:  kbhit ()
     Read a single keystroke from the keyboard.  If called with one
     argument, don't wait for a keypress.  For example,

          x = kbhit ();

     will set X to the next character typed at the keyboard as soon as
     it is typed.

          x = kbhit (1);

     identical to the above example, but don't wait for a keypress,
     returning the empty string if no key is available.
}

#
kendall
{
`kendall' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/kendall.m

 -- Function File:  kendall (X, Y)
     Compute Kendall's TAU for each of the variables specified by the
     input arguments.

     For matrices, each row is an observation and each column a
     variable; vectors are always observations and may be row or column
     vectors.

     `kendall (X)' is equivalent to `kendall (X, X)'.

     For two data vectors X, Y of common length N, Kendall's TAU is the
     correlation of the signs of all rank differences of X and Y;
     i.e., if both X and Y have distinct entries, then

                   1
          tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
                n (n-1)   i,j

     in which the Q(I) and R(I)  are the ranks of X and Y, respectively.

     If X and Y are drawn from independent distributions, Kendall's TAU
     is asymptotically normal with mean 0 and variance `(2 * (2N+5)) /
     (9 * N * (N-1))'.
}

#
keyboard
{
`keyboard' is a built-in function

 -- Built-in Function:  keyboard ()
 -- Built-in Function:  keyboard (PROMPT)
     This function is normally used for simple debugging.  When the
     `keyboard' function is executed, Octave prints a prompt and waits
     for user input.  The input strings are then evaluated and the
     results are printed.  This makes it possible to examine the values
     of variables within a function, and to assign new values if
     necessary.  To leave the prompt and return to normal execution
     type `return' or `dbcont'.  The `keyboard' function does not
     return an exit status.

     If `keyboard' is invoked without arguments, a default prompt of
     `debug> ' is used.

     See also: dbcont, dbquit
}

#
kill
{
`kill' is a built-in function

 -- Built-in Function: [ERR, MSG] = kill (PID, SIG)
     Send signal SIG to process PID.

     If PID is positive, then signal SIG is sent to PID.

     If PID is 0, then signal SIG is sent to every process in the
     process group of the current process.

     If PID is -1, then signal SIG is sent to every process except
     process 1.

     If PID is less than -1, then signal SIG is sent to every process
     in the process group -PID.

     If SIG is 0, then no signal is sent, but error checking is still
     performed.

     Return 0 if successful, otherwise return -1.
}

#
kolmogorov_smirnov_cdf
{
`kolmogorov_smirnov_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/kolmogorov_smirnov_cdf.m

 -- Function File:  kolmogorov_smirnov_cdf (X, TOL)
     Return the CDF at X of the Kolmogorov-Smirnov distribution,
                   Inf
          Q(x) =   SUM    (-1)^k exp(-2 k^2 x^2)
                 k = -Inf

     for X > 0.

     The optional parameter TOL specifies the precision up to which the
     series should be evaluated;  the default is TOL = `eps'.
}

#
kolmogorov_smirnov_test
{
`kolmogorov_smirnov_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/kolmogorov_smirnov_test.m

 -- Function File: [PVAL, KS] = kolmogorov_smirnov_test (X, DIST,
          PARAMS, ALT)
     Perform a Kolmogorov-Smirnov test of the null hypothesis that the
     sample X comes from the (continuous) distribution dist.  I.e., if
     F and G are the CDFs corresponding to the sample and dist,
     respectively, then the null is that F == G.

     The optional argument PARAMS contains a list of parameters of
     DIST.  For example, to test whether a sample X comes from a
     uniform distribution on [2,4], use

          kolmogorov_smirnov_test(x, "uniform", 2, 4)

     DIST can be any string for which a function DIST_CDF that
     calculates the CDF of distribution DIST exists.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative F != G.  In this case, the test
     statistic KS follows a two-sided Kolmogorov-Smirnov distribution.
     If ALT is `">"', the one-sided alternative F > G is considered.
     Similarly for `"<"', the one-sided alternative F > G is
     considered.  In this case, the test statistic KS has a one-sided
     Kolmogorov-Smirnov distribution.  The default is the two-sided
     case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value is displayed.
}

#
kolmogorov_smirnov_test_2
{
`kolmogorov_smirnov_test_2' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/kolmogorov_smirnov_test_2.m

 -- Function File: [PVAL, KS, D] = kolmogorov_smirnov_test_2 (X, Y, ALT)
     Perform a 2-sample Kolmogorov-Smirnov test of the null hypothesis
     that the samples X and Y come from the same (continuous)
     distribution.  I.e., if F and G are the CDFs corresponding to the
     X and Y samples, respectively, then the null is that F == G.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative F != G.  In this case, the test
     statistic KS follows a two-sided Kolmogorov-Smirnov distribution.
     If ALT is `">"', the one-sided alternative F > G is considered.
     Similarly for `"<"', the one-sided alternative F < G is
     considered.  In this case, the test statistic KS has a one-sided
     Kolmogorov-Smirnov distribution.  The default is the two-sided
     case.

     The p-value of the test is returned in PVAL.

     The third returned value, D, is the test statistic, the maximum
     vertical distance between the two cumulative distribution
     functions.

     If no output argument is given, the p-value is displayed.
}

#
kron
{
`kron' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/kron.oct

 -- Loadable Function:  kron (A, B)
     Form the kronecker product of two matrices, defined block by block
     as

          x = [a(i, j) b]

     For example,

          kron (1:4, ones (3, 1))
               =>  1  2  3  4
                   1  2  3  4
                   1  2  3  4
}

#
kruskal_wallis_test
{
`kruskal_wallis_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/kruskal_wallis_test.m

 -- Function File: [PVAL, K, DF] = kruskal_wallis_test (X1, ...)
     Perform a Kruskal-Wallis one-factor "analysis of variance".

     Suppose a variable is observed for K > 1 different groups, and let
     X1, ..., XK be the corresponding data vectors.

     Under the null hypothesis that the ranks in the pooled sample are
     not affected by the group memberships, the test statistic K is
     approximately chi-square with DF = K - 1 degrees of freedom.

     If the data contains ties (some value appears more than once) K is
     divided by

     1 - SUM_TIES / (N^3 - N)

     where SUM_TIES is the sum of T^2 - T over each group of ties where
     T is the number of ties in the group and N is the total number of
     values in the input data.  For more info on this adjustment see
     "Use of Ranks in One-Criterion Variance Analysis" in Journal of
     the American Statistical Association, Vol. 47, No. 260 (Dec 1952)
     by William H. Kruskal and W. Allen Wallis.

     The p-value (1 minus the CDF of this distribution at K) is
     returned in PVAL.

     If no output argument is given, the p-value is displayed.
}

#
krylov
{
`krylov' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/krylov.m

 -- Function File: [U, H, NU] = krylov (A, V, K, EPS1, PFLG)
     Construct an orthogonal basis U of block Krylov subspace

          [v a*v a^2*v ... a^(k+1)*v]

     Using Householder reflections to guard against loss of
     orthogonality.

     If V is a vector, then H contains the Hessenberg matrix such that
     `a*u == u*h+rk*ek'', in which `rk = a*u(:,k)-u*h(:,k)', and `ek''
     is the vector `[0, 0, ..., 1]' of length `k'.  Otherwise, H is
     meaningless.

     If V is a vector and K is greater than `length(A)-1', then H
     contains the Hessenberg matrix such that `a*u == u*h'.

     The value of NU is the dimension of the span of the krylov
     subspace (based on EPS1).

     If B is a vector and K is greater than M-1, then H contains the
     Hessenberg decomposition of A.

     The optional parameter EPS1 is the threshold for zero.  The
     default value is 1e-12.

     If the optional parameter PFLG is nonzero, row pivoting is used to
     improve numerical behavior.  The default value is 0.

     Reference: Hodel and Misra, "Partial Pivoting in the Computation of
     Krylov Subspaces", to be submitted to Linear Algebra and its
     Applications
}

#
krylovb
{
`krylovb' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/krylovb.m

 -- Function File: [U, UCOLS] = krylovb (A, V, K, EPS1, PFLG)
     See `krylov'.
}

#
kurtosis
{
`kurtosis' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/kurtosis.m

 -- Function File:  kurtosis (X, DIM)
     If X is a vector of length N, return the kurtosis

          kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3

     of X.  If X is a matrix, return the kurtosis over the first
     non-singleton dimension.  The optional argument DIM can be given
     to force the kurtosis to be given over that dimension.
}

#
laplace_cdf
{
`laplace_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/laplace_cdf.m

 -- Function File:  laplace_cdf (X)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Laplace distribution.
}

#
laplace_inv
{
`laplace_inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/laplace_inv.m

 -- Function File:  laplace_inv (X)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the Laplace distribution.
}

#
laplace_pdf
{
`laplace_pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/laplace_pdf.m

 -- Function File:  laplace_pdf (X)
     For each element of X, compute the probability density function
     (PDF) at X of the Laplace distribution.
}

#
laplace_rnd
{
`laplace_rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/laplace_rnd.m

 -- Function File:  laplace_rnd (R, C)
 -- Function File:  laplace_rnd (SZ);
     Return an R by C matrix of random numbers from the Laplace
     distribution.  Or if SZ is a vector, create a matrix of SZ.
}

#
lasterr
{
`lasterr' is a built-in function

 -- Built-in Function: [MSG, MSGID] = lasterr (MSG, MSGID)
     Without any arguments, return the last error message.  With one
     argument, set the last error message to MSG.  With two arguments,
     also set the last message identifier.
}

#
lasterror
{
`lasterror' is a built-in function

 -- Built-in Function: ERR = lasterror (ERR)
 -- Built-in Function:  lasterror ('reset')
     Returns or sets the last error message.  Called without any
     arguments returns a structure containing the last error message,
     as well as other information related to this error.  The elements
     of this structure are:

    'message'
          The text of the last error message

    'identifier'
          The message identifier of this error message

    'stack'
          A structure containing information on where the message
          occurred.  This might be an empty structure if this in the
          case where this information cannot be obtained.  The fields
          of this structure are:

         'file'
               The name of the file where the error occurred

         'name'
               The name of function in which the error occurred

         'line'
               The line number at which the error occurred

         'column'
               An optional field with the column number at which the
               error occurred

     The ERR structure may also be passed to `lasterror' to set the
     information about the last error.  The only constraint on ERR in
     that case is that it is a scalar structure.  Any fields of ERR
     that match the above are set to the value passed in ERR, while
     other fields are set to their default values.

     If `lasterror' is called with the argument 'reset', all values take
     their default values.
}

#
lastwarn
{
`lastwarn' is a built-in function

 -- Built-in Function: [MSG, MSGID] = lastwarn (MSG, MSGID)
     Without any arguments, return the last warning message.  With one
     argument, set the last warning message to MSG.  With two arguments,
     also set the last message identifier.
}

#
lchol
{
`lchol' is a function from the file /usr/share/octave/3.2.3/m/deprecated/lchol.m

 -- Loadable Function: L = lchol (A)
 -- Loadable Function: [L, P] = lchol (A)
     This function has been deprecated.  Use `chol (...,'lower')'
     instead.
}

#
lcm
{
`lcm' is a function from the file /usr/share/octave/3.2.3/m/elfun/lcm.m

 -- Mapping Function:  lcm (X)
 -- Mapping Function:  lcm (X, ...)
     Compute the least common multiple of the elements of X, or of the
     list of all arguments.  For example,

          lcm (a1, ..., ak)

     is the same as

          lcm ([a1, ..., ak]).

     All elements must be the same size or scalar.

     See also: factor, gcd
}

#
ldivide
{
`ldivide' is a built-in function

 -- Built-in Function:  ldivide (X, Y)
     This function is equivalent to `x .\ y'.
}

#
le
{
`le' is a built-in function

 -- Built-in Function:  le (X, Y)
     This function is equivalent to `x <= y'.
}

#
legend
{
`legend' is a function from the file /usr/share/octave/3.2.3/m/plot/legend.m

 -- Function File:  legend (ST1, ST2, ...)
 -- Function File:  legend (ST1, ST2, ..., "location", POS)
 -- Function File:  legend (MATSTR)
 -- Function File:  legend (MATSTR, "location", POS)
 -- Function File:  legend (CELL)
 -- Function File:  legend (CELL, "location", POS)
 -- Function File:  legend ('FUNC')
     Display a legend for the current axes using the specified strings
     as labels.  Legend entries may be specified as individual character
     string arguments, a character array, or a cell array of character
     strings.  Legend works on line graphs, bar graphs, etc.  A plot
     must exist before legend is called.

     The optional parameter POS specifies the location of the legend as
     follows:

          north      center top
          south      center bottom
          east       right center
          west       left center
          northeast  right top (default)
          northwest  left top
          southeast  right bottom
          southwest  left bottom

          outside    can be appended to any location string

     Some specific functions are directly available using FUNC:

    "show"
          Show legends from the plot

    "hide"
    "off"
          Hide legends from the plot

    "boxon"
          Draw a box around legends

    "boxoff"
          Withdraw the box around legends

    "left"
          Text is to the left of the keys

    "right"
          Text is to the right of the keys
}

#
legendre
{
`legendre' is a function from the file /usr/share/octave/3.2.3/m/specfun/legendre.m

 -- Function File: L = legendre (N, X)
 -- Function File: L = legendre (N, X, NORMALIZATION)
     Compute the Legendre function of degree N and order M = 0 ... N.
     The optional argument, NORMALIZATION, may be one of `"unnorm"',
     `"sch"', or `"norm"'.  The default is `"unnorm"'.  The value of N
     must be a non-negative scalar integer.

     If the optional argument NORMALIZATION is missing or is
     `"unnorm"', compute the Legendre function of degree N and order M
     and return all values for M = 0 ... N.  The return value has one
     dimension more than X.

     The Legendre Function of degree N and order M:

           m        m       2  m/2   d^m
          P(x) = (-1) * (1-x  )    * ----  P (x)
           n                         dx^m   n

     with Legendre polynomial of degree N:

                    1     d^n   2    n
          P (x) = ------ [----(x - 1)  ]
           n      2^n n!  dx^n

     `legendre (3, [-1.0, -0.9, -0.8])' returns the matrix:

           x  |   -1.0   |   -0.9   |  -0.8
          ------------------------------------
          m=0 | -1.00000 | -0.47250 | -0.08000
          m=1 |  0.00000 | -1.99420 | -1.98000
          m=2 |  0.00000 | -2.56500 | -4.32000
          m=3 |  0.00000 | -1.24229 | -3.24000

     If the optional argument `normalization' is `"sch"', compute the
     Schmidt semi-normalized associated Legendre function.  The Schmidt
     semi-normalized associated Legendre function is related to the
     unnormalized Legendre functions by the following:

     For Legendre functions of degree n and order 0:

            0       0
          SP (x) = P (x)
            n       n

     For Legendre functions of degree n and order m:

            m       m          m    2(n-m)! 0.5
          SP (x) = P (x) * (-1)  * [-------]
            n       n               (n+m)!

     If the optional argument NORMALIZATION is `"norm"', compute the
     fully normalized associated Legendre function.  The fully
     normalized associated Legendre function is related to the
     unnormalized Legendre functions by the following:

     For Legendre functions of degree N and order M

            m       m          m    (n+0.5)(n-m)! 0.5
          NP (x) = P (x) * (-1)  * [-------------]
            n       n                   (n+m)!
}

#
length
{
`length' is a built-in function

 -- Built-in Function:  length (A)
     Return the `length' of the object A.  For matrix objects, the
     length is the number of rows or columns, whichever is greater (this
     odd definition is used for compatibility with MATLAB).
}

#
lgamma
{
`lgamma' is a built-in function

 -- Mapping Function:  lgamma (X)
 -- Mapping Function:  gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc
}

#
license
{
`license' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/license.m

 -- Function File:  license
     Display the license of Octave.

 -- Function File:  license ("inuse")
     Display a list of packages currently being used.

 -- Function File: RETVAL = license ("inuse")
     Return a structure containing the fields `feature' and `user'.

 -- Function File: RETVAL = license ("test", FEATURE)
     Return 1 if a license exists for the product identified by the
     string FEATURE and 0 otherwise.  The argument FEATURE is case
     insensitive and only the first 27 characters are checked.

 -- Function File:  license ("test", FEATURE, TOGGLE)
     Enable or disable license testing for FEATURE, depending on
     TOGGLE, which may be one of:

    `"enable"'
          Future tests for the specified license of FEATURE are
          conducted as usual.

    `"disable"'
          Future tests for the specified license of FEATURE return 0.

 -- Function File: RETVAL = license ("checkout", FEATURE)
     Check out a license for FEATURE, returning 1 on success and 0 on
     failure.

     This function is provided for compatibility with MATLAB.

     See also: ver, version
}

#
lin2mu
{
`lin2mu' is a function from the file /usr/share/octave/3.2.3/m/audio/lin2mu.m

 -- Function File:  lin2mu (X, N)
     Converts audio data from linear to mu-law.  Mu-law values use 8-bit
     unsigned integers.  Linear values use N-bit signed integers or
     floating point values in the range -1<=X<=1 if N is 0.  If N is
     not specified it defaults to 0, 8 or 16 depending on the range
     values in X.

     See also: mu2lin, loadaudio, saveaudio, playaudio, setaudio, record
}

#
line
{
`line' is a function from the file /usr/share/octave/3.2.3/m/plot/line.m

 -- Function File:  line ()
 -- Function File:  line (X, Y)
 -- Function File:  line (X, Y, Z)
 -- Function File:  line (X, Y, Z, PROPERTY, VALUE, ...)
     Create line object from X and Y and insert in current axes object.
     Return a handle (or vector of handles) to the line objects created.

     Multiple property-value pairs may be specified for the line, but
     they must appear in pairs.
}

#
link
{
`link' is a built-in function

 -- Built-in Function: [ERR, MSG] = link (OLD, NEW)
     Create a new link (also known as a hard link) to an existing file.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: symlink
}

#
linkprop
{
`linkprop' is a function from the file /usr/share/octave/3.2.3/m/plot/linkprop.m

 -- Function File: HLINK = linkprop (H, PROP)
     Links graphics object properties, such that a change in one is
     propagated to the others.  The properties to link are given as a
     string of cell string array by PROP and the objects containing
     these properties by the handle array H.

     An example of the use of linkprops is

          x = 0:0.1:10;
          subplot (1, 2, 1);
          h1 = plot (x, sin (x));
          subplot (1, 2, 2);
          h2 = plot (x, cos (x));
          hlink = linkprop ([h1, h2], {"color","linestyle"});
          set (h1, "color", "green");
          set (h2, "linestyle", "--");
}

#
linspace
{
`linspace' is a built-in function

 -- Built-in Function:  linspace (BASE, LIMIT, N)
     Return a row vector with N linearly spaced elements between BASE
     and LIMIT.  If the number of elements is greater than one, then
     the BASE and LIMIT are always included in the range.  If BASE is
     greater than LIMIT, the elements are stored in decreasing order.
     If the number of points is not specified, a value of 100 is used.

     The `linspace' function always returns a row vector.

     For compatibility with MATLAB, return the second argument if fewer
     than two values are requested.
}

#
list
{
`list' is a built-in function

 -- Built-in Function:  list (A1, A2, ...)
     Create a new list with elements given by the arguments A1, A2, ....
}

#
list_in_columns
{
`list_in_columns' is a built-in function

 -- Built-in Function:  list_in_columns (ARG, WIDTH)
     Return a string containing the elements of ARG listed in columns
     with an overall maximum width of WIDTH.  The argument ARG must be
     a cell array of character strings or a character array.  If WIDTH
     is not specified, the width of the terminal screen is used.
     Newline characters are used to break the lines in the output
     string.  For example:

          list_in_columns ({"abc", "def", "ghijkl", "mnop", "qrs", "tuv"}, 20)
              => ans = abc     mnop
                     def     qrs
                     ghijkl  tuv

          whos ans
              =>
              Variables in the current scope:

                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     ans         1x37                        37  char

              Total is 37 elements using 37 bytes

     See also: terminal_size
}

#
list_primes
{
`list_primes' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/list_primes.m

 -- Function File:  list_primes (N)
     List the first N primes.  If N is unspecified, the first 25 primes
     are listed.

     The algorithm used is from page 218 of the TeXbook.

     See also: primes, isprime
}

#
load
{
`load' is a built-in function

 -- Command: load file
 -- Command: load options file
 -- Command: load options file v1 v2 ...
 -- Command: S = load("options", "file", "v1", "v2", ...)
     Load the named variables V1, V2, ..., from the file FILE.  If no
     variables are specified then all variables found in the file will
     be loaded.  As with `save', the list of variables to extract can
     be full names or use a pattern syntax.  The format of the file is
     automatically detected but may be overridden by supplying the
     appropriate option.

     If load is invoked using the functional form

          load ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

     If a variable that is not marked as global is loaded from a file
     when a global symbol with the same name already exists, it is
     loaded in the global symbol table.  Also, if a variable is marked
     as global in a file and a local symbol exists, the local symbol is
     moved to the global symbol table and given the value from the file.

     If invoked with a single output argument, Octave returns data
     instead of inserting variables in the symbol table.  If the data
     file contains only numbers (TAB- or space-delimited columns), a
     matrix of values is returned.  Otherwise, `load' returns a
     structure with members corresponding to the names of the variables
     in the file.

     The `load' command can read data stored in Octave's text and
     binary formats, and MATLAB's binary format.  If compiled with zlib
     support, it can also load gzip-compressed files.  It will
     automatically detect the type of file and do conversion from
     different floating point formats (currently only IEEE big and
     little endian, though other formats may be added in the future).

     Valid options for `load' are listed in the following table.

    `-force'
          This option is accepted for backward compatibility but is
          ignored.  Octave now overwrites variables currently in memory
          with those of the same name found in the file.

    `-ascii'
          Force Octave to assume the file contains columns of numbers
          in text format without any header or other information.  Data
          in the file will be loaded as a single numeric matrix with
          the name of the variable derived from the name of the file.

    `-binary'
          Force Octave to assume the file is in Octave's binary format.

    `-hdf5'
          Force Octave to assume the file is in HDF5 format.  (HDF5 is
          a free, portable binary format developed by the National
          Center for Supercomputing Applications at the University of
          Illinois.)  Note that Octave can read HDF5 files not created
          by itself, but may skip some datasets in formats that it
          cannot support.

    `-import'
          This option is accepted for backward compatibility but is
          ignored.  Octave can now support multi-dimensional HDF data
          and automatically modifies variable names if they are invalid
          Octave identifiers.

    `-mat'
    `-mat-binary'
    `-6'
    `-v6'
    `-7'
    `-v7'
          Force Octave to assume the file is in MATLAB's version 6 or 7
          binary format.

    `-mat4-binary'
    `-4'
    `-v4'
    `-V4'
          Force Octave to assume the file is in the binary format
          written by MATLAB version 4.

    `-text'
          Force Octave to assume the file is in Octave's text format.

     See also: save, dlmwrite, csvwrite, fwrite
}

#
loadaudio
{
`loadaudio' is a function from the file /usr/share/octave/3.2.3/m/audio/loadaudio.m

 -- Function File:  loadaudio (NAME, EXT, BPS)
     Loads audio data from the file `NAME.EXT' into the vector X.

     The extension EXT determines how the data in the audio file is
     interpreted;  the extensions `lin' (default) and `raw' correspond
     to linear, the extensions `au', `mu', or `snd' to mu-law encoding.

     The argument BPS can be either 8 (default) or 16, and specifies
     the number of bits per sample used in the audio file.

     See also: lin2mu, mu2lin, saveaudio, playaudio, setaudio, record
}

#
loadimage
{
`loadimage' is a function from the file /usr/share/octave/3.2.3/m/deprecated/loadimage.m

 -- Function File: [X, MAP] = loadimage (FILE)
     Load an image file and its associated color map from the specified
     FILE.  The image must be stored in Octave's image format.

     See also: saveimage, load, save
}

#
loadobj
{
`loadobj' is a function from the file /usr/share/octave/3.2.3/m/general/loadobj.m

 -- Function File: B = loadobj (A)
     Method of a class to manipulate an object after loading it from a
     file.  The function `loadobj' is called when the object A is loaded
     using the `load' function.  An example of the use of `saveobj'
     might be to add fields to an object that don't make sense to be
     saved.  For example

          function b = loadobj (a)
            b = a;
            b.addmissingfield = addfield (b);
          endfunction

     See also: saveobj, class
}

#
localtime
{
`localtime' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/time.oct

 -- Loadable Function:  localtime (T)
     Given a value returned from time (or any non-negative integer),
     return a time structure corresponding to the local time zone.

          localtime (time ())
              => {
                    usec = 0
                    year = 97
                    mon = 1
                    mday = 17
                    sec = 6
                    zone = CST
                    min = 15
                    wday = 1
                    hour = 1
                    isdst = 0
                    yday = 47
                  }

     See also: strftime, strptime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday
}

#
log
{
`log' is a built-in function

 -- Mapping Function:  log (X)
     Compute the natural logarithm, `ln (X)', for each element of X.
     To compute the matrix logarithm, see *note Linear Algebra::.

     See also: exp, log1p, log2, log10, logspace
}

#
log10
{
`log10' is a built-in function

 -- Mapping Function:  log10 (X)
     Compute the base-10 logarithm of each element of X.

     See also: log, log2, logspace, exp
}

#
log1p
{
`log1p' is a built-in function

 -- Mapping Function:  log1p (X)
     Compute `log (1 + X)' accurately in the neighborhood of zero.

     See also: log, exp, expm1
}

#
log2
{
`log2' is a built-in function

 -- Mapping Function:  log2 (X)
 -- Mapping Function: [F, E] = log2 (X)
     Compute the base-2 logarithm of each element of X.

     If called with two output arguments, split X into binary mantissa
     and exponent so that `1/2 <= abs(f) < 1' and E is an integer.  If
     `x = 0', `f = e = 0'.

     See also: pow2, log, log10, exp
}

#
logical
{
`logical' is a function from the file /usr/share/octave/3.2.3/m/general/logical.m

 -- Function File:  logical (ARG)
     Convert ARG to a logical value.  For example,

          logical ([-1, 0, 1])

     is equivalent to

          [-1, 0, 1] != 0
}

#
logistic_cdf
{
`logistic_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/logistic_cdf.m

 -- Function File:  logistic_cdf (X)
     For each component of X, compute the CDF at X of the logistic
     distribution.
}

#
logistic_inv
{
`logistic_inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/logistic_inv.m

 -- Function File:  logistic_inv (X)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the logistic distribution.
}

#
logistic_pdf
{
`logistic_pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/logistic_pdf.m

 -- Function File:  logistic_pdf (X)
     For each component of X, compute the PDF at X of the logistic
     distribution.
}

#
logistic_regression
{
`logistic_regression' is a function from the file /usr/share/octave/3.2.3/m/statistics/models/logistic_regression.m

 -- Function File: [THETA, BETA, DEV, DL, D2L, P] = logistic_regression
          (Y, X, PRINT, THETA, BETA)
     Perform ordinal logistic regression.

     Suppose Y takes values in K ordered categories, and let `gamma_i
     (X)' be the cumulative probability that Y falls in one of the
     first I categories given the covariate X.  Then

          [theta, beta] = logistic_regression (y, x)

     fits the model

          logit (gamma_i (x)) = theta_i - beta' * x,   i = 1 ... k-1

     The number of ordinal categories, K, is taken to be the number of
     distinct values of `round (Y)'.  If K equals 2, Y is binary and
     the model is ordinary logistic regression.  The matrix X is
     assumed to have full column rank.

     Given Y only, `theta = logistic_regression (y)' fits the model
     with baseline logit odds only.

     The full form is

          [theta, beta, dev, dl, d2l, gamma]
             = logistic_regression (y, x, print, theta, beta)

     in which all output arguments and all input arguments except Y are
     optional.

     Setting PRINT to 1 requests summary information about the fitted
     model to be displayed.  Setting PRINT to 2 requests information
     about convergence at each iteration.  Other values request no
     information to be displayed.  The input arguments THETA and BETA
     give initial estimates for THETA and BETA.

     The returned value DEV holds minus twice the log-likelihood.

     The returned values DL and D2L are the vector of first and the
     matrix of second derivatives of the log-likelihood with respect to
     THETA and BETA.

     P holds estimates for the conditional distribution of Y given X.
}

#
logistic_regression_derivatives
{
`logistic_regression_derivatives' is a function from the file /usr/share/octave/3.2.3/m/statistics/models/logistic_regression_derivatives.m

 -- Function File: [DL, D2L] = logistic_regression_derivatives (X, Z,
          Z1, G, G1, P)
     Called by logistic_regression.  Calculates derivates of the
     log-likelihood for ordinal logistic regression model.
}

#
logistic_regression_likelihood
{
`logistic_regression_likelihood' is a function from the file /usr/share/octave/3.2.3/m/statistics/models/logistic_regression_likelihood.m

 -- Function File: [G, G1, P, DEV] = logistic_regression_likelihood (Y,
          X, BETA, Z, Z1)
     Calculates likelihood for the ordinal logistic regression model.
     Called by logistic_regression.
}

#
logistic_rnd
{
`logistic_rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/logistic_rnd.m

 -- Function File:  logistic_rnd (R, C)
 -- Function File:  logistic_rnd (SZ)
     Return an R by C matrix of random numbers from the logistic
     distribution.  Or if SZ is a vector, create a matrix of SZ.
}

#
logit
{
`logit' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/logit.m

 -- Function File:  logit (P)
     For each component of P, return the logit of P defined as
          logit(P) = log (P / (1-P))
}

#
loglog
{
`loglog' is a function from the file /usr/share/octave/3.2.3/m/plot/loglog.m

 -- Function File:  loglog (ARGS)
     Produce a two-dimensional plot using log scales for both axes.  See
     the description of `plot' for a description of the arguments that
     `loglog' will accept.

     See also: plot, semilogx, semilogy
}

#
loglogerr
{
`loglogerr' is a function from the file /usr/share/octave/3.2.3/m/plot/loglogerr.m

 -- Function File:  loglogerr (ARGS)
     Produce two-dimensional plots on double logarithm axis with
     errorbars.  Many different combinations of arguments are possible.
     The most used form is

          loglogerr (X, Y, EY, FMT)

     which produces a double logarithm plot of Y versus X with errors
     in the Y-scale defined by EY and the plot format defined by FMT.
     See errorbar for available formats and additional information.

     See also: errorbar, semilogxerr, semilogyerr
}

#
logm
{
`logm' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/logm.m

 -- Function File:  logm (A)
     Compute the matrix logarithm of the square matrix A.  Note that
     this is currently implemented in terms of an eigenvalue expansion
     and needs to be improved to be more robust.
}

#
logncdf
{
`logncdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/logncdf.m

 -- Function File:  logncdf (X, MU, SIGMA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the lognormal distribution with parameters
     MU and SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 1, SIGMA = 1.
}

#
logninv
{
`logninv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/logninv.m

 -- Function File:  logninv (X, MU, SIGMA)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean `log (MU)' and
     variance SIGMA.

     Default values are MU = 1, SIGMA = 1.
}

#
lognormal_cdf
{
`lognormal_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/lognormal_cdf.m

 -- Function File:  lognormal_cdf (X, A, V)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the lognormal distribution with parameters
     A and V.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean `log (A)' and variance
     V.

     Default values are A = 1, V = 1.
}

#
lognormal_inv
{
`lognormal_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/lognormal_inv.m

 -- Function File:  lognormal_inv (X, A, V)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the lognormal distribution with parameters A and V.
     If a random variable follows this distribution, its logarithm is
     normally distributed with mean `log (A)' and variance V.

     Default values are A = 1, V = 1.
}

#
lognormal_pdf
{
`lognormal_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/lognormal_pdf.m

 -- Function File:  lognormal_pdf (X, A, V)
     For each element of X, compute the probability density function
     (PDF) at X of the lognormal distribution with parameters A and V.
     If a random variable follows this distribution, its logarithm is
     normally distributed with mean `log (A)' and variance V.

     Default values are A = 1, V = 1.
}

#
lognormal_rnd
{
`lognormal_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/lognormal_rnd.m

 -- Function File:  lognormal_rnd (A, V, R, C)
 -- Function File:  lognormal_rnd (A, V, SZ)
     Return an R by C matrix of random samples from the lognormal
     distribution with parameters A and V.  Both A and V must be scalar
     or of size R by C.  Or if SZ is a vector, create a matrix of size
     SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of A and V.
}

#
lognpdf
{
`lognpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/lognpdf.m

 -- Function File:  lognpdf (X, MU, SIGMA)
     For each element of X, compute the probability density function
     (PDF) at X of the lognormal distribution with parameters MU and
     SIGMA.  If a random variable follows this distribution, its
     logarithm is normally distributed with mean MU and standard
     deviation SIGMA.

     Default values are MU = 1, SIGMA = 1.
}

#
lognrnd
{
`lognrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/lognrnd.m

 -- Function File:  lognrnd (MU, SIGMA, R, C)
 -- Function File:  lognrnd (MU, SIGMA, SZ)
     Return an R by C matrix of random samples from the lognormal
     distribution with parameters MU and SIGMA.  Both MU and SIGMA must
     be scalar or of size R by C.  Or if SZ is a vector, create a
     matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of MU and SIGMA.
}

#
logspace
{
`logspace' is a function from the file /usr/share/octave/3.2.3/m/general/logspace.m

 -- Function File:  logspace (BASE, LIMIT, N)
     Similar to `linspace' except that the values are logarithmically
     spaced from 10^base to 10^limit.

     If LIMIT is equal to pi, the points are between 10^base and pi,
     _not_ 10^base and 10^pi, in order to be compatible with the
     corresponding MATLAB function.

     Also for compatibility, return the second argument if fewer than
     two values are requested.

     See also: linspace
}

#
lookfor
{
`lookfor' is a function from the file /usr/share/octave/3.2.3/m/help/lookfor.m

 -- Command: lookfor STR
 -- Command: lookfor -all STR
 -- Function: [FUNC, HELPSTRING] = lookfor (STR)
 -- Function: [FUNC, HELPSTRING] = lookfor ('-all', STR)
     Search for the string STR in all functions found in the current
     function search path.  By default, `lookfor' searches for STR in
     the first sentence of the help string of each function found.  The
     entire help text of each function can be searched if the '-all'
     argument is supplied.  All searches are case insensitive.

     Called with no output arguments, `lookfor' prints the list of
     matching functions to the terminal.  Otherwise, the output
     arguments FUNC and HELPSTRING define the matching functions and the
     first sentence of each of their help strings.

     The ability of `lookfor' to correctly identify the first sentence
     of the help text is dependent on the format of the function's
     help.  All Octave core functions are correctly formatted, but the
     same can not be guaranteed for external packages and user-supplied
     functions.  Therefore, the use of the '-all' argument may be
     necessary to find related functions that are not a part of Octave.

     See also: help, doc, which
}

#
lookup
{
`lookup' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/lookup.oct

 -- Loadable Function: IDX = lookup (TABLE, Y, OPT)
     Lookup values in a sorted table.  Usually used as a prelude to
     interpolation.

     If table is strictly increasing and `idx = lookup (table, y)', then
     `table(idx(i)) <= y(i) < table(idx(i+1))' for all `y(i)' within
     the table.  If `y(i) < table (1)' then `idx(i)' is 0. If `y(i) >=
     table(end)' then `idx(i)' is `table(n)'.

     If the table is strictly decreasing, then the tests are reversed.
     There are no guarantees for tables which are non-monotonic or are
     not strictly monotonic.

     The algorithm used by lookup is standard binary search, with
     optimizations to speed up the case of partially ordered arrays
     (dense downsampling).  In particular, looking up a single entry is
     of logarithmic complexity (unless a conversion occurs due to
     non-numeric or unequal types).

     TABLE and Y can also be cell arrays of strings (or Y can be a
     single string).  In this case, string lookup is performed using
     lexicographical comparison.

     If OPTS is specified, it shall be a string with letters indicating
     additional options.  For numeric lookup, 'l' in OPTS indicates that
     the leftmost subinterval shall be extended to infinity (i.e., all
     indices at least 1), and 'r' indicates that the rightmost
     subinterval shall be extended to infinity (i.e., all indices at
     most n-1).

     For string lookup, 'i' indicates case-insensitive comparison.
}

#
lower
{
`lower' is a built-in function

 -- Mapping Function:  tolower (S)
 -- Mapping Function:  lower (S)
     Return a copy of the string or cell string S, with each upper-case
     character replaced by the corresponding lower-case one;
     non-alphabetic characters are left unchanged.  For example,

          tolower ("MiXeD cAsE 123")
              => "mixed case 123"

     See also: toupper
}

#
ls
{
`ls' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/ls.m

 -- Command: ls options
     List directory contents.  For example,

          ls -l
               -| total 12
               -| -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
               -| -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m

     The `dir' and `ls' commands are implemented by calling your
     system's directory listing command, so the available options may
     vary from system to system.

     See also: dir, stat, readdir, glob, filesep, ls_command
}

#
ls_command
{
`ls_command' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/ls_command.m

 -- Function File: [OLD_CMD = ls_command (CMD)
     Set or return the shell command used by Octave's `ls' command.
     The value of CMD must be a character string.  With no arguments,
     simply return the previous value.

     See also: ls
}

#
lsode
{
`lsode' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/lsode.oct

 -- Loadable Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T, T_CRIT)
     Solve the set of differential equations

          dx
          -- = f(x, t)
          dt

     with

          x(t_0) = x_0

     The solution is returned in the matrix X, with each row
     corresponding to an element of the vector T.  The first element of
     T should be t_0 and should correspond to the initial state of the
     system X_0, so that the first row of the output is X_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of right
     hand sides for the set of equations.  The function must have the
     form

          XDOT = f (X, T)

     in which XDOT and X are vectors and T is a scalar.

     If FCN is a two-element string array or a two-element cell array
     of strings, inline functions, or function handles, the first
     element names the function f described above, and the second
     element names a function to compute the Jacobian of f.  The
     Jacobian function must have the form

          JAC = j (X, T)

     in which JAC is the matrix of partial derivatives

                      | df_1  df_1       df_1 |
                      | ----  ----  ...  ---- |
                      | dx_1  dx_2       dx_N |
                      |                       |
                      | df_2  df_2       df_2 |
                      | ----  ----  ...  ---- |
               df_i   | dx_1  dx_2       dx_N |
          jac = ---- = |                       |
               dx_j   |  .    .     .    .    |
                      |  .    .      .   .    |
                      |  .    .       .  .    |
                      |                       |
                      | df_N  df_N       df_N |
                      | ----  ----  ...  ---- |
                      | dx_1  dx_2       dx_N |

     The second and third arguments specify the initial state of the
     system, x_0, and the initial value of the independent variable t_0.

     The fourth argument is optional, and may be used to specify a set
     of times that the ODE solver should not integrate past.  It is
     useful for avoiding difficulties with singularities and points
     where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be 2
     (consistent with the Fortran version of LSODE).

     If the computation is not successful, ISTATE will be something
     other than 2 and MSG will contain additional information.

     You can use the function `lsode_options' to set optional
     parameters for `lsode'.

     See also: daspk, dassl, dasrt
}

#
lsode_options
{
`lsode_options' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/lsode.oct

 -- Loadable Function:  lsode_options (OPT, VAL)
     When called with two arguments, this function allows you set
     options parameters for the function `lsode'.  Given one argument,
     `lsode_options' returns the value of the corresponding option.  If
     no arguments are supplied, the names of all the available options
     and their current values are displayed.

     Options include

    `"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector.

    `"relative tolerance"'
          Relative tolerance parameter.  Unlike the absolute tolerance,
          this parameter may only be a scalar.

          The local error test applied at each integration step is

                abs (local error in x(i)) <= ...
                    rtol * abs (y(i)) + atol(i)

    `"integration method"'
          A string specifying the method of integration to use to solve
          the ODE system.  Valid values are

         "adams"
         "non-stiff"
               No Jacobian used (even if it is available).

         "bdf"

         "stiff"
               Use stiff backward differentiation formula (BDF) method.
               If a function to compute the Jacobian is not supplied,
               `lsode' will compute a finite difference approximation
               of the Jacobian matrix.

    `"initial step size"'
          The step size to be attempted on the first step (default is
          determined automatically).

    `"maximum order"'
          Restrict the maximum order of the solution method.  If using
          the Adams method, this option must be between 1 and 12.
          Otherwise, it must be between 1 and 5, inclusive.

    `"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions  (default is not specified).

    `"minimum step size"'
          The minimum absolute step size allowed (default is 0).

    `"step limit"'
          Maximum number of steps allowed (default is 100000).
}

#
lsqnonneg
{
`lsqnonneg' is a function from the file /usr/share/octave/3.2.3/m/optimization/lsqnonneg.m

 -- Function File: X = lsqnonneg (C, D)
 -- Function File: X = lsqnonneg (C, D, X0)
 -- Function File: [X, RESNORM] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG] = lsqnonneg (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT] = lsqnonneg
          (...)
 -- Function File: [X, RESNORM, RESIDUAL, EXITFLAG, OUTPUT, LAMBDA] =
lsqnonneg (...)
     Minimize `norm (C*X-d)' subject to `X >= 0'.  C and D must be
     real.  X0 is an optional initial guess for X.

     Outputs:
        * resnorm

          The squared 2-norm of the residual: norm(C*X-D)^2

        * residual

          The residual: D-C*X

        * exitflag

          An indicator of convergence.  0 indicates that the iteration
          count was exceeded, and therefore convergence was not
          reached; >0 indicates that the algorithm converged.  (The
          algorithm is stable and will converge given enough
          iterations.)

        * output

          A structure with two fields:
             * "algorithm": The algorithm used ("nnls")

             * "iterations": The number of iterations taken.

        * lambda

          Not implemented.

     See also: optimset
}

#
lstat
{
`lstat' is a built-in function

 -- Built-in Function: [INFO, ERR, MSG] = lstat (FILE)
     See stat.
}

#
lt
{
`lt' is a built-in function

 -- Built-in Function:  lt (X, Y)
     This function is equivalent to `x < y'.
}

#
lu
{
`lu' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/lu.oct

 -- Loadable Function: [L, U, P] = lu (A)
 -- Loadable Function: [L, U, P, Q] = lu (S)
 -- Loadable Function: [L, U, P, Q, R] = lu (S)
 -- Loadable Function: [...] = lu (S, THRES)
 -- Loadable Function: Y = lu (...)
 -- Loadable Function: [...] = lu (..., 'vector')
     Compute the LU decomposition of A.  If A is full subroutines from
     LAPACK are used and if A is sparse then UMFPACK is used.  The
     result is returned in a permuted form, according to the optional
     return value P.  For example, given the matrix `a = [1, 2; 3, 4]',

          [l, u, p] = lu (a)

     returns

          l =

           1.00000  0.00000
           0.33333  1.00000

          u =

           3.00000  4.00000
           0.00000  0.66667

          p =

           0  1
           1  0

     The matrix is not required to be square.

     Called with two or three output arguments and a spare input matrix,
     then "lu" does not attempt to perform sparsity preserving column
     permutations.  Called with a fourth output argument, the sparsity
     preserving column transformation Q is returned, such that `P * A *
     Q = L * U'.

     Called with a fifth output argument and a sparse input matrix, then
     "lu" attempts to use a scaling factor R on the input matrix such
     that `P * (R \ A) * Q = L * U'.  This typically leads to a sparser
     and more stable factorization.

     An additional input argument THRES, that defines the pivoting
     threshold can be given.  THRES can be a scalar, in which case it
     defines UMFPACK pivoting tolerance for both symmetric and
     unsymmetric cases.  If THRES is a two element vector, then the
     first element defines the pivoting tolerance for the unsymmetric
     UMFPACK pivoting strategy and the second the symmetric strategy.
     By default, the values defined by `spparms' are used and are by
     default `[0.1, 0.001]'.

     Given the string argument 'vector', "lu" returns the values of P Q
     as vector values, such that for full matrix, `A (P,:) = L * U',
     and `R(P,:) * A (:, Q) = L * U'.

     With two output arguments, returns the permuted forms of the upper
     and lower triangular matrices, such that `A = L * U'.  With one
     output argument Y, then the matrix returned by the LAPACK routines
     is returned.  If the input matrix is sparse then the matrix L is
     embedded into U to give a return value similar to the full case.
     For both full and sparse matrices, "lu" looses the permutation
     information.
}

#
luinc
{
`luinc' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/luinc.oct

 -- Loadable Function: [L, U, P, Q] = luinc (A, '0')
 -- Loadable Function: [L, U, P, Q] = luinc (A, DROPTOL)
 -- Loadable Function: [L, U, P, Q] = luinc (A, OPTS)
     Produce the incomplete LU factorization of the sparse matrix A.
     Two types of incomplete factorization are possible, and the type
     is determined by the second argument to "luinc".

     Called with a second argument of '0', the zero-level incomplete LU
     factorization is produced.  This creates a factorization of A
     where the position of the non-zero arguments correspond to the same
     positions as in the matrix A.

     Alternatively, the fill-in of the incomplete LU factorization can
     be controlled through the variable DROPTOL or the structure OPTS.
     The UMFPACK multifrontal factorization code by Tim A.  Davis is
     used for the incomplete LU factorization, (availability
     `http://www.cise.ufl.edu/research/sparse/umfpack/')

     DROPTOL determines the values below which the values in the LU
     factorization are dropped and replaced by zero.  It must be a
     positive scalar, and any values in the factorization whose
     absolute value are less than this value are dropped, expect if
     leaving them increase the sparsity of the matrix.  Setting DROPTOL
     to zero results in a complete LU factorization which is the
     default.

     OPTS is a structure containing one or more of the fields

    `droptol'
          The drop tolerance as above.  If OPTS only contains `droptol'
          then this is equivalent to using the variable DROPTOL.

    `milu'
          A logical variable flagging whether to use the modified
          incomplete LU factorization.  In the case that `milu' is
          true, the dropped values are subtracted from the diagonal of
          the matrix U of the factorization.  The default is `false'.

    `udiag'
          A logical variable that flags whether zero elements on the
          diagonal of U should be replaced with DROPTOL to attempt to
          avoid singular factors.  The default is `false'.

    `thresh'
          Defines the pivot threshold in the interval [0,1].  Values
          outside that range are ignored.

     All other fields in OPTS are ignored.  The outputs from "luinc"
     are the same as for "lu".

     Given the string argument 'vector', "luinc" returns the values of P
     Q as vector values.

     See also: sparse, lu
}

#
magic
{
`magic' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/magic.m

 -- Function File:  magic (N)
     Create an N-by-N magic square.  Note that `magic (2)' is undefined
     since there is no 2-by-2 magic square.
}

#
mahalanobis
{
`mahalanobis' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/mahalanobis.m

 -- Function File:  mahalanobis (X, Y)
     Return the Mahalanobis' D-square distance between the multivariate
     samples X and Y, which must have the same number of components
     (columns), but may have a different number of observations (rows).
}

#
make_absolute_filename
{
`make_absolute_filename' is a built-in function

 -- Built-in Function:  make_absolute_filename (FILE)
     Return the full name of FILE, relative to the current directory.
}

#
makeinfo_program
{
`makeinfo_program' is a built-in function

 -- Built-in Function: VAL = makeinfo_program ()
 -- Built-in Function: OLD_VAL = makeinfo_program (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     program that Octave runs to format help text containing Texinfo
     markup commands.  The default value is `makeinfo'.

     See also: info_file, info_program, doc, help
}

#
manova
{
`manova' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/manova.m

 -- Function File:  manova (Y, G)
     Perform a one-way multivariate analysis of variance (MANOVA).  The
     goal is to test whether the p-dimensional population means of data
     taken from K different groups are all equal.  All data are assumed
     drawn independently from p-dimensional normal distributions with
     the same covariance matrix.

     The data matrix is given by Y.  As usual, rows are observations
     and columns are variables.  The vector G specifies the
     corresponding group labels (e.g., numbers from 1 to K).

     The LR test statistic (Wilks' Lambda) and approximate p-values are
     computed and displayed.
}

#
mark_as_command
{
`mark_as_command' is a function from the file /usr/share/octave/3.2.3/m/deprecated/mark_as_command.m

 -- Built-in Function:  mark_as_command (NAME)
     This function is obsolete and will be removed from a future
     version of Octave.
}

#
mark_as_rawcommand
{
`mark_as_rawcommand' is a function from the file /usr/share/octave/3.2.3/m/deprecated/mark_as_rawcommand.m

 -- Built-in Function:  mark_as_rawcommand (NAME)
     This function is obsolete and will be removed from a future
     version of Octave.
}

#
mat2cell
{
`mat2cell' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/cellfun.oct

 -- Loadable Function: B = mat2cell (A, M, N)
 -- Loadable Function: B = mat2cell (A, D1, D2, ...)
 -- Loadable Function: B = mat2cell (A, R)
     Convert the matrix A to a cell array.  If A is 2-D, then it is
     required that `sum (M) == size (A, 1)' and `sum (N) == size (A,
     2)'.  Similarly, if A is a multi-dimensional and the number of
     dimensional arguments is equal to the dimensions of A, then it is
     required that `sum (DI) == size (A, i)'.

     Given a single dimensional argument R, the other dimensional
     arguments are assumed to equal `size (A,I)'.

     An example of the use of mat2cell is

          mat2cell (reshape(1:16,4,4),[3,1],[3,1])
          => {
           [1,1] =

              1   5   9
              2   6  10
              3   7  11

           [2,1] =

              4   8  12

           [1,2] =

             13
             14
             15

           [2,2] = 16
          }

     See also: num2cell, cell2mat
}

#
mat2str
{
`mat2str' is a function from the file /usr/share/octave/3.2.3/m/strings/mat2str.m

 -- Function File: S = mat2str (X, N)
 -- Function File: S = mat2str (..., 'class')
     Format real/complex numerical matrices as strings.  This function
     returns values that are suitable for the use of the `eval'
     function.

     The precision of the values is given by N.  If N is a scalar then
     both real and imaginary parts of the matrix are printed to the
     same precision.  Otherwise `N (1)' defines the precision of the
     real part and `N (2)' defines the precision of the imaginary part.
     The default for N is 17.

     If the argument 'class' is given, then the class of X is included
     in the string in such a way that the eval will result in the
     construction of a matrix of the same class.

          mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
               => "[-0.3333+0.14i;0.3333-0.14i]"

          mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
               => "[-0.3333+0i,0+0.14i;0.3333+0i,-0-0.14i]"

          mat2str (int16([1 -1]), 'class')
               => "int16([1,-1])"

     See also: sprintf, num2str, int2str
}

#
matlabroot
{
`matlabroot' is a function from the file /usr/share/octave/3.2.3/m/path/matlabroot.m

 -- Function File: VAL = matlabroot ()
     Return the location of Octave's home.

     See also: OCTAVE_HOME
}

#
matrix_type
{
`matrix_type' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/matrix_type.oct

 -- Loadable Function: TYPE = matrix_type (A)
 -- Loadable Function: A = matrix_type (A, TYPE)
 -- Loadable Function: A = matrix_type (A, 'upper', PERM)
 -- Loadable Function: A = matrix_type (A, 'lower', PERM)
 -- Loadable Function: A = matrix_type (A, 'banded', NL, NU)
     Identify the matrix type or mark a matrix as a particular type.
     This allows rapid for solutions of linear equations involving A to
     be performed.  Called with a single argument, `matrix_type'
     returns the type of the matrix and caches it for future use.
     Called with more than one argument, `matrix_type' allows the type
     of the matrix to be defined.

     The possible matrix types depend on whether the matrix is full or
     sparse, and can be one of the following

    'unknown'
          Remove any previously cached matrix type, and mark type as
          unknown

    'full'
          Mark the matrix as full.

    'positive definite'
          Probable full positive definite matrix.

    'diagonal'
          Diagonal Matrix.  (Sparse matrices only)

    'permuted diagonal'
          Permuted Diagonal matrix.  The permutation does not need to
          be specifically indicated, as the structure of the matrix
          explicitly gives this.  (Sparse matrices only)

    'upper'
          Upper triangular.  If the optional third argument PERM is
          given, the matrix is assumed to be a permuted upper
          triangular with the permutations defined by the vector PERM.

    'lower'
          Lower triangular.  If the optional third argument PERM is
          given, the matrix is assumed to be a permuted lower
          triangular with the permutations defined by the vector PERM.

    'banded'
    'banded positive definite'
          Banded matrix with the band size of NL below the diagonal and
          NU above it.  If NL and NU are 1, then the matrix is
          tridiagonal and treated with specialized code.  In addition
          the matrix can be marked as probably a positive definite
          (Sparse matrices only)

    'singular'
          The matrix is assumed to be singular and will be treated with
          a minimum norm solution


     Note that the matrix type will be discovered automatically on the
     first attempt to solve a linear equation involving A.  Therefore
     `matrix_type' is only useful to give Octave hints of the matrix
     type.  Incorrectly defining the matrix type will result in
     incorrect results from solutions of linear equations, and so it is
     entirely the responsibility of the user to correctly identify the
     matrix type.

     Also the test for positive definiteness is a low-cost test for a
     hermitian matrix with a real positive diagonal.  This does not
     guarantee that the matrix is positive definite, but only that it
     is a probable candidate.  When such a matrix is factorized, a
     Cholesky factorization is first attempted, and if that fails the
     matrix is then treated with an LU factorization.  Once the matrix
     has been factorized, `matrix_type' will return the correct
     classification of the matrix.
}

#
max
{
`max' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/max.oct

 -- Loadable Function:  max (X)
 -- Loadable Function:  max (X, Y)
 -- Loadable Function:  max (X, Y, DIM)
 -- Loadable Function: [W, IW] = max (X)
     For a vector argument, return the maximum value.  For a matrix
     argument, return the maximum value from each column, as a row
     vector, or over the dimension DIM if defined.  For two matrices
     (or a matrix and scalar), return the pair-wise maximum.  Thus,

          max (max (X))

     returns the largest element of the matrix X, and

          max (2:5, pi)
             =>  3.1416  3.1416  4.0000  5.0000
     compares each element of the range `2:5' with `pi', and returns a
     row vector of the maximum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, `max' also
     returns the first index of the maximum value(s).  Thus,

          [x, ix] = max ([1, 3, 5, 2, 5])
             =>  x = 5
                 ix = 3

     See also: min, cummax, cummin
}

#
max_recursion_depth
{
`max_recursion_depth' is a built-in function

 -- Built-in Function: VAL = max_recursion_depth ()
 -- Built-in Function: OLD_VAL = max_recursion_depth (NEW_VAL)
     Query or set the internal limit on the number of times a function
     may be called recursively.  If the limit is exceeded, an error
     message is printed and control returns to the top level.
}

#
mcnemar_test
{
`mcnemar_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/mcnemar_test.m

 -- Function File: [PVAL, CHISQ, DF] = mcnemar_test (X)
     For a square contingency table X of data cross-classified on the
     row and column variables, McNemar's test can be used for testing
     the null hypothesis of symmetry of the classification
     probabilities.

     Under the null, CHISQ is approximately distributed as chisquare
     with DF degrees of freedom.

     The p-value (1 minus the CDF of this distribution at CHISQ) is
     returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
md5sum
{
`md5sum' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/md5sum.oct

 -- Loadable Function:  md5sum (FILE)
 -- Loadable Function:  md5sum (STR, OPT)
     Calculates the MD5 sum of the file FILE.  If the second parameter
     OPT exists and is true, then calculate the MD5 sum of the string
     STR.
}

#
mean
{
`mean' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/mean.m

 -- Function File:  mean (X, DIM, OPT)
     If X is a vector, compute the mean of the elements of X

          mean (x) = SUM_i x(i) / N
     If X is a matrix, compute the mean for each column and return them
     in a row vector.

     With the optional argument OPT, the kind of mean computed can be
     selected.  The following options are recognized:

    `"a"'
          Compute the (ordinary) arithmetic mean.  This is the default.

    `"g"'
          Compute the geometric mean.

    `"h"'
          Compute the harmonic mean.

     If the optional argument DIM is supplied, work along dimension DIM.

     Both DIM and OPT are optional.  If both are supplied, either may
     appear first.
}

#
meansq
{
`meansq' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/meansq.m

 -- Function File:  meansq (X)
 -- Function File:  meansq (X, DIM)
     For vector arguments, return the mean square of the values.  For
     matrix arguments, return a row vector containing the mean square
     of each column.  With the optional DIM argument, returns the mean
     squared of the values along this dimension.
}

#
median
{
`median' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/median.m

 -- Function File:  median (X, DIM)
     If X is a vector, compute the median value of the elements of X.
     If the elements of X are sorted, the median is defined as

                      x(ceil(N/2)),             N odd
          median(x) =
                      (x(N/2) + x((N/2)+1))/2,  N even
     If X is a matrix, compute the median value for each column and
     return them in a row vector.  If the optional DIM argument is
     given, operate along this dimension.

     See also: std, mean
}

#
menu
{
`menu' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/menu.m

 -- Function File:  menu (TITLE, OPT1, ...)
     Print a title string followed by a series of options.  Each option
     will be printed along with a number.  The return value is the
     number of the option selected by the user.  This function is
     useful for interactive programs.  There is no limit to the number
     of options that may be passed in, but it may be confusing to
     present more than will fit easily on one screen.

     See also: disp, printf, input
}

#
mesh
{
`mesh' is a function from the file /usr/share/octave/3.2.3/m/plot/mesh.m

 -- Function File:  mesh (X, Y, Z)
     Plot a mesh given matrices X, and Y from `meshgrid' and a matrix Z
     corresponding to the X and Y coordinates of the mesh.  If X and Y
     are vectors, then a typical vertex is (X(j), Y(i), Z(i,j)).  Thus,
     columns of Z correspond to different X values and rows of Z
     correspond to different Y values.

     See also: meshgrid, contour
}

#
meshc
{
`meshc' is a function from the file /usr/share/octave/3.2.3/m/plot/meshc.m

 -- Function File:  meshc (X, Y, Z)
     Plot a mesh and contour given matrices X, and Y from `meshgrid'
     and a matrix Z corresponding to the X and Y coordinates of the
     mesh.  If X and Y are vectors, then a typical vertex is (X(j),
     Y(i), Z(i,j)).  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     See also: meshgrid, mesh, contour
}

#
meshdom
{
`meshdom' is a function from the file /usr/share/octave/3.2.3/m/deprecated/meshdom.m

 -- Function File:  meshdom (X, Y)
     This function has been deprecated.  Use `meshgrid' instead.
}

#
meshgrid
{
`meshgrid' is a function from the file /usr/share/octave/3.2.3/m/plot/meshgrid.m

 -- Function File: [XX, YY, ZZ] = meshgrid (X, Y, Z)
 -- Function File: [XX, YY] = meshgrid (X, Y)
 -- Function File: [XX, YY] = meshgrid (X)
     Given vectors of X and Y and Z coordinates, and returning 3
     arguments, return three-dimensional arrays corresponding to the X,
     Y, and Z coordinates of a mesh.  When returning only 2 arguments,
     return matrices corresponding to the X and Y coordinates of a
     mesh.  The rows of XX are copies of X, and the columns of YY are
     copies of Y.  If Y is omitted, then it is assumed to be the same
     as X, and Z is assumed the same as Y.

     See also: mesh, contour
}

#
meshz
{
`meshz' is a function from the file /usr/share/octave/3.2.3/m/plot/meshz.m

 -- Function File:  meshz (X, Y, Z)
     Plot a curtain mesh given matrices X, and Y from `meshgrid' and a
     matrix Z corresponding to the X and Y coordinates of the mesh.  If
     X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.

     See also: meshgrid, mesh, contour
}

#
methods
{
`methods' is a built-in function

 -- Built-in Function:  methods (X)
 -- Built-in Function:  methods ("classname")
     Return a cell array containing the names of the methods for the
     object X or the named class.
}

#
mex
{
`mex' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/mex.m

 -- Function File:  mex [options] file ...
     Compile source code written in C, C++, or Fortran, to a MEX file.
     This is equivalent to `mkoctfile --mex [options] file'.

     See also: mkoctfile
}

#
mexext
{
`mexext' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/mexext.m

 -- Function File:  mexext ()
     Return the filename extension used for MEX files.
}

#
mfilename
{
`mfilename' is a built-in function

 -- Built-in Function:  mfilename ()
 -- Built-in Function:  mfilename (`"fullpath"')
 -- Built-in Function:  mfilename (`"fullpathext"')
     Return the name of the currently executing file.  At the top-level,
     return the empty string.  Given the argument `"fullpath"', include
     the directory part of the file name, but not the extension.  Given
     the argument `"fullpathext"', include the directory part of the
     file name and the extension.
}

#
min
{
`min' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/max.oct

 -- Loadable Function:  min (X)
 -- Loadable Function:  min (X, Y)
 -- Loadable Function:  min (X, Y, DIM)
 -- Loadable Function: [W, IW] = min (X)
     For a vector argument, return the minimum value.  For a matrix
     argument, return the minimum value from each column, as a row
     vector, or over the dimension DIM if defined.  For two matrices
     (or a matrix and scalar), return the pair-wise minimum.  Thus,

          min (min (X))

     returns the smallest element of X, and

          min (2:5, pi)
             =>  2.0000  3.0000  3.1416  3.1416
     compares each element of the range `2:5' with `pi', and returns a
     row vector of the minimum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, `min' also
     returns the first index of the minimum value(s).  Thus,

          [x, ix] = min ([1, 3, 0, 2, 0])
             =>  x = 0
                 ix = 3

     See also: max, cummin, cummax
}

#
minus
{
`minus' is a built-in function

 -- Built-in Function:  minus (X, Y)
     This function is equivalent to `x - y'.
}

#
mislocked
{
`mislocked' is a built-in function

 -- Built-in Function:  mislocked (FCN)
     Return true if the named function is locked.  If no function is
     named then return true if the current function is locked.

     See also: mlock, munlock, persistent
}

#
mkdir
{
`mkdir' is a built-in function

 -- Built-in Function: [STATUS, MSG, MSGID] = mkdir (DIR)
 -- Built-in Function: [STATUS, MSG, MSGID] = mkdir (PARENT, DIR)
     Create a directory named DIR in the directory PARENT.

     If successful, STATUS is 1, with MSG and MSGID empty character
     strings.  Otherwise, STATUS is 0, MSG contains a system-dependent
     error message, and MSGID contains a unique message identifier.

     See also: rmdir
}

#
mkfifo
{
`mkfifo' is a built-in function

 -- Built-in Function: [ERR, MSG] = mkfifo (NAME, MODE)
     Create a FIFO special file named NAME with file mode MODE

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.
}

#
mkoctfile
{
`mkoctfile' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/mkoctfile.m

 -- Function File:  mkoctfile [-options] file ...
     The `mkoctfile' function compiles source code written in C, C++,
     or Fortran.  Depending on the options used with `mkoctfile', the
     compiled code can be called within Octave or can be used as a
     stand-alone application.

     `mkoctfile' can be called from the shell prompt or from the Octave
     prompt.

     `mkoctfile' accepts the following options, all of which are
     optional except for the file name of the code you wish to compile:

    `-I DIR'
          Add the include directory DIR to compile commands.

    `-D DEF'
          Add the definition DEF to the compiler call.

    `-l LIB'
          Add the library LIB to the link command.

    `-L DIR'
          Add the library directory DIR to the link command.

    `-M'
    `--depend'
          Generate dependency files (.d) for C and C++ source files.

    `-c'
          Compile but do not link.

    `-g'
          Enable debugging options for compilers.

    `-o FILE'
    `--output FILE'
          Output file name.  Default extension is .oct (or .mex if -mex
          is specified) unless linking a stand-alone executable.

    `-p VAR'
    `--print VAR'
          Print the configuration variable VAR.  Recognized variables
          are:

                  ALL_CFLAGS                FFTW_LIBS
                  ALL_CXXFLAGS              FLIBS
                  ALL_FFLAGS                FPICFLAG
                  ALL_LDFLAGS               INCFLAGS
                  BLAS_LIBS                 LDFLAGS
                  CC                        LD_CXX
                  CFLAGS                    LD_STATIC_FLAG
                  CPICFLAG                  LFLAGS
                  CPPFLAGS                  LIBCRUFT
                  CXX                       LIBOCTAVE
                  CXXFLAGS                  LIBOCTINTERP
                  CXXPICFLAG                LIBREADLINE
                  DEPEND_EXTRA_SED_PATTERN  LIBS
                  DEPEND_FLAGS              OCTAVE_LIBS
                  DL_LD                     RDYNAMIC_FLAG
                  DL_LDFLAGS                RLD_FLAG
                  F2C                       SED
                  F2CFLAGS                  XTRA_CFLAGS
                  F77                       XTRA_CXXFLAGS
                  FFLAGS

    `--link-stand-alone'
          Link a stand-alone executable file.

    `--mex'
          Assume we are creating a MEX file.  Set the default output
          extension to ".mex".

    `-s'
    `--strip'
          Strip the output file.

    `-v'
    `--verbose'
          Echo commands as they are executed.

    `file'
          The file to compile or link.  Recognized file types are

                                 .c    C source
                                 .cc   C++ source
                                 .C    C++ source
                                 .cpp  C++ source
                                 .f    Fortran source
                                 .F    Fortran source
                                 .o    object file
}

#
mkpp
{
`mkpp' is a function from the file /usr/share/octave/3.2.3/m/polynomial/mkpp.m

 -- Function File: PP = mkpp (X, P)
 -- Function File: PP = mkpp (X, P, D)
     Construct a piece-wise polynomial structure from sample points X
     and coefficients P.  The i-th row of P, `P (I,:)', contains the
     coefficients for the polynomial over the I-th interval, ordered
     from highest to lowest.  There must be one row for each interval
     in X, so `rows (P) == length (X) - 1'.

     You can concatenate multiple polynomials of the same order over the
     same set of intervals using `P = [ P1; P2; ...; PD ]'.  In this
     case, `rows (P) == D * (length (X) - 1)'.

     D specifies the shape of the matrix P for all except the last
     dimension.  If D is not specified it will be computed as `round
     (rows (P) / (length (X) - 1))' instead.

     See also: unmkpp, ppval, spline
}

#
mkstemp
{
`mkstemp' is a built-in function

 -- Built-in Function: [FID, NAME, MSG] = mkstemp (TEMPLATE, DELETE)
     Return the file ID corresponding to a new temporary file with a
     unique name created from TEMPLATE.  The last six characters of
     TEMPLATE must be `XXXXXX' and these are replaced with a string
     that makes the filename unique.  The file is then created with
     mode read/write and permissions that are system dependent (on
     GNU/Linux systems, the permissions will be 0600 for versions of
     glibc 2.0.7 and later).  The file is opened with the `O_EXCL' flag.

     If the optional argument DELETE is supplied and is true, the file
     will be deleted automatically when Octave exits, or when the
     function `purge_tmp_files' is called.

     If successful, FID is a valid file ID, NAME is the name of the
     file, and MSG is an empty string.  Otherwise, FID is -1, NAME is
     empty, and MSG contains a system-dependent error message.

     See also: tmpfile, tmpnam, P_tmpdir
}

#
mktime
{
`mktime' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/time.oct

 -- Loadable Function:  mktime (TM_STRUCT)
     Convert a time structure corresponding to the local time to the
     number of seconds since the epoch.  For example,

          mktime (localtime (time ()))
              => 856163706

     See also: strftime, strptime, localtime, gmtime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday
}

#
mldivide
{
`mldivide' is a built-in function

 -- Built-in Function:  mldivide (X, Y)
     This function is equivalent to `x \ y'.
}

#
mlock
{
`mlock' is a built-in function

 -- Built-in Function:  mlock ()
     Lock the current function into memory so that it can't be cleared.

     See also: munlock, mislocked, persistent
}

#
mod
{
`mod' is a function from the file /usr/share/octave/3.2.3/m/general/mod.m

 -- Mapping Function:  mod (X, Y)
     Compute the modulo of X and Y.  Conceptually this is given by

          x - y .* floor (x ./ y)

     and is written such that the correct modulus is returned for
     integer types.  This function handles negative values correctly.
     That is, `mod (-1, 3)' is 2, not -1, as `rem (-1, 3)' returns.
     `mod (X, 0)' returns X.

     An error results if the dimensions of the arguments do not agree,
     or if either of the arguments is complex.

     See also: rem, fmod
}

#
mode
{
`mode' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/mode.m

 -- Function File: [M, F, C] = mode (X, DIM)
     Count the most frequently appearing value.  `mode' counts the
     frequency along the first non-singleton dimension and if two or
     more values have the same frequency returns the smallest of the
     two in M.  The dimension along which to count can be specified by
     the DIM parameter.

     The variable F counts the frequency of each of the most frequently
     occurring elements.  The cell array C contains all of the elements
     with the maximum frequency .
}

#
moment
{
`moment' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/moment.m

 -- Function File:  moment (X, P, OPT, DIM)
     If X is a vector, compute the P-th moment of X.

     If X is a matrix, return the row vector containing the P-th moment
     of each column.

     With the optional string opt, the kind of moment to be computed can
     be specified.  If opt contains `"c"' or `"a"', central and/or
     absolute moments are returned.  For example,

          moment (x, 3, "ac")

     computes the third central absolute moment of X.

     If the optional argument DIM is supplied, work along dimension DIM.
}

#
more
{
`more' is a built-in function

 -- Command: more
 -- Command: more on
 -- Command: more off
     Turn output pagination on or off.  Without an argument, `more'
     toggles the current state.  The current state can be determined
     via `page_screen_output'.
}

#
movefile
{
`movefile' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/movefile.m

 -- Function File: [STATUS, MSG, MSGID] = movefile (F1, F2)
     Move the file F1 to the new name F2.  The name F1 may contain
     globbing patterns.  If F1 expands to multiple file names, F2 must
     be a directory.

     If successful, STATUS is 1, with MSG and MSGID empty\n\ character
     strings.  Otherwise, STATUS is 0, MSG contains a\n\
     system-dependent error message, and MSGID contains a unique\n\
     message identifier.\n\

     See also: glob
}

#
mpoles
{
`mpoles' is a function from the file /usr/share/octave/3.2.3/m/polynomial/mpoles.m

 -- Function File: [MULTP, INDX] = mpoles (P)
 -- Function File: [MULTP, INDX] = mpoles (P, TOL)
 -- Function File: [MULTP, INDX] = mpoles (P, TOL, REORDER)
     Identify unique poles in P and associates their multiplicity,
     ordering them from largest to smallest.

     If the relative difference of the poles is less than TOL, then
     they are considered to be multiples.  The default value for TOL is
     0.001.

     If the optional parameter REORDER is zero, poles are not sorted.

     The value MULTP is a vector specifying the multiplicity of the
     poles.  MULTP(:) refers to multiplicity of P(INDX(:)).

     For example,

          p = [2 3 1 1 2];
          [m, n] = mpoles(p);
            => m = [1; 1; 2; 1; 2]
            => n = [2; 5; 1; 4; 3]
            => p(n) = [3, 2, 2, 1, 1]

     See also: poly, roots, conv, deconv, polyval, polyderiv,
     polyinteg, residue
}

#
mpower
{
`mpower' is a built-in function

 -- Built-in Function:  mpower (X, Y)
     This function is equivalent to `x ^ y'.
}

#
mrdivide
{
`mrdivide' is a built-in function

 -- Built-in Function:  mrdivide (X, Y)
     This function is equivalent to `x / y'.
}

#
mtimes
{
`mtimes' is a built-in function

 -- Built-in Function:  mtimes (X, Y)
     This function is equivalent to `x * y'.
}

#
mu2lin
{
`mu2lin' is a function from the file /usr/share/octave/3.2.3/m/audio/mu2lin.m

 -- Function File:  mu2lin (X, BPS)
     Converts audio data from linear to mu-law.  Mu-law values are 8-bit
     unsigned integers.  Linear values use N-bit signed integers or
     floating point values in the range -1<=y<=1 if N is 0.  If N is
     not specified it defaults to 8.

     See also: lin2mu, loadaudio, saveaudio, playaudio, setaudio, record
}

#
munlock
{
`munlock' is a built-in function

 -- Built-in Function:  munlock (FCN)
     Unlock the named function.  If no function is named then unlock
     the current function.

     See also: mlock, mislocked, persistent
}

#
namelengthmax
{
`namelengthmax' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/namelengthmax.m

 -- Function File:  namelengthmax ()
     Returns the MATLAB compatible maximum variable name length.
     Octave is capable of storing strings up to `2 ^ 31 - 1' in length.
     However for MATLAB compatibility all variable, function and
     structure field names should be shorter than the length supplied by
     `namelengthmax'.  In particular variables stored to a MATLAB file
     format will have their names truncated to this length.
}

#
nan
{
`nan' is a built-in function

 -- Built-in Function:  NaN
 -- Built-in Function:  NaN (N)
 -- Built-in Function:  NaN (N, M)
 -- Built-in Function:  NaN (N, M, K, ...)
 -- Built-in Function:  NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the IEEE symbol NaN (Not a Number).  NaN is the
     result of operations which do not produce a well defined numerical
     result.  Common operations which produce a NaN are arithmetic with
     infinity (Inf - Inf), zero divided by zero (0/0), and any
     operation involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN).  This
     behavior is specified by the IEEE standard for floating point
     arithmetic.  To find NaN values, use the `isnan' function.

     When called with no arguments, return a scalar with the value
     `NaN'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isnan
}

#
nargchk
{
`nargchk' is a function from the file /usr/share/octave/3.2.3/m/general/nargchk.m

 -- Function File: MSGSTR = nargchk (MINARGS, MAXARGS, NARGS)
 -- Function File: MSGSTR = nargchk (MINARGS, MAXARGS, NARGS, "string")
 -- Function File: MSGSTRUCT = nargchk (MINARGS, MAXARGS, NARGS,
          "struct")
     Return an appropriate error message string (or structure) if the
     number of inputs requested is invalid.

     This is useful for checking to see that the number of input
     arguments supplied to a function is within an acceptable range.

     See also: nargoutchk, error, nargin, nargout
}

#
nargin
{
`nargin' is a built-in function

 -- Built-in Function:  nargin ()
 -- Built-in Function:  nargin (FCN_NAME)
     Within a function, return the number of arguments passed to the
     function.  At the top level, return the number of command line
     arguments passed to Octave.  If called with the optional argument
     FCN_NAME, return the maximum number of arguments the named
     function can accept, or -1 if the function accepts a variable
     number of arguments.

     See also: nargout, varargin, varargout
}

#
nargout
{
`nargout' is a built-in function

 -- Built-in Function:  nargout ()
 -- Built-in Function:  nargout (FCN_NAME)
     Within a function, return the number of values the caller expects
     to receive.  If called with the optional argument FCN_NAME, return
     the maximum number of values the named function can produce, or -1
     if the function can produce a variable number of values.

     For example,

          f ()

     will cause `nargout' to return 0 inside the function `f' and

          [s, t] = f ()

     will cause `nargout' to return 2 inside the function `f'.

     At the top level, `nargout' is undefined.

     See also: nargin, varargin, varargout
}

#
nargoutchk
{
`nargoutchk' is a function from the file /usr/share/octave/3.2.3/m/general/nargoutchk.m

 -- Function File: MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS)
 -- Function File: MSGSTR = nargoutchk (MINARGS, MAXARGS, NARGS,
          "string")
 -- Function File: MSGSTRUCT = nargoutchk (MINARGS, MAXARGS, NARGS,
          "struct")
     Return an appropriate error message string (or structure) if the
     number of outputs requested is invalid.

     This is useful for checking to see that the number of output
     arguments supplied to a function is within an acceptable range.

     See also: nargchk, error, nargout, nargin
}

#
native_float_format
{
`native_float_format' is a built-in function

 -- Built-in Function:  native_float_format ()
     Return the native floating point format as a string
}

#
nbincdf
{
`nbincdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/nbincdf.m

 -- Function File:  nbincdf (X, N, P)
     For each element of X, compute the CDF at x of the Pascal
     (negative binomial) distribution with parameters N and P.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
}

#
nbininv
{
`nbininv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/nbininv.m

 -- Function File:  nbininv (X, N, P)
     For each element of X, compute the quantile at X of the Pascal
     (negative binomial) distribution with parameters N and P.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
}

#
nbinpdf
{
`nbinpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/nbinpdf.m

 -- Function File:  nbinpdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the Pascal (negative binomial) distribution with
     parameters N and P.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
}

#
nbinrnd
{
`nbinrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/nbinrnd.m

 -- Function File:  nbinrnd (N, P, R, C)
 -- Function File:  nbinrnd (N, P, SZ)
     Return an R by C matrix of random samples from the Pascal
     (negative binomial) distribution with parameters N and P.  Both N
     and P must be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of N and P.  Or if SZ is a vector, create a matrix of
     size SZ.
}

#
nchoosek
{
`nchoosek' is a function from the file /usr/share/octave/3.2.3/m/specfun/nchoosek.m

 -- Function File: C = nchoosek (N, K)
     Compute the binomial coefficient or all combinations of N.  If N
     is a scalar then, calculate the binomial coefficient of N and K,
     defined as

           /   \
           | n |    n (n-1) (n-2) ... (n-k+1)       n!
           |   |  = ------------------------- =  ---------
           | k |               k!                k! (n-k)!
           \   /

     If N is a vector generate all combinations of the elements of N,
     taken K at a time, one row per combination.  The resulting C has
     size `[nchoosek (length (N), K), K]'.

     `nchoosek' works only for non-negative integer arguments; use
     `bincoeff' for non-integer scalar arguments and for using vector
     arguments to compute many coefficients at once.

     See also: bincoeff
}

#
ndgrid
{
`ndgrid' is a function from the file /usr/share/octave/3.2.3/m/plot/ndgrid.m

 -- Function File: [Y1, Y2, ...,  Yn] = ndgrid (X1, X2, ..., Xn)
 -- Function File: [Y1, Y2, ...,  Yn] = ndgrid (X)
     Given n vectors X1, ... Xn, `ndgrid' returns n arrays of dimension
     n. The elements of the i-th output argument contains the elements
     of the vector Xi repeated over all dimensions different from the
     i-th dimension.  Calling ndgrid with only one input argument X is
     equivalent of calling ndgrid with all n input arguments equal to X:

     [Y1, Y2, ...,  Yn] = ndgrid (X, ..., X)

     See also: meshgrid
}

#
ndims
{
`ndims' is a built-in function

 -- Built-in Function:  ndims (A)
     Returns the number of dimensions of array A.  For any array, the
     result will always be larger than or equal to 2.  Trailing
     singleton dimensions are not counted.
}

#
ne
{
`ne' is a built-in function

 -- Built-in Function:  ne (X, Y)
     This function is equivalent to `x != y'.
}

#
newplot
{
`newplot' is a function from the file /usr/share/octave/3.2.3/m/plot/newplot.m

 -- Function File:  newplot ()
     Prepare graphics engine to produce a new plot.  This function
     should be called at the beginning of all high-level plotting
     functions.
}

#
news
{
`news' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/news.m

 -- Function File:  news ()
     Display the current NEWS file for Octave.
}

#
nextpow2
{
`nextpow2' is a function from the file /usr/share/octave/3.2.3/m/general/nextpow2.m

 -- Function File:  nextpow2 (X)
     If X is a scalar, return the first integer N such that 2^n >= abs
     (x).

     If X is a vector, return `nextpow2 (length (X))'.

     See also: pow2, log2
}

#
nnz
{
`nnz' is a built-in function

 -- Built-in Function: SCALAR = nnz (A)
     Returns the number of non zero elements in A.

     See also: sparse
}

#
nonzeros
{
`nonzeros' is a function from the file /usr/share/octave/3.2.3/m/sparse/nonzeros.m

 -- Function File:  nonzeros (S)
     Returns a vector of the non-zero values of the sparse matrix S.
}

#
norm
{
`norm' is a built-in function

 -- Built-in Function:  norm (A, P, OPT)
     Compute the p-norm of the matrix A.  If the second argument is
     missing, `p = 2' is assumed.

     If A is a matrix (or sparse matrix):

    P = `1'
          1-norm, the largest column sum of the absolute values of A.

    P = `2'
          Largest singular value of A.

    P = `Inf' or `"inf"'
          Infinity norm, the largest row sum of the absolute values of
          A.

    P = `"fro"'
          Frobenius norm of A, `sqrt (sum (diag (A' * A)))'.

    other P, `P > 1'
          maximum `norm (A*x, p)' such that `norm (x, p) == 1'

     If A is a vector or a scalar:

    P = `Inf' or `"inf"'
          `max (abs (A))'.

    P = `-Inf'
          `min (abs (A))'.

    P = `"fro"'
          Frobenius norm of A, `sqrt (sumsq (abs (a)))'.

    P = 0
          Hamming norm - the number of nonzero elements.

    other P, `P > 1'
          p-norm of A, `(sum (abs (A) .^ P)) ^ (1/P)'.

    other P `P < 1'
          the p-pseudonorm defined as above.

     If `"rows"' is given as OPT, the norms of all rows of the matrix A
     are returned as a column vector.  Similarly, if `"columns"' or
     `"cols"' is passed column norms are computed.

     See also: cond, svd
}

#
normal_cdf
{
`normal_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/normal_cdf.m

 -- Function File:  normal_cdf (X, M, V)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the normal distribution with mean M and
     variance V.

     Default values are M = 0, V = 1.
}

#
normal_inv
{
`normal_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/normal_inv.m

 -- Function File:  normal_inv (X, M, V)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the normal distribution with mean M and variance V.

     Default values are M = 0, V = 1.
}

#
normal_pdf
{
`normal_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/normal_pdf.m

 -- Function File:  normal_pdf (X, M, V)
     For each element of X, compute the probability density function
     (PDF) at X of the normal distribution with mean M and variance V.

     Default values are M = 0, V = 1.
}

#
normal_rnd
{
`normal_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/normal_rnd.m

 -- Function File:  normal_rnd (M, V, R, C)
 -- Function File:  normal_rnd (M, V, SZ)
     Return an R by C  or `size (SZ)' matrix of random samples from the
     normal distribution with parameters M and V.  Both M and V must be
     scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of M and V.
}

#
normcdf
{
`normcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/normcdf.m

 -- Function File:  normcdf (X, M, S)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the normal distribution with mean M and
     standard deviation S.

     Default values are M = 0, S = 1.
}

#
normest
{
`normest' is a function from the file /usr/share/octave/3.2.3/m/sparse/normest.m

 -- Function File: [N, C] = normest (A, TOL)
     Estimate the 2-norm of the matrix A using a power series analysis.
     This is typically used for large matrices, where the cost of
     calculating the `norm (A)' is prohibitive and an approximation to
     the 2-norm is acceptable.

     TOL is the tolerance to which the 2-norm is calculated.  By default
     TOL is 1e-6.  C returns the number of iterations needed for
     `normest' to converge.
}

#
norminv
{
`norminv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/norminv.m

 -- Function File:  norminv (X, M, S)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the normal distribution with mean M and standard
     deviation S.

     Default values are M = 0, S = 1.
}

#
normpdf
{
`normpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/normpdf.m

 -- Function File:  normpdf (X, M, S)
     For each element of X, compute the probability density function
     (PDF) at X of the normal distribution with mean M and standard
     deviation S.

     Default values are M = 0, S = 1.
}

#
normrnd
{
`normrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/normrnd.m

 -- Function File:  normrnd (M, S, R, C)
 -- Function File:  normrnd (M, S, SZ)
     Return an R by C  or `size (SZ)' matrix of random samples from the
     normal distribution with parameters mean M and standard deviation
     S.  Both M and S must be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of M and S.
}

#
not
{
`not' is a built-in function

 -- Built-in Function:  not (X)
     This function is equivalent to `! x'.
}

#
now
{
`now' is a function from the file /usr/share/octave/3.2.3/m/time/now.m

 -- Function File: t = now ()
     Returns the current local time as the number of days since Jan 1,
     0000.  By this reckoning, Jan 1, 1970 is day number 719529.

     The integral part, `floor (now)' corresponds to 00:00:00 today.

     The fractional part, `rem (now, 1)' corresponds to the current
     time on Jan 1, 0000.

     The returned value is also called a "serial date number" (see
     `datenum').

     See also: clock, date, datenum
}

#
nth
{
`nth' is a built-in function

 -- Built-in Function:  nth (LIST, N)
     Return the N-th element of LIST.
}

#
nthroot
{
`nthroot' is a function from the file /usr/share/octave/3.2.3/m/general/nthroot.m

 -- Function File:  nthroot (X, N)
     Compute the n-th root of X, returning real results for real
     components of X.  For example

          nthroot (-1, 3)
          => -1
          (-1) ^ (1 / 3)
          => 0.50000 - 0.86603i
}

#
ntsc2rgb
{
`ntsc2rgb' is a function from the file /usr/share/octave/3.2.3/m/image/ntsc2rgb.m

 -- Function File:  ntsc2rgb (YIQ)
     Transform a colormap or image from NTSC to RGB.

     See also: rgb2ntsc
}

#
null
{
`null' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/null.m

 -- Function File:  null (A, TOL)
     Return an orthonormal basis of the null space of A.

     The dimension of the null space is taken as the number of singular
     values of A not greater than TOL.  If the argument TOL is missing,
     it is computed as

          max (size (A)) * max (svd (A)) * eps
}

#
num2cell
{
`num2cell' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/cellfun.oct

 -- Loadable Function: C = num2cell (M)
 -- Loadable Function: C = num2cell (M, DIM)
     Convert the matrix M to a cell array.  If DIM is defined, the
     value C is of dimension 1 in this dimension and the elements of M
     are placed in slices in C.

     See also: mat2cell
}

#
num2hex
{
`num2hex' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/hex2num.oct

 -- Loadable Function: S = num2hex (N)
     Typecast a double precision number or vector to a 16 character
     hexadecimal string of the IEEE 754 representation of the number.
     For example

          num2hex ([-1, 1, e, Inf, NaN, NA]);
          => "bff0000000000000
             3ff0000000000000
             4005bf0a8b145769
             7ff0000000000000
             fff8000000000000
             7ff00000000007a2"

     See also: hex2num, hex2dec, dec2hex
}

#
num2str
{
`num2str' is a function from the file /usr/share/octave/3.2.3/m/general/num2str.m

 -- Function File:  num2str (X)
 -- Function File:  num2str (X, PRECISION)
 -- Function File:  num2str (X, FORMAT)
     Convert a number (or array) to a string (or a character array).
     The optional second argument may either give the number of
     significant digits (PRECISION) to be used in the output or a format
     template string (FORMAT) as in `sprintf' (*note Formatted
     Output::).  `num2str' can also handle complex numbers.  For
     example:

          num2str (123.456)
               => "123.46"

          num2str (123.456, 4)
               => "123.5"

          s = num2str ([1, 1.34; 3, 3.56], "%5.1f")
               => s =
                  1.0  1.3
                  3.0  3.6
          whos s
               =>
                Attr Name        Size                     Bytes  Class
                ==== ====        ====                     =====  =====
                     s           2x8                         16  char

          num2str (1.234 + 27.3i)
               => "1.234+27.3i"

     The `num2str' function is not very flexible.  For better control
     over the results, use `sprintf' (*note Formatted Output::).  Note
     that for complex X, the format string may only contain one output
     conversion specification and nothing else.  Otherwise, you will
     get unpredictable results.

     See also: sprintf, int2str, mat2str
}

#
numel
{
`numel' is a built-in function

 -- Built-in Function:  numel (A)
     Returns the number of elements in the object A.

     See also: size
}

#
nzmax
{
`nzmax' is a built-in function

 -- Built-in Function: SCALAR = nzmax (SM)
     Return the amount of storage allocated to the sparse matrix SM.
     Note that Octave tends to crop unused memory at the first
     opportunity for sparse objects.  There are some cases of user
     created sparse objects where the value returned by "nzmax" will
     not be the same as "nnz", but in general they will give the same
     result.

     See also: sparse, spalloc
}

#
ocean
{
`ocean' is a function from the file /usr/share/octave/3.2.3/m/image/ocean.m

 -- Function File:  ocean (N)
     Create color colormap.  The argument N should be a scalar.  If it
     is omitted, the length of the current colormap or 64 is assumed.
}

#
octave_config_info
{
`octave_config_info' is a built-in function

 -- Built-in Function:  octave_config_info (OPTION)
     Return a structure containing configuration and installation
     information for Octave.

     if OPTION is a string, return the configuration information for the
     specified option.
}

#
octave_core_file_limit
{
`octave_core_file_limit' is a built-in function

 -- Built-in Function: VAL = octave_core_file_limit ()
 -- Built-in Function: OLD_VAL = octave_core_file_limit (NEW_VAL)
     Query or set the internal variable that specifies the maximum
     amount of memory (in kilobytes) of the top-level workspace that
     Octave will attempt to save when writing data to the crash dump
     file (the name of the file is specified by OCTAVE_CORE_FILE_NAME).
     If OCTAVE_CORE_FILE_OPTIONS flags specify a binary format, then
     OCTAVE_CORE_FILE_LIMIT will be approximately the maximum size of
     the file.  If a text file format is used, then the file could be
     much larger than the limit.  The default value is -1 (unlimited)

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options
}

#
octave_core_file_name
{
`octave_core_file_name' is a built-in function

 -- Built-in Function: VAL = octave_core_file_name ()
 -- Built-in Function: OLD_VAL = octave_core_file_name (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     file used for saving data from the top-level workspace if Octave
     aborts.  The default value is `"octave-core"'

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options
}

#
octave_core_file_options
{
`octave_core_file_options' is a built-in function

 -- Built-in Function: VAL = octave_core_file_options ()
 -- Built-in Function: OLD_VAL = octave_core_file_options (NEW_VAL)
     Query or set the internal variable that specifies the options used
     for saving the workspace data if Octave aborts.  The value of
     `octave_core_file_options' should follow the same format as the
     options for the `save' function.  The default value is Octave's
     binary format.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_limit
}

#
octave_tmp_file_name
{
`octave_tmp_file_name' is a built-in function

 -- Built-in Function:  tmpnam (DIR, PREFIX)
     Return a unique temporary file name as a string.

     If PREFIX is omitted, a value of `"oct-"' is used.  If DIR is also
     omitted, the default directory for temporary files is used.  If
     DIR is provided, it must exist, otherwise the default directory
     for temporary files is used.  Since the named file is not opened,
     by `tmpnam', it is possible (though relatively unlikely) that it
     will not be available by the time your program attempts to open it.

     See also: tmpfile, mkstemp, P_tmpdir
}

#
ols
{
`ols' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/ols.m

 -- Function File: [BETA, SIGMA, R] = ols (Y, X)
     Ordinary least squares estimation for the multivariate model y = x
     b + e with mean (e) = 0 and cov (vec (e)) = kron (s, I).   where y
     is a t by p matrix, x is a t by k matrix, b is a k by p matrix, and
     e is a t by p matrix.

     Each row of Y and X is an observation and each column a variable.

     The return values BETA, SIGMA, and R are defined as follows.

    BETA
          The OLS estimator for B, `BETA = pinv (X) * Y', where `pinv
          (X)' denotes the pseudoinverse of X.

    SIGMA
          The OLS estimator for the matrix S,

               SIGMA = (Y-X*BETA)'
                 * (Y-X*BETA)
                 / (T-rank(X))

    R
          The matrix of OLS residuals, `R = Y - X * BETA'.
}

#
onenormest
{
`onenormest' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/onenormest.m

 -- Function File: [EST, V, W, ITER] = onenormest (A, T)
 -- Function File: [EST, V, W, ITER] = onenormest (APPLY, APPLY_T, N, T)
     Apply Higham and Tisseur's randomized block 1-norm estimator to
     matrix A using T test vectors.  If T exceeds 5, then only 5 test
     vectors are used.

     If the matrix is not explicit, e.g., when estimating the norm of
     `inv (A)' given an LU factorization, `onenormest' applies A and
     its conjugate transpose through a pair of functions APPLY and
     APPLY_T, respectively, to a dense matrix of size N by T.  The
     implicit version requires an explicit dimension N.

     Returns the norm estimate EST, two vectors V and W related by norm
     `(W, 1) = EST * norm (V, 1)', and the number of iterations ITER.
     The number of iterations is limited to 10 and is at least 2.

     References:
        * Nicholas J. Higham and Fran
}

#
ones
{
`ones' is a built-in function

 -- Built-in Function:  ones (X)
 -- Built-in Function:  ones (N, M)
 -- Built-in Function:  ones (N, M, K, ...)
 -- Built-in Function:  ones (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 1.
     The arguments are handled the same as the arguments for `eye'.

     If you need to create a matrix whose values are all the same, you
     should use an expression like

          val_matrix = val * ones (n, m)

     The optional argument CLASS, allows `ones' to return an array of
     the specified type, for example

          val = ones (n,m, "uint8")
}

#
optimget
{
`optimget' is a function from the file /usr/share/octave/3.2.3/m/optimization/optimget.m

 -- Function File:  optimget (OPTIONS, PARNAME)
 -- Function File:  optimget (OPTIONS, PARNAME, DEFAULT)
     Return a specific option from a structure created by `optimset'.
     If PARNAME is not a field of the OPTIONS structure, return DEFAULT
     if supplied, otherwise return an empty matrix.
}

#
optimset
{
`optimset' is a function from the file /usr/share/octave/3.2.3/m/optimization/optimset.m

 -- Function File:  optimset ()
 -- Function File:  optimset (PAR, VAL, ...)
 -- Function File:  optimset (OLD, PAR, VAL, ...)
 -- Function File:  optimset (OLD, NEW)
     Create options struct for optimization functions.
}

#
or
{
`or' is a built-in function

 -- Built-in Function:  or (X, Y)
     This function is equivalent to `x | y'.
}

#
orderfields
{
`orderfields' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/orderfields.m

 -- Function File: [T, P] = orderfields (S1, S2)
     Return a struct with fields arranged alphabetically or as specified
     by S2 and a corresponding permutation vector.

     Given one struct, arrange field names in S1 alphabetically.

     Given two structs, arrange field names in S1 as they appear in S2.
     The second argument may also specify the order in a permutation
     vector or a cell array of strings.

     See also: getfield, rmfield, isfield, isstruct, fieldnames, struct
}

#
orient
{
`orient' is a function from the file /usr/share/octave/3.2.3/m/plot/orient.m

 -- Function File:  orient (ORIENTATION)
     Set the default print orientation.  Valid values for ORIENTATION
     include `"landscape"' and `"portrait"'.  If called with no
     arguments, return the default print orientation.
}

#
orth
{
`orth' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/orth.m

 -- Function File:  orth (A, TOL)
     Return an orthonormal basis of the range space of A.

     The dimension of the range space is taken as the number of singular
     values of A greater than TOL.  If the argument TOL is missing, it
     is computed as

          max (size (A)) * max (svd (A)) * eps
}

#
otherwise
{

 -- Keyword: otherwise
     The default statement in a switch block (similar to else in an if
     block).

     See also: switch
}

#
output_max_field_width
{
`output_max_field_width' is a built-in function

 -- Built-in Function: VAL = output_max_field_width ()
 -- Built-in Function: OLD_VAL = output_max_field_width (NEW_VAL)
     Query or set the internal variable that specifies the maximum width
     of a numeric output field.

     See also: format, output_precision
}

#
output_precision
{
`output_precision' is a built-in function

 -- Built-in Function: VAL = output_precision ()
 -- Built-in Function: OLD_VAL = output_precision (NEW_VAL)
     Query or set the internal variable that specifies the minimum
     number of significant figures to display for numeric output.

     See also: format, output_max_field_width
}

#
pack
{
`pack' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/pack.m

 -- Function File:  pack ()
     This function is provided for compatibility with MATLAB, but it
     doesn't actually do anything.
}

#
page_output_immediately
{
`page_output_immediately' is a built-in function

 -- Built-in Function: VAL = page_output_immediately ()
 -- Built-in Function: VAL = page_output_immediately (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     sends output to the pager as soon as it is available.  Otherwise,
     Octave buffers its output and waits until just before the prompt
     is printed to flush it to the pager.
}

#
page_screen_output
{
`page_screen_output' is a built-in function

 -- Built-in Function: VAL = page_screen_output ()
 -- Built-in Function: OLD_VAL = page_screen_output (NEW_VAL)
     Query or set the internal variable that controls whether output
     intended for the terminal window that is longer than one page is
     sent through a pager.  This allows you to view one screenful at a
     time.  Some pagers (such as `less'--see *note Installation::) are
     also capable of moving backward on the output.
}

#
paren
{
`paren' is the file /usr/share/octave/3.2.3/m/miscellaneous/paren.m

 -- Operator: (
 -- Operator: )
     Array index or function argument delimeter.
}

#
pareto
{
`pareto' is a function from the file /usr/share/octave/3.2.3/m/plot/pareto.m

 -- Function File:  pareto (X)
 -- Function File:  pareto (X, Y)
 -- Function File:  pareto (H, ...)
 -- Function File: H = pareto (...)
     Draw a Pareto chart, also called ABC chart.  A Pareto chart is a
     bar graph used to arrange information in such a way that
     priorities for process improvement can be established.  It
     organizes and displays information to show the relative importance
     of data.  The chart is similar to the histogram or bar chart,
     except that the bars are arranged in decreasing order from left to
     right along the abscissa.

     The fundamental idea (Pareto principle) behind the use of Pareto
     diagrams is that the majority of an effect is due to a small
     subset of the causes, so for quality improvement the first few (as
     presented on the diagram) contributing causes to a problem usually
     account for the majority of the result.  Thus, targeting these
     "major causes" for elimination results in the most cost-effective
     improvement scheme.

     The data are passed as X and the abscissa as Y.  If Y is absent,
     then the abscissa are assumed to be `1 : length (X)'.  Y can be a
     string array, a cell array of strings or a numerical vector.

     An example of the use of `pareto' is

          Cheese = {"Cheddar", "Swiss", "Camembert", ...
                    "Munster", "Stilton", "Blue"};
          Sold = [105, 30, 70, 10, 15, 20];
          pareto(Sold, Cheese);
}

#
parseparams
{
`parseparams' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/parseparams.m

 -- Function File: [REG, PROP] = parseparams (PARAMS)
     Return in REG the cell elements of PARAM up to the first string
     element and in PROP all remaining elements beginning with the
     first string element.  For example

          [reg, prop] = parseparams ({1, 2, "linewidth", 10})
          reg =
          {
            [1,1] = 1
            [1,2] = 2
          }
          prop =
          {
            [1,1] = linewidth
            [1,2] = 10
          }

     The parseparams function may be used to separate 'regular'
     arguments and additional arguments given as property/value pairs of
     the VARARGIN cell array.

     See also: varargin
}

#
pascal
{
`pascal' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/pascal.m

 -- Function File:  pascal (N, T)
     Return the Pascal matrix of order N if `T = 0'.  T defaults to 0.
     Return lower triangular Cholesky factor of the Pascal matrix if `T
     = 1'.  This matrix is its own inverse, that is `pascal (N, 1) ^ 2
     == eye (N)'.  If `T = -1', return its absolute value.  This is the
     standard pascal triangle as a lower-triangular matrix.  If `T =
     2', return a transposed and permuted version of `pascal (N, 1)',
     which is the cube-root of the identity matrix.  That is `pascal
     (N, 2) ^ 3 == eye (N)'.

     See also: hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
              hadamard, wilkinson, compan, rosser
}

#
pascal_cdf
{
`pascal_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/pascal_cdf.m

 -- Function File:  pascal_cdf (X, N, P)
     For each element of X, compute the CDF at x of the Pascal
     (negative binomial) distribution with parameters N and P.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
}

#
pascal_inv
{
`pascal_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/pascal_inv.m

 -- Function File:  pascal_inv (X, N, P)
     For each element of X, compute the quantile at X of the Pascal
     (negative binomial) distribution with parameters N and P.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
}

#
pascal_pdf
{
`pascal_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/pascal_pdf.m

 -- Function File:  pascal_pdf (X, N, P)
     For each element of X, compute the probability density function
     (PDF) at X of the Pascal (negative binomial) distribution with
     parameters N and P.

     The number of failures in a Bernoulli experiment with success
     probability P before the N-th success follows this distribution.
}

#
pascal_rnd
{
`pascal_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/pascal_rnd.m

 -- Function File:  pascal_rnd (N, P, R, C)
 -- Function File:  pascal_rnd (N, P, SZ)
     Return an R by C matrix of random samples from the Pascal
     (negative binomial) distribution with parameters N and P.  Both N
     and P must be scalar or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of N and P.  Or if SZ is a vector, create a matrix of
     size SZ.
}

#
patch
{
`patch' is a function from the file /usr/share/octave/3.2.3/m/plot/patch.m

 -- Function File:  patch ()
 -- Function File:  patch (X, Y, C)
 -- Function File:  patch (X, Y, Z, C)
 -- Function File:  patch (FV)
 -- Function File:  patch ('Faces', F, 'Vertices', V, ...)
 -- Function File:  patch (..., PROP, VAL)
 -- Function File:  patch (H, ...)
 -- Function File: H = patch (...)
     Create patch object from X and Y with color C and insert in the
     current axes object.  Return handle to patch object.

     For a uniform colored patch, C can be given as an RGB vector,
     scalar value referring to the current colormap, or string value
     (for example, "r" or "red").

     If passed a structure FV contain the fields "vertices", "faces"
     and optionally "facevertexcdata", create the patch based on these
     properties.
}

#
path
{
`path' is a built-in function

 -- Built-in Function:  path (...)
     Modify or display Octave's load path.

     If NARGIN and NARGOUT are zero, display the elements of Octave's
     load path in an easy to read format.

     If NARGIN is zero and nargout is greater than zero, return the
     current load path.

     If NARGIN is greater than zero, concatenate the arguments,
     separating them with `pathsep()'.  Set the internal search path to
     the result and return it.

     No checks are made for duplicate elements.

     See also: addpath, rmpath, genpath, pathdef, savepath, pathsep
}

#
pathdef
{
`pathdef' is a function from the file /usr/share/octave/3.2.3/m/path/pathdef.m

 -- Function File: VAL = pathdef ()
     Return the default path for Octave.  The path information is
     extracted from one of three sources.  In order of preference,
     those are;

       1. `~/.octaverc'

       2. `<octave-home>/.../<version>/m/startup/octaverc'

       3. Octave's path prior to changes by any octaverc.

     See also: path, addpath, rmpath, genpath, savepath, pathsep
}

#
pathsep
{
`pathsep' is a built-in function

 -- Built-in Function: VAL = pathsep ()
 -- Built-in Function: OLD_VAL = pathsep (NEW_VAL)
     Query or set the character used to separate directories in a path.

     See also: filesep, dir, ls
}

#
pause
{
`pause' is a built-in function

 -- Built-in Function:  pause (SECONDS)
     Suspend the execution of the program.  If invoked without any
     arguments, Octave waits until you type a character.  With a
     numeric argument, it pauses for the given number of seconds.  For
     example, the following statement prints a message and then waits 5
     seconds before clearing the screen.

          fprintf (stderr, "wait please...\n");
          pause (5);
          clc;
}

#
pcg
{
`pcg' is a function from the file /usr/share/octave/3.2.3/m/sparse/pcg.m

 -- Function File: X = pcg (A, B, TOL, MAXIT, M1, M2, X0, ...)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC, EIGEST] = pcg (...)
     Solves the linear system of equations `A * X = B' by means of the
     Preconditioned Conjugate Gradient iterative method.  The input
     arguments are

        * A can be either a square (preferably sparse) matrix or a
          function handle, inline function or string containing the name
          of a function which computes `A * X'.  In principle A should
          be symmetric and positive definite; if `pcg' finds A to not
          be positive definite, you will get a warning message and the
          FLAG output parameter will be set.

        * B is the right hand side vector.

        * TOL is the required relative tolerance for the residual error,
          `B - A * X'.  The iteration stops if `norm (B - A * X) <= TOL
          * norm (B - A * X0)'.  If TOL is empty or is omitted, the
          function sets `TOL = 1e-6' by default.

        * MAXIT is the maximum allowable number of iterations; if `[]'
          is supplied for `maxit', or `pcg' has less arguments, a
          default value equal to 20 is used.

        * M = M1 * M2 is the (left) preconditioning matrix, so that the
          iteration is (theoretically) equivalent to solving by `pcg'
          `P * X = M \ B', with `P = M \ A'.  Note that a proper choice
          of the preconditioner may dramatically improve the overall
          performance of the method.  Instead of matrices M1 and M2,
          the user may pass two functions which return the results of
          applying the inverse of M1 and M2 to a vector (usually this
          is the preferred way of using the preconditioner).  If `[]'
          is supplied for M1, or M1 is omitted, no preconditioning is
          applied.  If M2 is omitted, M = M1 will be used as
          preconditioner.

        * X0 is the initial guess.  If X0 is empty or omitted, the
          function sets X0 to a zero vector by default.

     The arguments which follow X0 are treated as parameters, and
     passed in a proper way to any of the functions (A or M) which are
     passed to `pcg'.  See the examples below for further details.  The
     output arguments are

        * X is the computed approximation to the solution of `A * X =
          B'.

        * FLAG reports on the convergence.  `FLAG = 0' means the
          solution converged and the tolerance criterion given by TOL
          is satisfied.  `FLAG = 1' means that the MAXIT limit for the
          iteration count was reached.  `FLAG = 3' reports that the
          (preconditioned) matrix was found not positive definite.

        * RELRES is the ratio of the final residual to its initial
          value, measured in the Euclidean norm.

        * ITER is the actual number of iterations performed.

        * RESVEC describes the convergence history of the method.
          `RESVEC (i,1)' is the Euclidean norm of the residual, and
          `RESVEC (i,2)' is the preconditioned residual norm, after the
          (I-1)-th iteration, `I = 1, 2, ..., ITER+1'.  The
          preconditioned residual norm is defined as `norm (R) ^ 2 = R'
          * (M \ R)' where `R = B - A * X', see also the description of
          M.  If EIGEST is not required, only `RESVEC (:,1)' is
          returned.

        * EIGEST returns the estimate for the smallest `EIGEST (1)' and
          largest `EIGEST (2)' eigenvalues of the preconditioned matrix
          `P = M \ A'.  In particular, if no preconditioning is used,
          the estimates for the extreme eigenvalues of A are returned.
          `EIGEST (1)' is an overestimate and `EIGEST (2)' is an
          underestimate, so that `EIGEST (2) / EIGEST (1)' is a lower
          bound for `cond (P, 2)', which nevertheless in the limit
          should theoretically be equal to the actual value of the
          condition number.  The method which computes EIGEST works
          only for symmetric positive definite A and M, and the user is
          responsible for verifying this assumption.

     Let us consider a trivial problem with a diagonal matrix (we
     exploit the sparsity of A)

          	n = 10;
          	a = diag (sparse (1:n));
          	b = rand (n, 1);
               [l, u, p, q] = luinc (a, 1.e-3);

     EXAMPLE 1: Simplest use of `pcg'

            x = pcg(A,b)

     EXAMPLE 2: `pcg' with a function which computes `A * X'

            function y = apply_a (x)
              y = [1:N]'.*x;
            endfunction

            x = pcg ("apply_a", b)

     EXAMPLE 3: `pcg' with a preconditioner: L * U

          x = pcg (a, b, 1.e-6, 500, l*u);

     EXAMPLE 4: `pcg' with a preconditioner: L * U.  Faster than
     EXAMPLE 3 since lower and upper triangular matrices are easier to
     invert

          x = pcg (a, b, 1.e-6, 500, l, u);

     EXAMPLE 5: Preconditioned iteration, with full diagnostics.  The
     preconditioner (quite strange, because even the original matrix A
     is trivial) is defined as a function

            function y = apply_m (x)
              k = floor (length (x) - 2);
              y = x;
              y(1:k) = x(1:k)./[1:k]';
            endfunction

            [x, flag, relres, iter, resvec, eigest] = ...
                               pcg (a, b, [], [], "apply_m");
            semilogy (1:iter+1, resvec);

     EXAMPLE 6: Finally, a preconditioner which depends on a parameter
     K.

            function y = apply_M (x, varargin)
            K = varargin{1};
            y = x;
            y(1:K) = x(1:K)./[1:K]';
            endfunction

            [x, flag, relres, iter, resvec, eigest] = ...
                 pcg (A, b, [], [], "apply_m", [], [], 3)

     REFERENCES

     	[1] C.T.Kelley, 'Iterative methods for linear and nonlinear
     equations', 	SIAM, 1995 (the base PCG algorithm)

     	[2] Y.Saad, 'Iterative methods for sparse linear systems', PWS
     1996 	(condition number estimate from PCG) Revised version of
     this book is 	available online at
     http://www-users.cs.umn.edu/~saad/books.html

     See also: sparse, pcr
}

#
pchip
{
`pchip' is a function from the file /usr/share/octave/3.2.3/m/polynomial/pchip.m

 -- Function File: PP = pchip (X, Y)
 -- Function File: YI = pchip (X, Y, XI)
     Piecewise Cubic Hermite interpolating polynomial.  Called with two
     arguments, the piece-wise polynomial PP is returned, that may
     later be used with `ppval' to evaluate the polynomial at specific
     points.

     The variable X must be a strictly monotonic vector (either
     increasing or decreasing).  While Y can be either a vector or
     array.  In the case where Y is a vector, it must have a length of
     N.  If Y is an array, then the size of Y must have the form `[S1,
     S2, ..., SK, N]' The array is then reshaped internally to a matrix
     where the leading dimension is given by `S1 * S2 * ... * SK' and
     each row in this matrix is then treated separately.  Note that this
     is exactly the opposite treatment than `interp1' and is done for
     compatibility.

     Called with a third input argument, `pchip' evaluates the
     piece-wise polynomial at the points XI.  There is an equivalence
     between `ppval (pchip (X, Y), XI)' and `pchip (X, Y, XI)'.

     See also: spline, ppval, mkpp, unmkpp
}

#
pclose
{
`pclose' is a built-in function

 -- Built-in Function:  pclose (FID)
     Close a file identifier that was opened by `popen'.  You may also
     use `fclose' for the same purpose.
}

#
pcolor
{
`pcolor' is a function from the file /usr/share/octave/3.2.3/m/plot/pcolor.m

 -- Function File:  pcolor (X, Y, C)
 -- Function File:  pcolor (C)
     Density plot for given matrices X, and Y from `meshgrid' and a
     matrix C corresponding to the X and Y coordinates of the mesh's
     vertices.  If X and Y are vectors, then a typical vertex is (X(j),
     Y(i), C(i,j)).  Thus, columns of C correspond to different X
     values and rows of C correspond to different Y values.

     The `colormap' is scaled to the extents of C.  Limits may be
     placed on the color axis by the command `caxis', or by setting the
     `clim' property of the parent axis.

     The face color of each cell of the mesh is determined by
     interpolating the values of C for the cell's vertices.  Contrast
     this with `imagesc' which renders one cell for each element of C.

     `shading' modifies an attribute determining the manner by which the
     face color of each cell is interpolated from the values of C, and
     the visibility of the cells' edges.  By default the attribute is
     "faceted", which renders a single color for each cell's face with
     the edge visible.

     H is the handle to the surface object.

     See also: caxis, contour, meshgrid, imagesc, shading
}

#
pcr
{
`pcr' is a function from the file /usr/share/octave/3.2.3/m/sparse/pcr.m

 -- Function File: X = pcr (A, B, TOL, MAXIT, M, X0, ...)
 -- Function File: [X, FLAG, RELRES, ITER, RESVEC] = pcr (...)
     Solves the linear system of equations `A * X = B' by means of the
     Preconditioned Conjugate Residuals iterative method.  The input
     arguments are

        * A can be either a square (preferably sparse) matrix or a
          function handle, inline function or string containing the name
          of a function which computes `A * X'.  In principle A should
          be symmetric and non-singular; if `pcr' finds A to be
          numerically singular, you will get a warning message and the
          FLAG output parameter will be set.

        * B is the right hand side vector.

        * TOL is the required relative tolerance for the residual error,
          `B - A * X'.  The iteration stops if `norm (B - A * X) <= TOL
          * norm (B - A * X0)'.  If TOL is empty or is omitted, the
          function sets `TOL = 1e-6' by default.

        * MAXIT is the maximum allowable number of iterations; if `[]'
          is supplied for `maxit', or `pcr' has less arguments, a
          default value equal to 20 is used.

        * M is the (left) preconditioning matrix, so that the iteration
          is (theoretically) equivalent to solving by `pcr' `P * X = M
          \ B', with `P = M \ A'.  Note that a proper choice of the
          preconditioner may dramatically improve the overall
          performance of the method.  Instead of matrix M, the user may
          pass a function which returns the results of applying the
          inverse of M to a vector (usually this is the preferred way
          of using the preconditioner).  If `[]' is supplied for M, or
          M is omitted, no preconditioning is applied.

        * X0 is the initial guess.  If X0 is empty or omitted, the
          function sets X0 to a zero vector by default.

     The arguments which follow X0 are treated as parameters, and
     passed in a proper way to any of the functions (A or M) which are
     passed to `pcr'.  See the examples below for further details.  The
     output arguments are

        * X is the computed approximation to the solution of `A * X =
          B'.

        * FLAG reports on the convergence.  `FLAG = 0' means the
          solution converged and the tolerance criterion given by TOL
          is satisfied.  `FLAG = 1' means that the MAXIT limit for the
          iteration count was reached.  `FLAG = 3' reports t `pcr'
          breakdown, see [1] for details.

        * RELRES is the ratio of the final residual to its initial
          value, measured in the Euclidean norm.

        * ITER is the actual number of iterations performed.

        * RESVEC describes the convergence history of the method, so
          that `RESVEC (i)' contains the Euclidean norms of the
          residual after the (I-1)-th iteration, `I = 1,2, ..., ITER+1'.

     Let us consider a trivial problem with a diagonal matrix (we
     exploit the sparsity of A)

          	n = 10;
          	a = sparse (diag (1:n));
          	b = rand (N, 1);

     EXAMPLE 1: Simplest use of `pcr'

            x = pcr(A, b)

     EXAMPLE 2: `pcr' with a function which computes `A * X'.

            function y = apply_a (x)
              y = [1:10]'.*x;
            endfunction

            x = pcr ("apply_a", b)

     EXAMPLE 3:  Preconditioned iteration, with full diagnostics.  The
     preconditioner (quite strange, because even the original matrix A
     is trivial) is defined as a function

            function y = apply_m (x)
              k = floor (length(x)-2);
              y = x;
              y(1:k) = x(1:k)./[1:k]';
            endfunction

            [x, flag, relres, iter, resvec] = ...
                               pcr (a, b, [], [], "apply_m")
            semilogy([1:iter+1], resvec);

     EXAMPLE 4: Finally, a preconditioner which depends on a parameter
     K.

            function y = apply_m (x, varargin)
              k = varargin{1};
              y = x; y(1:k) = x(1:k)./[1:k]';
            endfunction

            [x, flag, relres, iter, resvec] = ...
                               pcr (a, b, [], [], "apply_m"', [], 3)

     REFERENCES

     	[1] W. Hackbusch, "Iterative Solution of Large Sparse Systems of
     	Equations", section 9.5.4; Springer, 1994

     See also: sparse, pcg
}

#
peaks
{
`peaks' is a function from the file /usr/share/octave/3.2.3/m/plot/peaks.m

 -- Function File:  peaks ()
 -- Function File:  peaks (N)
 -- Function File:  peaks (X, Y)
 -- Function File: Z = peaks (...)
 -- Function File: [X, Y, Z] = peaks (...)
     Generate a function with lots of local maxima and minima.  The
     function has the form


     f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
              - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
              - 1/3*exp(-(x+1)^2 - y^2)

     Called without a return argument, `peaks' plots the surface of the
     above function using `mesh'.  If N is a scalar, the `peaks'
     returns the values of the above function on a N-by-N mesh over the
     range `[-3,3]'.  The default value for N is 49.

     If N is a vector, then it represents the X and Y values of the
     grid on which to calculate the above function.  The X and Y values
     can be specified separately.

     See also: surf, mesh, meshgrid
}

#
periodogram
{
`periodogram' is a function from the file /usr/share/octave/3.2.3/m/signal/periodogram.m

 -- Function File:  periodogram (X)
     For a data matrix X from a sample of size N, return the
     periodogram.
}

#
perl
{
`perl' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/perl.m

 -- Function File: [OUTPUT, STATUS] = perl (SCRIPTFILE)
 -- Function File: [OUTPUT, STATUS] = perl (SCRIPTFILE, ARGUMENT1,
          ARGUMENT2, ...)
     Invoke perl script SCRIPTFILE with possibly a list of command line
     arguments.  Returns output in OUTPUT and status in STATUS.

     See also: system
}

#
perms
{
`perms' is a function from the file /usr/share/octave/3.2.3/m/specfun/perms.m

 -- Function File:  perms (V)
     Generate all permutations of V, one row per permutation.  The
     result has size `factorial (N) * N', where N is the length of V.

     As an example, `perms([1, 2, 3])' returns the matrix
            1   2   3
            2   1   3
            1   3   2
            2   3   1
            3   1   2
            3   2   1
}

#
permute
{
`permute' is a built-in function

 -- Built-in Function:  permute (A, PERM)
     Return the generalized transpose for an N-d array object A.  The
     permutation vector PERM must contain the elements `1:ndims(a)' (in
     any order, but each element must appear just once).

     See also: ipermute
}

#
perror
{
`perror' is a function from the file /usr/share/octave/3.2.3/m/general/perror.m

 -- Function File:  perror (NAME, NUM)
     Print the error message for function NAME corresponding to the
     error number NUM.  This function is intended to be used to print
     useful error messages for those functions that return numeric error
     codes.

     See also: strerror
}

#
persistent
{

 -- Keyword: persistent VAR
     Declare variables as persistent.  A variable that has been declared
     persistent within a function will retain its contents in memory
     between subsequent calls to the same function.  The difference
     between persistent variables and global variables is that
     persistent variables are local in scope to a particular function
     and are not visible elsewhere.

     See also: global
}

#
pi
{
`pi' is a built-in function

 -- Built-in Function:  pi
 -- Built-in Function:  pi (N)
 -- Built-in Function:  pi (N, M)
 -- Built-in Function:  pi (N, M, K, ...)
 -- Built-in Function:  pi (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the ratio of the circumference of a circle to its
     diameter.  Internally, `pi' is computed as `4.0 * atan (1.0)'.

     When called with no arguments, return a scalar with the value of
     pi.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".
}

#
pie
{
`pie' is a function from the file /usr/share/octave/3.2.3/m/plot/pie.m

 -- Function File:  pie (Y)
 -- Function File:  pie (Y, EXPLODE)
 -- Function File:  pie (..., LABELS)
 -- Function File:  pie (H, ...);
 -- Function File: H = pie (...);
     Produce a pie chart.

     Called with a single vector argument, produces a pie chart of the
     elements in X, with the size of the slice determined by percentage
     size of the values of X.

     The variable EXPLODE is a vector of the same length as X that if
     non zero 'explodes' the slice from the pie chart.

     If given LABELS is a cell array of strings of the same length as
     X, giving the labels of each of the slices of the pie chart.

     The optional return value H provides a handle to the patch object.

     See also: bar, stem
}

#
pink
{
`pink' is a function from the file /usr/share/octave/3.2.3/m/image/pink.m

 -- Function File:  pink (N)
     Create color colormap.  This colormap gives a sepia tone on black
     and white images.  The argument N should be a scalar.  If it is
     omitted, the length of the current colormap or 64 is assumed.

     See also: colormap
}

#
pinv
{
`pinv' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/pinv.oct

 -- Loadable Function:  pinv (X, TOL)
     Return the pseudoinverse of X.  Singular values less than TOL are
     ignored.

     If the second argument is omitted, it is assumed that

          tol = max (size (X)) * sigma_max (X) * eps,

     where `sigma_max (X)' is the maximal singular value of X.
}

#
pipe
{
`pipe' is a built-in function

 -- Built-in Function: [READ_FD, WRITE_FD, ERR, MSG] = pipe ()
     Create a pipe and return the reading and writing ends of the pipe
     into READ_FD and WRITE_FD respectively.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.
}

#
pkg
{
`pkg' is a function from the file /usr/share/octave/3.2.3/m/pkg/pkg.m

 -- Command: pkg COMMAND PKG_NAME
 -- Command: pkg COMMAND OPTION PKG_NAME
     This command interacts with the package manager.  Different
     actions will be taken depending on the value of COMMAND.

    `install'
          Install named packages.  For example,
               pkg install image-1.0.0.tar.gz
          installs the package found in the file `image-1.0.0.tar.gz'.

          The OPTION variable can contain options that affect the manner
          in which a package is installed.  These options can be one or
          more of

         `-nodeps'
               The package manager will disable the dependency
               checking.  That way it is possible to install a package
               even if it depends on another package that's not
               installed on the system.  *Use this option with care.*

         `-noauto'
               The package manager will not automatically load the
               installed package when starting Octave, even if the
               package requests that it is.

         `-auto'
               The package manager will automatically load the
               installed package when starting Octave, even if the
               package requests that it isn't.

         `-local'
               A local installation is forced, even if the user has
               system privileges.

         `-global'
               A global installation is forced, even if the user
               doesn't normally have system privileges

         `-verbose'
               The package manager will print the output of all of the
               commands that are performed.

    `uninstall'
          Uninstall named packages.  For example,
               pkg uninstall image
          removes the `image' package from the system.  If another
          installed package depends on the `image' package an error
          will be issued.  The package can be uninstalled anyway by
          using the `-nodeps' option.

    `load'
          Add named packages to the path.  After loading a package it is
          possible to use the functions provided by the package.  For
          example,
               pkg load image
          adds the `image' package to the path.  It is possible to load
          all installed packages at once with the command
               pkg load all

    `unload'
          Removes named packages from the path.  After unloading a
          package it is no longer possible to use the functions
          provided by the package.  This command behaves like the
          `load' command.

    `list'
          Show a list of the currently installed packages.  By
          requesting one or two output argument it is possible to get a
          list of the currently installed packages.  For example,
               installed_packages = pkg list;
          returns a cell array containing a structure for each
          installed package.  The command
               [USER_PACKAGES, SYSTEM_PACKAGES] = pkg list
          splits the list of installed packages into those who are
          installed by the current user, and those installed by the
          system administrator.

    `describe'
          Show a short description of the named installed packages,
          with the option '-verbose' also list functions provided by
          the package, e.g.:
                pkg describe -verbose all
          will describe all installed packages and the functions they
          provide.  If one output is requested a cell of structure
          containing the description and list of functions of each
          package is returned as output rather than printed on screen:
                desc = pkg ("describe", "secs1d", "image")
          If any of the requested packages is not installed, pkg
          returns an error, unless a second output is requested:
                [ desc, flag] = pkg ("describe", "secs1d", "image")
          FLAG will take one of the values "Not installed", "Loaded" or
          "Not loaded" for each of the named packages.

    `prefix'
          Set the installation prefix directory.  For example,
               pkg prefix ~/my_octave_packages
          sets the installation prefix to `~/my_octave_packages'.
          Packages will be installed in this directory.

          It is possible to get the current installation prefix by
          requesting an output argument.  For example,
               p = pkg prefix

          The location in which to install the architecture dependent
          files can be independent specified with an addition argument.
          For example

               pkg prefix ~/my_octave_packages ~/my_arch_dep_pkgs

    `local_list'
          Set the file in which to look for information on the locally
          installed packages.  Locally installed packages are those
          that are typically available only to the current user.  For
          example
               pkg local_list ~/.octave_packages
          It is possible to get the current value of local_list with
          the following
               pkg local_list

    `global_list'
          Set the file in which to look for, for information on the
          globally installed packages.  Globally installed packages are
          those that are typically available to all users.  For example
               pkg global_list /usr/share/octave/octave_packages
          It is possible to get the current value of global_list with
          the following
               pkg global_list

    `rebuild'
          Rebuilds the package database from the installed directories.
          This can be used in cases where for some reason the package
          database is corrupted.  It can also take the `-auto' and
          `-noauto' options to allow the autoloading state of a package
          to be changed.  For example

               pkg rebuild -noauto image

          will remove the autoloading status of the image package.

    `build'
          Builds a binary form of a package or packages.  The binary
          file produced will itself be an Octave package that can be
          installed normally with `pkg'.  The form of the command to
          build a binary package is

               pkg build builddir image-1.0.0.tar.gz ...

          where `builddir' is the name of a directory where the
          temporary installation will be produced and the binary
          packages will be found.  The options `-verbose' and `-nodeps'
          are respected, while the other options are ignored.
}

#
planerot
{
`planerot' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/planerot.m

 -- Function File: [G, Y] = planerot (X)
     Given a two-element column vector, returns the 2 by 2 orthogonal
     matrix G such that `Y = G * X' and `Y(2) = 0'.

     See also: givens
}

#
playaudio
{
`playaudio' is a function from the file /usr/share/octave/3.2.3/m/audio/playaudio.m

 -- Function File:  playaudio (NAME, EXT)
 -- Function File:  playaudio (X)
     Plays the audio file `NAME.EXT' or the audio data stored in the
     vector X.

     See also: lin2mu, mu2lin, loadaudio, saveaudio, setaudio, record
}

#
plot
{
`plot' is a function from the file /usr/share/octave/3.2.3/m/plot/plot.m

 -- Function File:  plot (Y)
 -- Function File:  plot (X, Y)
 -- Function File:  plot (X, Y, PROPERTY, VALUE, ...)
 -- Function File:  plot (X, Y, FMT)
 -- Function File:  plot (H, ...)
     Produces two-dimensional plots.  Many different combinations of
     arguments are possible.  The simplest form is

          plot (Y)

     where the argument is taken as the set of Y coordinates and the X
     coordinates are taken to be the indices of the elements, starting
     with 1.

     To save a plot, in one of several image formats such as PostScript
     or PNG, use the `print' command.

     If more than one argument is given, they are interpreted as

          plot (Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, PROPERTY, VALUE, ...)

     or

          plot (X, Y, FMT, ...)

     and so on.  Any number of argument sets may appear.  The X and Y
     values are interpreted as follows:

        * If a single data argument is supplied, it is taken as the set
          of Y coordinates and the X coordinates are taken to be the
          indices of the elements, starting with 1.

        * If the X is a vector and Y is a matrix, then the columns (or
          rows) of Y are plotted versus X.  (using whichever
          combination matches, with columns tried first.)

        * If the X is a matrix and Y is a vector, Y is plotted versus
          the columns (or rows) of X.  (using whichever combination
          matches, with columns tried first.)

        * If both arguments are vectors, the elements of Y are plotted
          versus the elements of X.

        * If both arguments are matrices, the columns of Y are plotted
          versus the columns of X.  In this case, both matrices must
          have the same number of rows and columns and no attempt is
          made to transpose the arguments to make the number of rows
          match.

          If both arguments are scalars, a single point is plotted.

     Multiple property-value pairs may be specified, but they must
     appear in pairs.  These arguments are applied to the lines drawn by
     `plot'.

     If the FMT argument is supplied, it is interpreted as follows.  If
     FMT is missing, the default gnuplot line style is assumed.

    `-'
          Set lines plot style (default).

    `.'
          Set dots plot style.

    `N'
          Interpreted as the plot color if N is an integer in the range
          1 to 6.

    `NM'
          If NM is a two digit integer and M is an integer in the range
          1 to 6, M is interpreted as the point style.  This is only
          valid in combination with the `@' or `-@' specifiers.

    `C'
          If C is one of `"k"' (black), `"r"' (red), `"g"' (green),
          `"b"' (blue), `"m"' (magenta), `"c"' (cyan), or `"w"'
          (white), it is interpreted as the line plot color.

    `";title;"'
          Here `"title"' is the label for the key.

    `+'
    `*'
    `o'
    `x'
    `^'
          Used in combination with the points or linespoints styles,
          set the point style.

     The FMT argument may also be used to assign key titles.  To do so,
     include the desired title between semi-colons after the formatting
     sequence described above, e.g., "+3;Key Title;" Note that the last
     semi-colon is required and will generate an error if it is left
     out.

     Here are some plot examples:

          plot (x, y, "@12", x, y2, x, y3, "4", x, y4, "+")

     This command will plot `y' with points of type 2 (displayed as
     `+') and color 1 (red), `y2' with lines, `y3' with lines of color
     4 (magenta) and `y4' with points displayed as `+'.

          plot (b, "*", "markersize", 3)

     This command will plot the data in the variable `b', with points
     displayed as `*' with a marker size of 3.

          t = 0:0.1:6.3;
          plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");

     This will plot the cosine and sine functions and label them
     accordingly in the key.

     If the first argument is an axis handle, then plot into these axes,
     rather than the current axis handle returned by `gca'.

     See also: semilogx, semilogy, loglog, polar, mesh, contour, bar,
     stairs, errorbar, xlabel, ylabel, title, print
}

#
plot3
{
`plot3' is a function from the file /usr/share/octave/3.2.3/m/plot/plot3.m

 -- Function File:  plot3 (ARGS)
     Produce three-dimensional plots.  Many different combinations of
     arguments are possible.  The simplest form is

          plot3 (X, Y, Z)

     in which the arguments are taken to be the vertices of the points
     to be plotted in three dimensions.  If all arguments are vectors
     of the same length, then a single continuous line is drawn.  If
     all arguments are matrices, then each column of the matrices is
     treated as a separate line.  No attempt is made to transpose the
     arguments to make the number of rows match.

     If only two arguments are given, as

          plot3 (X, C)

     the real and imaginary parts of the second argument are used as
     the Y and Z coordinates, respectively.

     If only one argument is given, as

          plot3 (C)

     the real and imaginary parts of the argument are used as the Y and
     Z values, and they are plotted versus their index.

     Arguments may also be given in groups of three as

          plot3 (X1, Y1, Z1, X2, Y2, Z2, ...)

     in which each set of three arguments is treated as a separate line
     or set of lines in three dimensions.

     To plot multiple one- or two-argument groups, separate each group
     with an empty format string, as

          plot3 (X1, C1, "", C2, "", ...)

     An example of the use of `plot3' is

             z = [0:0.05:5];
             plot3 (cos(2*pi*z), sin(2*pi*z), z, ";helix;");
             plot3 (z, exp(2i*pi*z), ";complex sinusoid;");

     See also: plot, xlabel, ylabel, zlabel, title, print
}

#
plotmatrix
{
`plotmatrix' is a function from the file /usr/share/octave/3.2.3/m/plot/plotmatrix.m

 -- Function File:  plotmatrix (X, Y)
 -- Function File:  plotmatrix (X)
 -- Function File:  plotmatrix (..., STYLE)
 -- Function File:  plotmatrix (H, ...)
 -- Function File: [H, AX, BIGAX, P, PAX] = plotmatrix (...)
     Scatter plot of the columns of one matrix against another.  Given
     the arguments X and Y, that have a matching number of rows,
     `plotmatrix' plots a set of axes corresponding to

          plot (X (:, i), Y (:, j)

     Given a single argument X, then this is equivalent to

          plotmatrix (X, X)

     except that the diagonal of the set of axes will be replaced with
     the histogram `hist (X (:, i))'.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the `plot' command.
     If a leading axes handle H is passed to `plotmatrix', then this
     axis will be used for the plot.

     The optional return value H provides handles to the individual
     graphics objects in the scatter plots, whereas AX returns the
     handles to the scatter plot axis objects.  BIGAX is a hidden axis
     object that surrounds the other axes, such that the commands
     `xlabel', `title', etc., will be associated with this hidden axis.
     Finally P returns the graphics objects associated with the
     histogram and PAX the corresponding axes objects.

          plotmatrix (randn (100, 3), 'g+')
}

#
plotyy
{
`plotyy' is a function from the file /usr/share/octave/3.2.3/m/plot/plotyy.m

 -- Function File:  plotyy (X1, Y1, X2, Y2)
 -- Function File:  plotyy (..., FUN)
 -- Function File:  plotyy (..., FUN1, FUN2)
 -- Function File:  plotyy (H, ...)
 -- Function File: [AX, H1, H2] = plotyy (...)
     Plots two sets of data with independent y-axes.  The arguments X1
     and Y1 define the arguments for the first plot and X1 and Y2 for
     the second.

     By default the arguments are evaluated with `feval (@plot, X, Y)'.
     However the type of plot can be modified with the FUN argument, in
     which case the plots are generated by `feval (FUN, X, Y)'.  FUN
     can be a function handle, an inline function or a string of a
     function name.

     The function to use for each of the plots can be independently
     defined with FUN1 and FUN2.

     If given, H defines the principal axis in which to plot the X1 and
     Y1 data.  The return value AX is a two element vector with the
     axis handles of the two plots.  H1 and H2 are handles to the
     objects generated by the plot commands.

          x = 0:0.1:2*pi;
          y1 = sin (x);
          y2 = exp (x - 1);
          ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
          xlabel ("X");
          ylabel (ax(1), "Axis 1");
          ylabel (ax(2), "Axis 2");
}

#
plus
{
`plus' is a built-in function

 -- Built-in Function:  plus (X, Y)
     This function is equivalent to `x + y'.
}

#
poisscdf
{
`poisscdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/poisscdf.m

 -- Function File:  poisscdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Poisson distribution with parameter
     lambda.
}

#
poissinv
{
`poissinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/poissinv.m

 -- Function File:  poissinv (X, LAMBDA)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the Poisson distribution with parameter LAMBDA.
}

#
poisson_cdf
{
`poisson_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/poisson_cdf.m

 -- Function File:  poisson_cdf (X, LAMBDA)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Poisson distribution with parameter
     lambda.
}

#
poisson_inv
{
`poisson_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/poisson_inv.m

 -- Function File:  poisson_inv (X, LAMBDA)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the Poisson distribution with parameter LAMBDA.
}

#
poisson_pdf
{
`poisson_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/poisson_pdf.m

 -- Function File:  poisson_pdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) at X of the poisson distribution with parameter LAMBDA.
}

#
poisson_rnd
{
`poisson_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/poisson_rnd.m

 -- Function File:  poisson_rnd (LAMBDA, R, C)
     Return an R by C matrix of random samples from the Poisson
     distribution with parameter LAMBDA, which must be a scalar or of
     size R by C.

     If R and C are omitted, the size of the result matrix is the size
     of LAMBDA.
}

#
poisspdf
{
`poisspdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/poisspdf.m

 -- Function File:  poisspdf (X, LAMBDA)
     For each element of X, compute the probability density function
     (PDF) at X of the poisson distribution with parameter LAMBDA.
}

#
poissrnd
{
`poissrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/poissrnd.m

 -- Function File:  poissrnd (LAMBDA, R, C)
     Return an R by C matrix of random samples from the Poisson
     distribution with parameter LAMBDA, which must be a scalar or of
     size R by C.

     If R and C are omitted, the size of the result matrix is the size
     of LAMBDA.
}

#
pol2cart
{
`pol2cart' is a function from the file /usr/share/octave/3.2.3/m/general/pol2cart.m

 -- Function File: [X, Y] = pol2cart (THETA, R)
 -- Function File: [X, Y, Z] = pol2cart (THETA, R, Z)
     Transform polar or cylindrical to Cartesian coordinates.  THETA, R
     (and Z) must be the same shape, or scalar.  THETA describes the
     angle relative to the positive x-axis.  R is the distance to the
     z-axis (0, 0, z).

     See also: cart2pol, cart2sph, sph2cart
}

#
polar
{
`polar' is a function from the file /usr/share/octave/3.2.3/m/plot/polar.m

 -- Function File:  polar (THETA, RHO, FMT)
     Make a two-dimensional plot given the polar coordinates THETA and
     RHO.

     The optional third argument specifies the line type.

     See also: plot
}

#
poly
{
`poly' is a function from the file /usr/share/octave/3.2.3/m/polynomial/poly.m

 -- Function File:  poly (A)
     If A is a square N-by-N matrix, `poly (A)' is the row vector of
     the coefficients of `det (z * eye (N) - a)', the characteristic
     polynomial of A.  As an example we can use this to find the
     eigenvalues of A as the roots of `poly (A)'.
          roots(poly(eye(3)))
          => 1.00000 + 0.00000i
          => 1.00000 - 0.00000i
          => 1.00000 + 0.00000i
     In real-life examples you should, however, use the `eig' function
     for computing eigenvalues.

     If X is a vector, `poly (X)' is a vector of coefficients of the
     polynomial whose roots are the elements of X.  That is, of C is a
     polynomial, then the elements of `D = roots (poly (C))' are
     contained in C.  The vectors C and D are, however, not equal due
     to sorting and numerical errors.

     See also: eig, roots
}

#
polyaffine
{
`polyaffine' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyaffine.m

 -- Function File:  polyaffine (F, MU)
     Return the coefficients of the polynomial whose coefficients are
     given by vector F after an affine tranformation. If F is the vector
     representing the polynomial f(x), then G = polytrans (F, MU) is
     the vector representing
          g(x) = f((x-MU(1))/MU(2)).

     See also: polyval
}

#
polyarea
{
`polyarea' is a function from the file /usr/share/octave/3.2.3/m/general/polyarea.m

 -- Function File:  polyarea (X, Y)
 -- Function File:  polyarea (X, Y, DIM)
     Determines area of a polygon by triangle method.  The variables X
     and Y define the vertex pairs, and must therefore have the same
     shape.  They can be either vectors or arrays.  If they are arrays
     then the columns of X and Y are treated separately and an area
     returned for each.

     If the optional DIM argument is given, then `polyarea' works along
     this dimension of the arrays X and Y.
}

#
polyder
{
`polyder' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyder.m

 -- Function File:  polyder (C)
 -- Function File: [Q] = polyder (B, A)
 -- Function File: [Q, R] = polyder (B, A)
     See polyderiv.
}

#
polyderiv
{
`polyderiv' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyderiv.m

 -- Function File:  polyderiv (C)
 -- Function File: [Q] = polyderiv (B, A)
 -- Function File: [Q, R] = polyderiv (B, A)
     Return the coefficients of the derivative of the polynomial whose
     coefficients are given by vector C.  If a pair of polynomials is
     given B and A, the derivative of the product is returned in Q, or
     the quotient numerator in Q and the quotient denominator in R.

     See also: poly, polyinteg, polyreduce, roots, conv, deconv,
     residue, filter, polygcd, polyval, polyvalm
}

#
polyfit
{
`polyfit' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyfit.m

 -- Function File: [P, S, MU] = polyfit (X, Y, N)
     Return the coefficients of a polynomial P(X) of degree N that
     minimizes the least-squares-error of the fit.

     The polynomial coefficients are returned in a row vector.

     The second output is a structure containing the following fields:

    `R'
          Triangular factor R from the QR decomposition.

    `X'
          The Vandermonde matrix used to compute the polynomial
          coefficients.

    `df'
          The degrees of freedom.

    `normr'
          The norm of the residuals.

    `yf'
          The values of the polynomial for each value of X.

     The second output may be used by `polyval' to calculate the
     statistical error limits of the predicted values.

     When the third output, MU, is present the coefficients, P, are
     associated with a polynomial in XHAT = (X-MU(1))/MU(2).  Where
     MU(1) = mean (X), and MU(2) = std (X).  This linear transformation
     of X improves the numerical stability of the fit.

     See also: polyval, residue
}

#
polygcd
{
`polygcd' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polygcd.m

 -- Function File: Q = polygcd (B, A, TOL)
     Find greatest common divisor of two polynomials.  This is
     equivalent to the polynomial found by multiplying together all the
     common roots.  Together with deconv, you can reduce a ratio of two
     polynomials.  Tolerance defaults to
          sqrt(eps).
      Note that this is an unstable algorithm, so don't try it on large
     polynomials.

     Example
          polygcd (poly(1:8), poly(3:12)) - poly(3:8)
          => [ 0, 0, 0, 0, 0, 0, 0 ]
          deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))) ...
            - poly(1:2)
          => [ 0, 0, 0 ]

     See also: poly, polyinteg, polyderiv, polyreduce, roots, conv,
     deconv, residue, filter, polyval, polyvalm
}

#
polyint
{
`polyint' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyint.m

 -- Function File:  polyint (C, K)
     Return the coefficients of the integral of the polynomial whose
     coefficients are represented by the vector C.  The variable K is
     the constant of integration, which by default is set to zero.

     See also: poly, polyderiv, polyreduce, roots, conv, deconv,
     residue, filter, polyval, polyvalm
}

#
polyinteg
{
`polyinteg' is a function from the file /usr/share/octave/3.2.3/m/deprecated/polyinteg.m

 -- Function File:  polyinteg (C)
     Return the coefficients of the integral of the polynomial whose
     coefficients are represented by the vector C.

     The constant of integration is set to zero.

     See also: polyint, poly, polyderiv, polyreduce, roots, conv,
     deconv, residue, filter, polyval, polyvalm
}

#
polyout
{
`polyout' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyout.m

 -- Function File:  polyout (C, X)
     Write formatted polynomial
             c(x) = c(1) * x^n + ... + c(n) x + c(n+1)
      and return it as a string or write it to the screen (if  NARGOUT
     is zero).   X defaults to the string `"s"'.

     See also: polyval, polyvalm, poly, roots, conv, deconv, residue,
     filter, polyderiv, polyinteg
}

#
polyreduce
{
`polyreduce' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyreduce.m

 -- Function File:  polyreduce (C)
     Reduces a polynomial coefficient vector to a minimum number of
     terms by stripping off any leading zeros.

     See also: poly, roots, conv, deconv, residue, filter, polyval,
     polyvalm, polyderiv, polyinteg
}

#
polyval
{
`polyval' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyval.m

 -- Function File: Y = polyval (P, X)
 -- Function File: Y = polyval (P, X, [], MU)
     Evaluate the polynomial at of the specified values for X.  When MU
     is present evaluate the polynomial for (X-MU(1))/MU(2).  If X is a
     vector or matrix, the polynomial is evaluated for each of the
     elements of X.

 -- Function File: [Y, DY] = polyval (P, X, S)
 -- Function File: [Y, DY] = polyval (P, X, S, MU)
     In addition to evaluating the polynomial, the second output
     represents the prediction interval, Y +/- DY, which contains at
     least 50% of the future predictions.  To calculate the prediction
     interval, the structured variable S, originating form `polyfit',
     must be present.

     See also: polyfit, polyvalm, poly, roots, conv, deconv, residue,
     filter, polyderiv, polyinteg
}

#
polyvalm
{
`polyvalm' is a function from the file /usr/share/octave/3.2.3/m/polynomial/polyvalm.m

 -- Function File:  polyvalm (C, X)
     Evaluate a polynomial in the matrix sense.

     `polyvalm (C, X)' will evaluate the polynomial in the matrix
     sense, i.e., matrix multiplication is used instead of element by
     element multiplication as is used in polyval.

     The argument X must be a square matrix.

     See also: polyval, poly, roots, conv, deconv, residue, filter,
     polyderiv, polyinteg
}

#
popen
{
`popen' is a built-in function

 -- Built-in Function: FID = popen (COMMAND, MODE)
     Start a process and create a pipe.  The name of the command to run
     is given by COMMAND.  The file identifier corresponding to the
     input or output stream of the process is returned in FID.  The
     argument MODE may be

    `"r"'
          The pipe will be connected to the standard output of the
          process, and open for reading.

    `"w"'
          The pipe will be connected to the standard input of the
          process, and open for writing.

     For example,

          fid = popen ("ls -ltr / | tail -3", "r");
          while (ischar (s = fgets (fid)))
           fputs (stdout, s);
          endwhile
              -| drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
              -| drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
              -| drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp
}

#
popen2
{
`popen2' is a built-in function

 -- Built-in Function: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     Start a subprocess with two-way communication.  The name of the
     process is given by COMMAND, and ARGS is an array of strings
     containing options for the command.  The file identifiers for the
     input and output streams of the subprocess are returned in IN and
     OUT.  If execution of the command is successful, PID contains the
     process ID of the subprocess.  Otherwise, PID is -1.

     For example,

          [in, out, pid] = popen2 ("sort", "-r");
          fputs (in, "these\nare\nsome\nstrings\n");
          fclose (in);
          EAGAIN = errno ("EAGAIN");
          done = false;
          do
           s = fgets (out);
           if (ischar (s))
             fputs (stdout, s);
           elseif (errno () == EAGAIN)
             sleep (0.1);
             fclear (out);
           else
             done = true;
           endif
          until (done)
          fclose (out);
          waitpid (pid);
              -| these
              -| strings
              -| some
              -| are

     Note that `popen2', unlike `popen', will not "reap" the child
     process.  If you don't use `waitpid' to check the child's exit
     status, it will linger until Octave exits.
}

#
postpad
{
`postpad' is a function from the file /usr/share/octave/3.2.3/m/general/postpad.m

 -- Function File:  postpad (X, L, C)
 -- Function File:  postpad (X, L, C, DIM)
     See also: prepad, resize
}

#
pow2
{
`pow2' is a function from the file /usr/share/octave/3.2.3/m/specfun/pow2.m

 -- Mapping Function:  pow2 (X)
 -- Mapping Function:  pow2 (F, E)
     With one argument, computes 2 .^ x for each element of X.

     With two arguments, returns f .* (2 .^ e).

     See also: log2, nextpow2
}

#
power
{
`power' is a built-in function

 -- Built-in Function:  power (X, Y)
     This function is equivalent to `x .^ y'.
}

#
ppplot
{
`ppplot' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/ppplot.m

 -- Function File: [P, Y] = ppplot (X, DIST, PARAMS)
     Perform a PP-plot (probability plot).

     If F is the CDF of the distribution DIST with parameters PARAMS
     and X a sample vector of length N, the PP-plot graphs ordinate
     Y(I) = F (I-th largest element of X) versus abscissa P(I) = (I -
     0.5)/N.  If the sample comes from F, the pairs will approximately
     follow a straight line.

     The default for DIST is the standard normal distribution.  The
     optional argument PARAMS contains a list of parameters of DIST.
     For example, for a probability plot of the uniform distribution on
     [2,4] and X, use

          ppplot (x, "uniform", 2, 4)

     DIST can be any string for which a function DIST_CDF that
     calculates the CDF of distribution DIST exists.

     If no output arguments are given, the data are plotted directly.
}

#
ppval
{
`ppval' is a function from the file /usr/share/octave/3.2.3/m/polynomial/ppval.m

 -- Function File: YI = ppval (PP, XI)
     Evaluate piece-wise polynomial PP at the points XI.  If `PP.d' is
     a scalar greater than 1, or an array, then the returned value YI
     will be an array that is `d1, d1, ..., dk, length (XI)]'.

     See also: mkpp, unmkpp, spline
}

#
prctile
{
`prctile' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/prctile.m

 -- Function File: Y = prctile (X, P)
 -- Function File: Q = prctile (X, P, DIM)
     For a sample X, compute the quantiles, Y, corresponding to the
     cumulative probability values, P, in percent.  All non-numeric
     values (NaNs) of X are ignored.

     If X is a matrix, compute the percentiles for each column and
     return them in a matrix, such that the i-th row of Y contains the
     P(i)th percentiles of each column of X.

     The optional argument DIM determines the dimension along which the
     percentiles are calculated.  If DIM is omitted, and X is a vector
     or matrix, it defaults to 1 (column wise quantiles).  In the
     instance that X is a N-d array, DIM defaults to the first
     dimension whose size greater than unity.
}

#
prepad
{
`prepad' is a function from the file /usr/share/octave/3.2.3/m/general/prepad.m

 -- Function File:  prepad (X, L, C)
 -- Function File:  prepad (X, L, C, DIM)
     Prepend (append) the scalar value C to the vector X until it is of
     length L.  If the third argument is not supplied, a value of 0 is
     used.

     If `length (X) > L', elements from the beginning (end) of X are
     removed until a vector of length L is obtained.

     If X is a matrix, elements are prepended or removed from each row.

     If the optional DIM argument is given, then operate along this
     dimension.

     See also: postpad
}

#
primes
{
`primes' is a function from the file /usr/share/octave/3.2.3/m/specfun/primes.m

 -- Function File:  primes (N)
     Return all primes up to N.

     The algorithm used is the Sieve of Erastothenes.

     Note that if you need a specific number of primes you can use the
     fact the distance from one prime to the next is, on average,
     proportional to the logarithm of the prime.  Integrating, one finds
     that there are about k primes less than k*log(5*k).

     See also: list_primes, isprime
}

#
print
{
`print' is a function from the file /usr/share/octave/3.2.3/m/plot/print.m

 -- Function File:  print ()
 -- Function File:  print (OPTIONS)
 -- Function File:  print (FILENAME, OPTIONS)
 -- Function File:  print (H, FILENAME, OPTIONS)
     Print a graph, or save it to a file

     FILENAME defines the file name of the output file.  If no filename
     is specified, the output is sent to the printer.

     H specifies the figure handle.  If no handle is specified the
     handle for the current figure is used.

     OPTIONS:
    `-PPRINTER'
          Set the PRINTER name to which the graph is sent if no
          FILENAME is specified.

    `-GGHOSTSCRIPT_COMMAND'
          Specify the command for calling Ghostscript.  For Unix and
          Windows, the defaults are 'gs' and 'gswin32c', respectively.

    `-color'
    `-mono'
          Monochrome or color lines.

    `-solid'
    `-dashed'
          Solid or dashed lines.

    `-portrait'
    `-landscape'
          Specify the orientation of the plot for printed output.

    `-dDEVICE'
          Output device, where DEVICE is one of:
         `ps'
         `ps2'
         `psc'
         `psc2'
               Postscript (level 1 and 2, mono and color)

         `eps'
         `eps2'
         `epsc'
         `epsc2'
               Encapsulated postscript (level 1 and 2, mono and color)

         `tex'
         `epslatex'
         `epslatexstandalone'
         `pstex'
         `pslatex'
               Generate a LaTeX (or TeX) file for labels, and eps/ps for
               graphics.  The file produced by `epslatexstandalone' can
               be processed directly by LaTeX.  The other formats are
               intended to be included in a LaTeX (or TeX) document.
               The `tex' device is the same as the `epslatex' device.

         `ill'
         `aifm'
               Adobe Illustrator

         `cdr'
         `corel'
               CorelDraw

         `dxf'
               AutoCAD

         `emf'
         `meta'
               Microsoft Enhanced Metafile

         `fig'
               XFig.  If this format is selected the additional options
                  `-textspecial' or `-textnormal' can be used to control
                  whether the special flag should be set for the text in
                  the figure (default is `-textnormal').

         `hpgl'
               HP plotter language

         `mf'
               Metafont

         `png'
               Portable network graphics

         `jpg'
         `jpeg'
               JPEG image

         `gif'
               GIF image

         `pbm'
               PBMplus

         `svg'
               Scalable vector graphics

         `pdf'
               Portable document format

               NOTE: The gnuplot binary as shipped by Debian cannot
               create PDF files, see http://bugs.debian.org/478677


          If the device is omitted, it is inferred from the file
          extension, or if there is no filename it is sent to the
          printer as postscript.

    `-dGS_DEVICE'
          Additional devices are supported by Ghostscript.  Some
          examples are;

         `ljet2p'
               HP LaserJet IIP

         `ljet3'
               HP LaserJet III

         `deskjet'
               HP DeskJet and DeskJet Plus

         `cdj550'
               HP DeskJet 550C

         `paintjet'
               HP PointJet

         `pcx24b'
               24-bit color PCX file format

         `ppm'
               Portable Pixel Map file format

          For a complete list, type `system ("gs -h")' to see what
          formats and devices are available.

          When the ghostscript is sent to a printer the size is
          determined by the figure's "papersize" property.  When the
          ghostscript output is sent to a file the size is determined
          by the figure's "paperposition" property.

    `-rNUM'
          Resolution of bitmaps in pixels per inch.  For both metafiles
          and SVG the default is the screen resolution, for other it is
          150 dpi.  To specify screen resolution, use "-r0".

    `-tight'
          Forces a tight bounding box for eps-files.  Since the
          ghostscript devices are conversion of an eps-file, this
          option works the those devices as well.

    `-SXSIZE,YSIZE'
          Plot size in pixels for EMF, GIF, JPEG, PBM, PNG and SVG.  If
          using the command form of the print function, you must quote
          the XSIZE,YSIZE option.  For example, by writing
          `"-S640,480"'.  The size defaults to that specified by the
          figure's paperposition property.

    `-FFONTNAME'
    `-FFONTNAME:SIZE'
    `-F:SIZE'
          FONTNAME set the postscript font (for use with postscript,
          aifm, corel and fig).  By default, 'Helvetica' is set for
          PS/Aifm, and 'SwitzerlandLight' for Corel.  It can also be
          'Times-Roman'.  SIZE is given in points.  FONTNAME is ignored
          for the fig device.

     The filename and options can be given in any order.
}

#
print_empty_dimensions
{
`print_empty_dimensions' is a built-in function

 -- Built-in Function: VAL = print_empty_dimensions ()
 -- Built-in Function: OLD_VAL = print_empty_dimensions (NEW_VAL)
     Query or set the internal variable that controls whether the
     dimensions of empty matrices are printed along with the empty
     matrix symbol, `[]'.  For example, the expression

          zeros (3, 0)

     will print

          ans = [](3x0)
}

#
print_usage
{
`print_usage' is a function from the file /usr/share/octave/3.2.3/m/help/print_usage.m

 -- Function File:  print_usage ()
 -- Function File:  print_usage (NAME)
     Print the usage message for a function.  When called with no input
     arguments the `print_usage' function displays the usage message of
     the currently executing function.

     See also: help
}

#
printf
{
`printf' is a built-in function

 -- Built-in Function:  printf (TEMPLATE, ...)
     Print optional arguments under the control of the template string
     TEMPLATE to the stream `stdout' and return the number of
     characters printed.

     See the Formatted Output section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: fprintf, sprintf, scanf
}

#
prism
{
`prism' is a function from the file /usr/share/octave/3.2.3/m/image/prism.m

 -- Function File:  prism (N)
     Create color colormap.  This colormap cycles trough red, orange,
     yellow, green, blue and violet.  The argument N should be a
     scalar.  If it is omitted, the length of the current colormap or
     64 is assumed.

     See also: colormap
}

#
probit
{
`probit' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/probit.m

 -- Function File:  probit (P)
     For each component of P, return the probit (the quantile of the
     standard normal distribution) of P.
}

#
prod
{
`prod' is a built-in function

 -- Built-in Function:  prod (X)
 -- Built-in Function:  prod (X, DIM)
     Product of elements along dimension DIM.  If DIM is omitted, it
     defaults to 1 (column-wise products).

     As a special case, if X is a vector and DIM is omitted, return the
     product of the elements.

     See also: cumprod, sum
}

#
program_invocation_name
{
`program_invocation_name' is a built-in function

 -- Built-in Function: program_invocation_name ()
     Return the name that was typed at the shell prompt to run Octave.

     If executing a script from the command line (e.g., `octave foo.m')
     or using an executable Octave script, the program name is set to
     the name of the script.  *Note Executable Octave Programs::, for
     an example of how to create an executable Octave script.

     See also: program_name
}

#
program_name
{
`program_name' is a built-in function

 -- Built-in Function:  program_name ()
     Return the last component of the value returned by
     `program_invocation_name'.

     See also: program_invocation_name
}

#
prop_test_2
{
`prop_test_2' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/prop_test_2.m

 -- Function File: [PVAL, Z] = prop_test_2 (X1, N1, X2, N2, ALT)
     If X1 and N1 are the counts of successes and trials in one sample,
     and X2 and N2 those in a second one, test the null hypothesis that
     the success probabilities P1 and P2 are the same.  Under the null,
     the test statistic Z approximately follows a standard normal
     distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative P1 != P2.  If ALT is `">"', the
     one-sided alternative P1 > P2 is used.  Similarly for `"<"', the
     one-sided alternative P1 < P2 is used.  The default is the
     two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
putenv
{
`putenv' is a built-in function

 -- Built-in Function:  putenv (VAR, VALUE)
 -- Built-in Function:  setenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.
}

#
puts
{
`puts' is a built-in function

 -- Built-in Function:  puts (STRING)
     Write a string to the standard output with no formatting.

     Return a non-negative number on success and EOF on error.
}

#
pwd
{
`pwd' is a built-in function

 -- Built-in Function:  pwd ()
     Return the current working directory.

     See also: dir, ls
}

#
qp
{
`qp' is a function from the file /usr/share/octave/3.2.3/m/optimization/qp.m

 -- Function File: [X, OBJ, INFO, LAMBDA] = qp (X0, H, Q, A, B, LB, UB,
          A_LB, A_IN, A_UB)
     Solve the quadratic program

               min 0.5 x'*H*x + x'*q
                x

     subject to

               A*x = b
               lb <= x <= ub
               A_lb <= A_in*x <= A_ub

     using a null-space active-set method.

     Any bound (A, B, LB, UB, A_LB, A_UB) may be set to the empty
     matrix (`[]') if not present.  If the initial guess is feasible
     the algorithm is faster.

     The value INFO is a structure with the following fields:
    `solveiter'
          The number of iterations required to find the solution.

    `info'
          An integer indicating the status of the solution, as follows:
         0
               The problem is feasible and convex.  Global solution
               found.

         1
               The problem is not convex.  Local solution found.

         2
               The problem is not convex and unbounded.

         3
               Maximum number of iterations reached.

         6
               The problem is infeasible.
}

#
qqplot
{
`qqplot' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/qqplot.m

 -- Function File: [Q, S] = qqplot (X, DIST, PARAMS)
     Perform a QQ-plot (quantile plot).

     If F is the CDF of the distribution DIST with parameters PARAMS
     and G its inverse, and X a sample vector of length N, the QQ-plot
     graphs ordinate S(I) = I-th largest element of x versus abscissa
     Q(If) = G((I - 0.5)/N).

     If the sample comes from F except for a transformation of location
     and scale, the pairs will approximately follow a straight line.

     The default for DIST is the standard normal distribution.  The
     optional argument PARAMS contains a list of parameters of DIST.
     For example, for a quantile plot of the uniform distribution on
     [2,4] and X, use

          qqplot (x, "uniform", 2, 4)

     DIST can be any string for which a function DIST_INV that
     calculates the inverse CDF of distribution DIST exists.

     If no output arguments are given, the data are plotted directly.
}

#
qr
{
`qr' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/qr.oct

 -- Loadable Function: [Q, R, P] = qr (A)
 -- Loadable Function: [Q, R, P] = qr (A, '0')
     Compute the QR factorization of A, using standard LAPACK
     subroutines.  For example, given the matrix `a = [1, 2; 3, 4]',

          [q, r] = qr (a)

     returns

          q =

           -0.31623  -0.94868
           -0.94868   0.31623

          r =

           -3.16228  -4.42719
            0.00000  -0.63246

     The `qr' factorization has applications in the solution of least
     squares problems

          `min norm(A x - b)'

     for overdetermined systems of equations (i.e., `a' is a tall, thin
     matrix).  The QR factorization is `q * r = a' where `q' is an
     orthogonal matrix and `r' is upper triangular.

     If given a second argument of '0', `qr' returns an economy-sized
     QR factorization, omitting zero rows of R and the corresponding
     columns of Q.

     If the matrix A is full, the permuted QR factorization `[Q, R, P]
     = qr (A)' forms the QR factorization such that the diagonal
     entries of `r' are decreasing in magnitude order.  For
     example,given the matrix `a = [1, 2; 3, 4]',

          [q, r, p] = qr(a)

     returns

          q =

           -0.44721  -0.89443
           -0.89443   0.44721

          r =

           -4.47214  -3.13050
            0.00000   0.44721

          p =

            0  1
            1  0

     The permuted `qr' factorization `[q, r, p] = qr (a)' factorization
     allows the construction of an orthogonal basis of `span (a)'.

     If the matrix A is sparse, then compute the sparse QR factorization
     of A, using CSPARSE.  As the matrix Q is in general a full matrix,
     this function returns the Q-less factorization R of A, such that
     `R = chol (A' * A)'.

     If the final argument is the scalar `0' and the number of rows is
     larger than the number of columns, then an economy factorization is
     returned.  That is R will have only `size (A,1)' rows.

     If an additional matrix B is supplied, then `qr' returns C, where
     `C = Q' * B'.  This allows the least squares approximation of `A \
     B' to be calculated as

          [C,R] = spqr (A,B)
          X = R \ C
}

#
qrdelete
{
`qrdelete' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/qr.oct

 -- Loadable Function: [Q1, R1] = qrdelete (Q, R, J, ORIENT)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     [A(:,1:j-1) A(:,j+1:n)], i.e., A with one column deleted (if
     ORIENT is "col"), or the QR factorization of
     [A(1:j-1,:);A(:,j+1:n)], i.e., A with one row deleted (if ORIENT
     is "row").

     The default value of ORIENT is "col".

     If ORIENT is `"col"', J may be an index vector resulting in the
     QR factorization of a matrix B such that A(:,J) = [] gives B.
     Notice that the latter case is done as a sequence of k deletions;
     thus, for k large enough, it will be both faster and more accurate
     to recompute the factorization from scratch.

     If ORIENT is `"col"', the QR factorization supplied may be either
     full (Q is square) or economized (R is square).

     If ORIENT is `"row"', full factorization is needed.

     See also: qr, qrinsert, qrupdate
}

#
qrinsert
{
`qrinsert' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/qr.oct

 -- Loadable Function: [Q1, R1] = qrinsert (Q, R, J, X, ORIENT)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     [A(:,1:j-1) x A(:,j:n)], where U is a column vector to be inserted
     into A (if ORIENT is `"col"'), or the QR factorization of
     [A(1:j-1,:);x;A(:,j:n)], where X is a row vector to be inserted
     into A (if ORIENT is `"row"').

     The default value of ORIENT is `"col"'.  If ORIENT is `"col"', U
     may be a matrix and J an index vector resulting in the
     QR factorization of a matrix B such that B(:,J) gives U and
     B(:,J) = [] gives A.  Notice that the latter case is done as a
     sequence of k insertions; thus, for k large enough, it will be
     both faster and more accurate to recompute the factorization from
     scratch.

     If ORIENT is `"col"', the QR factorization supplied may be either
     full (Q is square) or economized (R is square).

     If ORIENT is `"row"', full factorization is needed.

     See also: qr, qrupdate, qrdelete
}

#
qrshift
{
`qrshift' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/qr.oct

 -- Loadable Function: [Q1, R1] = qrshift (Q, R, I, J)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     A(:,p), where p is the permutation
     `p = [1:i-1, shift(i:j, 1), j+1:n]' if I < J
     or
     `p = [1:j-1, shift(j:i,-1), i+1:n]' if J < I.
     See also: qr, qrinsert, qrdelete
}

#
qrupdate
{
`qrupdate' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/qr.oct

 -- Loadable Function: [Q1, R1] = qrupdate (Q, R, U, V)
     Given a QR factorization of a real or complex matrix A = Q*R,
     Q unitary and R upper trapezoidal, return the QR factorization of
     A + U*V', where U and V are column vectors (rank-1 update) or
     matrices with equal number of columns (rank-k update).  Notice
     that the latter case is done as a sequence of rank-1 updates;
     thus, for k large enough, it will be both faster and more accurate
     to recompute the factorization from scratch.

     The QR factorization supplied may be either full (Q is square) or
     economized (R is square).

     See also: qr, qrinsert, qrdelete
}

#
quad
{
`quad' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/quad.oct

 -- Loadable Function: [V, IER, NFUN, ERR] = quad (F, A, B, TOL, SING)
     Integrate a nonlinear function of one variable using Quadpack.
     The first argument is the name of the function, the function
     handle or the inline function to call to compute the value of the
     integrand.  It must have the form

          y = f (x)

     where Y and X are scalars.

     The second and third arguments are limits of integration.  Either
     or both may be infinite.

     The optional argument TOL is a vector that specifies the desired
     accuracy of the result.  The first element of the vector is the
     desired absolute tolerance, and the second element is the desired
     relative tolerance.  To choose a relative test only, set the
     absolute tolerance to zero.  To choose an absolute test only, set
     the relative tolerance to zero.

     The optional argument SING is a vector of values at which the
     integrand is known to be singular.

     The result of the integration is returned in V and IER contains an
     integer error code (0 indicates a successful integration).  The
     value of NFUN indicates how many function evaluations were
     required, and ERR contains an estimate of the error in the
     solution.

     You can use the function `quad_options' to set optional parameters
     for `quad'.

     It should be noted that since `quad' is written in Fortran it
     cannot be called recursively.
}

#
quad_options
{
`quad_options' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/quad.oct

 -- Loadable Function:  quad_options (OPT, VAL)
     When called with two arguments, this function allows you set
     options parameters for the function `quad'.  Given one argument,
     `quad_options' returns the value of the corresponding option.  If
     no arguments are supplied, the names of all the available options
     and their current values are displayed.

     Options include

    `"absolute tolerance"'
          Absolute tolerance; may be zero for pure relative error test.

    `"relative tolerance"'
          Nonnegative relative tolerance.  If the absolute tolerance is
          zero, the relative tolerance must be greater than or equal to
          `max (50*eps, 0.5e-28)'.

    `"single precision absolute tolerance"'
          Absolute tolerance for single precision; may be zero for pure
          relative error test.

    `"single precision relative tolerance"'
          Nonnegative relative tolerance for single precision.  If the
          absolute tolerance is zero, the relative tolerance must be
          greater than or equal to `max (50*eps, 0.5e-28)'.
}

#
quadgk
{
`quadgk' is a function from the file /usr/share/octave/3.2.3/m/general/quadgk.m

 -- Function File:  quadgk (F, A, B, ABSTOL, TRACE)
 -- Function File:  quadgk (F, A, B, PROP, VAL, ...)
 -- Function File: [Q, ERR] = quadgk (...)
     Numerically evaluate integral using adaptive Gauss-Konrod
     quadrature.  The formulation is based on a proposal by L.F.
     Shampine, `"Vectorized adaptive quadrature in MATLAB", Journal of
     Computational and Applied Mathematics, pp131-140, Vol 211, Issue 2,
     Feb 2008' where all function evaluations at an iteration are
     calculated with a single call to F.  Therefore the function F must
     be of the form `F (X)' and accept vector values of X and return a
     vector of the same length representing the function evaluations at
     the given values of X.  The function F can be defined in terms of
     a function handle, inline function or string.

     The bounds of the quadrature `[A, B]' can be finite or infinite
     and contain weak end singularities.  Variable transformation will
     be used to treat infinite intervals and weaken the singularities.
     For example

          quadgk(@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)

     Note that the formulation of the integrand uses the
     element-by-element operator `./' and all user functions to
     `quadgk' should do the same.

     The absolute tolerance can be passed as a fourth argument in a
     manner compatible with `quadv'.  Equally the user can request that
     information on the convergence can be printed is the fifth argument
     is logically true.

     Alternatively, certain properties of `quadgk' can be passed as
     pairs `PROP, VAL'.  Valid properties are

    `AbsTol'
          Defines the absolute error tolerance for the quadrature.  The
          default absolute tolerance is 1e-10.

    `RelTol'
          Defines the relative error tolerance for the quadrature.  The
          default relative tolerance is 1e-5.

    `MaxIntervalCount'
          `quadgk' initially subdivides the interval on which to perform
          the quadrature into 10 intervals.  Sub-intervals that have an
          unacceptable error are sub-divided and re-evaluated.  If the
          number of sub-intervals exceeds at any point 650
          sub-intervals then a poor convergence is signaled and the
          current estimate of the integral is returned.  The property
          'MaxIntervalCount' can be used to alter the number of
          sub-intervals that can exist before exiting.

    `WayPoints'
          If there exists discontinuities in the first derivative of the
          function to integrate, then these can be flagged with the
          `"WayPoints"' property.  This forces the ends of a
          sub-interval to fall on the breakpoints of the function and
          can result in significantly improved estimation of the error
          in the integral, faster computation or both.  For example,

               quadgk (@(x) abs (1 - x .^ 2), 0, 2, 'Waypoints', 1)

          signals the breakpoint in the integrand at `X = 1'.

    `Trace'
          If logically true, then `quadgk' prints information on the
          convergence of the quadrature at each iteration.

     If any of A, B or WAYPOINTS is complex, then the quadrature is
     treated as a contour integral along a piecewise continuous path
     defined by the above.  In this case the integral is assumed to
     have no edge singularities.  For example

          quadgk (@(z) log (z), 1+1i, 1+1i, "WayPoints",
                  [1-1i, -1,-1i, -1+1i])

     integrates `log (z)' along the square defined by `[1+1i,  1-1i,
     -1-1i, -1+1i]'

     If two output arguments are requested, then ERR returns the
     approximate bounds on the error in the integral `abs (Q - I)',
     where I is the exact value of the integral.

     See also: triplequad, dblquad, quad, quadl, quadv, trapz
}

#
quadl
{
`quadl' is a function from the file /usr/share/octave/3.2.3/m/general/quadl.m

 -- Function File: Q = quadl (F, A, B)
 -- Function File: Q = quadl (F, A, B, TOL)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE, P1, P2, ...)
     Numerically evaluate integral using adaptive Lobatto rule.  `quadl
     (F, A, B)' approximates the integral of `F(X)' to machine
     precision.  F is either a function handle, inline function or
     string containing the name of the function to evaluate.  The
     function F must return a vector of output values if given a vector
     of input values.

     If defined, TOL defines the relative tolerance to which to which
     to integrate `F(X)'.  While if TRACE is defined, displays the left
     end point of the current interval, the interval length, and the
     partial integral.

     Additional arguments P1, etc., are passed directly to F.  To use
     default values for TOL and TRACE, one may pass empty matrices.

     Reference: W. Gander and W. Gautschi, 'Adaptive Quadrature -
     Revisited', BIT Vol. 40, No. 1, March 2000, pp. 84-101.
     `http://www.inf.ethz.ch/personal/gander/'
}

#
quadv
{
`quadv' is a function from the file /usr/share/octave/3.2.3/m/general/quadv.m

 -- Function File: Q = quadv (F, A, B)
 -- Function File: Q = quadl (F, A, B, TOL)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE)
 -- Function File: Q = quadl (F, A, B, TOL, TRACE, P1, P2, ...)
 -- Function File: [Q, FCNT] = quadl (...)
     Numerically evaluate integral using adaptive Simpson's rule.
     `quadv (F, A, B)' approximates the integral of `F(X)' to the
     default absolute tolerance of `1e-6'.  F is either a function
     handle, inline function or string containing the name of the
     function to evaluate.  The function F must accept a string, and
     can return a vector representing the approximation to N different
     sub-functions.

     If defined, TOL defines the absolute tolerance to which to which
     to integrate each sub-interval of `F(X)'.  While if TRACE is
     defined, displays the left end point of the current interval, the
     interval length, and the partial integral.

     Additional arguments P1, etc., are passed directly to F.  To use
     default values for TOL and TRACE, one may pass empty matrices.

     See also: triplequad, dblquad, quad, quadl, quadgk, trapz
}

#
quantile
{
`quantile' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/quantile.m

 -- Function File: Q = quantile (X, P)
 -- Function File: Q = quantile (X, P, DIM)
 -- Function File: Q = quantile (X, P, DIM, METHOD)
     For a sample, X, calculate the quantiles, Q, corresponding to the
     cumulative probability values in P.  All non-numeric values (NaNs)
     of X are ignored.

     If X is a matrix, compute the quantiles for each column and return
     them in a matrix, such that the i-th row of Q contains the P(i)th
     quantiles of each column of X.

     The optional argument DIM determines the dimension along which the
     percentiles are calculated.  If DIM is omitted, and X is a vector
     or matrix, it defaults to 1 (column wise quantiles).  In the
     instance that X is a N-d array, DIM defaults to the first
     dimension whose size greater than unity.

     The methods available to calculate sample quantiles are the nine
     methods used by R (http://www.r-project.org/).  The default value
     is METHOD = 5.

     Discontinuous sample quantile methods 1, 2, and 3

       1. Method 1: Inverse of empirical distribution function.

       2. Method 2: Similar to method 1 but with averaging at
          discontinuities.

       3. Method 3: SAS definition: nearest even order statistic.

     Continuous sample quantile methods 4 through 9, where p(k) is the
     linear interpolation function respecting each methods'
     representative cdf.

       4. Method 4: p(k) = k / n. That is, linear interpolation of the
          empirical cdf.

       5. Method 5: p(k) = (k - 0.5) / n. That is a piecewise linear
          function where the knots are the values midway through the
          steps of the empirical cdf.

       6. Method 6: p(k) = k / (n + 1).

       7. Method 7: p(k) = (k - 1) / (n - 1).

       8. Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting
          quantile estimates are approximately median-unbiased
          regardless of the distribution of X.

       9. Method 9: p(k) = (k - 3/8) / (n + 1/4).  The resulting
          quantile estimates are approximately unbiased for the
          expected order statistics if X is normally distributed.

     Hyndman and Fan (1996) recommend method 8.  Maxima, S, and R
     (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS
     use method 6.  MATLAB uses method 5.

     References:

        * Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New
          S Language.  Wadsworth & Brooks/Cole.

        * Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in
          statistical packages, American Statistician, 50, 361-365.

        * R: A Language and Environment for Statistical Computing;
          `http://cran.r-project.org/doc/manuals/fullrefman.pdf'.
}

#
quit
{
`quit' is a built-in function

 -- Built-in Function:  exit (STATUS)
 -- Built-in Function:  quit (STATUS)
     Exit the current Octave session.  If the optional integer value
     STATUS is supplied, pass that value to the operating system as the
     Octave's exit status.  The default value is zero.
}

#
quiver
{
`quiver' is a function from the file /usr/share/octave/3.2.3/m/plot/quiver.m

 -- Function File:  quiver (U, V)
 -- Function File:  quiver (X, Y, U, V)
 -- Function File:  quiver (..., S)
 -- Function File:  quiver (..., STYLE)
 -- Function File:  quiver (..., 'filled')
 -- Function File:  quiver (H, ...)
 -- Function File: H = quiver (...)
     Plot the `(U, V)' components of a vector field in an `(X, Y)'
     meshgrid.  If the grid is uniform, you can specify X and Y as
     vectors.

     If X and Y are undefined they are assumed to be `(1:M, 1:N)' where
     `[M, N] = size(U)'.

     The variable S is a scalar defining a scaling factor to use for
     the arrows of the field relative to the mesh spacing.  A value of 0
     disables all scaling.  The default value is 1.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the `plot'
     command.  If a marker is specified then markers at the grid points
     of the vectors are printed rather than arrows.  If the argument
     'filled' is given then the markers as filled.

     The optional return value H provides a quiver group that regroups
     the components of the quiver plot (body, arrow and marker), and
     allows them to be changed together

          [x, y] = meshgrid (1:2:20);
          h = quiver (x, y, sin (2*pi*x/10), sin (2*pi*y/10));
          set (h, "maxheadsize", 0.33);

     See also: plot
}

#
quiver3
{
`quiver3' is a function from the file /usr/share/octave/3.2.3/m/plot/quiver3.m

 -- Function File:  quiver3 (U, V, W)
 -- Function File:  quiver3 (X, Y, Z, U, V, W)
 -- Function File:  quiver3 (..., S)
 -- Function File:  quiver3 (..., STYLE)
 -- Function File:  quiver3 (..., 'filled')
 -- Function File:  quiver3 (H, ...)
 -- Function File: H = quiver3 (...)
     Plot the `(U, V, W)' components of a vector field in an `(X, Y),
     Z' meshgrid.  If the grid is uniform, you can specify X, Y Z as
     vectors.

     If X, Y and Z are undefined they are assumed to be `(1:M, 1:N,
     1:P)' where `[M, N] = size(U)' and `P = max (size (W))'.

     The variable S is a scalar defining a scaling factor to use for
     the arrows of the field relative to the mesh spacing.  A value of 0
     disables all scaling.  The default value is 1.

     The style to use for the plot can be defined with a line style
     STYLE in a similar manner to the line styles used with the `plot'
     command.  If a marker is specified then markers at the grid points
     of the vectors are printed rather than arrows.  If the argument
     'filled' is given then the markers as filled.

     The optional return value H provides a quiver group that regroups
     the components of the quiver plot (body, arrow and marker), and
     allows them to be changed together

          [x, y, z] = peaks (25);
          surf (x, y, z);
          hold on;
          [u, v, w] = surfnorm (x, y, z / 10);
          h = quiver3 (x, y, z, u, v, w);
          set (h, "maxheadsize", 0.33);

     See also: plot
}

#
qz
{
`qz' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/qz.oct

 -- Loadable Function: LAMBDA = qz (A, B)
     Generalized eigenvalue problem A x = s B x, QZ decomposition.
     There are three ways to call this function:
       1. `lambda = qz(A,B)'

          Computes the generalized eigenvalues LAMBDA of (A - s B).

       2. `[AA, BB, Q, Z, V, W, lambda] = qz (A, B)'

          Computes qz decomposition, generalized eigenvectors, and
          generalized eigenvalues of (A - sB)

                  A*V = B*V*diag(lambda)
                  W'*A = diag(lambda)*W'*B
                  AA = Q'*A*Z, BB = Q'*B*Z
          with Q and Z orthogonal (unitary)= I

       3. `[AA,BB,Z{, lambda}] = qz(A,B,opt)'

          As in form [2], but allows ordering of generalized eigenpairs
          for (e.g.) solution of discrete time algebraic Riccati
          equations.  Form 3 is not available for complex matrices, and
          does not compute the generalized eigenvectors V, W, nor the
          orthogonal matrix Q.
         OPT
               for ordering eigenvalues of the GEP pencil.  The leading
               block of the revised pencil contains all eigenvalues
               that satisfy:
              `"N"'
                    = unordered (default)

              `"S"'
                    = small: leading block has all |lambda| <=1

              `"B"'
                    = big: leading block has all |lambda| >= 1

              `"-"'
                    = negative real part: leading block has all
                    eigenvalues in the open left half-plane

              `"+"'
                    = non-negative real part: leading block has all
                    eigenvalues in the closed right half-plane

     Note: qz performs permutation balancing, but not scaling (see
     balance).  Order of output arguments was selected for
     compatibility with MATLAB

     See also: balance, eig, schur
}

#
qzhess
{
`qzhess' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/qzhess.m

 -- Function File: [AA, BB, Q, Z] = qzhess (A, B)
     Compute the Hessenberg-triangular decomposition of the matrix
     pencil `(A, B)', returning `AA = Q * A * Z', `BB = Q * B * Z',
     with Q and Z orthogonal.  For example,

          [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
               => aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
               => bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
               =>  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
               =>  z = [ 1, 0; 0, 1 ]

     The Hessenberg-triangular decomposition is the first step in Moler
     and Stewart's QZ decomposition algorithm.

     Algorithm taken from Golub and Van Loan, `Matrix Computations, 2nd
     edition'.
}

#
rainbow
{
`rainbow' is a function from the file /usr/share/octave/3.2.3/m/image/rainbow.m

 -- Function File:  rainbow (N)
     Create color colormap.  This colormap is red through orange,
     yellow, green, blue to violet.  The argument N should be a scalar.
     If it is omitted, the length of the current colormap or 64 is
     assumed.

     See also: colormap
}

#
rand
{
`rand' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/rand.oct

 -- Loadable Function:  rand (X)
 -- Loadable Function:  rand (N, M)
 -- Loadable Function:  rand ("state", X)
 -- Loadable Function:  rand ("seed", X)
     Return a matrix with random elements uniformly distributed on the
     interval (0, 1).  The arguments are handled the same as the
     arguments for `eye'.

     You can query the state of the random number generator using the
     form

          v = rand ("state")

     This returns a column vector V of length 625.  Later, you can
     restore the random number generator to the state V using the form

          rand ("state", v)

     You may also initialize the state vector from an arbitrary vector
     of length <= 625 for V.  This new state will be a hash based on the
     value of V, not V itself.

     By default, the generator is initialized from `/dev/urandom' if it
     is available, otherwise from cpu time, wall clock time and the
     current fraction of a second.

     To compute the pseudo-random sequence, `rand' uses the Mersenne
     Twister with a period of 2^19937-1 (See M. Matsumoto and T.
     Nishimura, `Mersenne Twister: A 623-dimensionally equidistributed
     uniform pseudorandom number generator', ACM Trans. on Modeling and
     Computer Simulation Vol. 8, No. 1, January pp.3-30 1998,
     `http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html').  Do
     *not* use for cryptography without securely hashing several
     returned values together, otherwise the generator state can be
     learned after reading 624 consecutive values.

     Older versions of Octave used a different random number generator.
     The new generator is used by default as it is significantly faster
     than the old generator, and produces random numbers with a
     significantly longer cycle time.  However, in some circumstances
     it might be desirable to obtain the same random sequences as used
     by the old generators.  To do this the keyword "seed" is used to
     specify that the old generators should be use, as in

          rand ("seed", val)

     which sets the seed of the generator to VAL.  The seed of the
     generator can be queried with

          s = rand ("seed")

     However, it should be noted that querying the seed will not cause
     `rand' to use the old generators, only setting the seed will.  To
     cause `rand' to once again use the new generators, the keyword
     "state" should be used to reset the state of the `rand'.

     See also: randn, rande, randg, randp
}

#
rande
{
`rande' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/rand.oct

 -- Loadable Function:  rande (X)
 -- Loadable Function:  rande (N, M)
 -- Loadable Function:  rande ("state", X)
 -- Loadable Function:  rande ("seed", X)
     Return a matrix with exponentially distributed random elements.
     The arguments are handled the same as the arguments for `rand'.

     By default, `randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to a exponential
     distribution.  (G. Marsaglia and W.W. Tsang, `Ziggurat method for
     generating random variables', J. Statistical Software, vol 5, 2000,
     `http://www.jstatsoft.org/v05/i08/')

     See also: rand, randn, randg, randp
}

#
randg
{
`randg' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/rand.oct

 -- Loadable Function:  randg (A, X)
 -- Loadable Function:  randg (A, N, M)
 -- Loadable Function:  randg ("state", X)
 -- Loadable Function:  randg ("seed", X)
     Return a matrix with `gamma(A,1)' distributed random elements.
     The arguments are handled the same as the arguments for `rand',
     except for the argument A.

     This can be used to generate many distributions:

    `gamma (a, b)' for `a > -1', `b > 0'
               r = b * randg (a)

    `beta (a, b)' for `a > -1', `b > -1'
               r1 = randg (a, 1)
               r = r1 / (r1 + randg (b, 1))

    `Erlang (a, n)'
               r = a * randg (n)

    `chisq (df)' for `df > 0'
               r = 2 * randg (df / 2)

    `t(df)' for `0 < df < inf' (use randn if df is infinite)
               r = randn () / sqrt (2 * randg (df / 2) / df)

    `F (n1, n2)' for `0 < n1', `0 < n2'
               ## r1 equals 1 if n1 is infinite
               r1 = 2 * randg (n1 / 2) / n1
               ## r2 equals 1 if n2 is infinite
               r2 = 2 * randg (n2 / 2) / n2
               r = r1 / r2

    negative `binomial (n, p)' for `n > 0', `0 < p <= 1'
               r = randp ((1 - p) / p * randg (n))

    non-central `chisq (df, L)', for `df >= 0' and `L > 0'
          (use chisq if `L = 0')
               r = randp (L / 2)
               r(r > 0) = 2 * randg (r(r > 0))
               r(df > 0) += 2 * randg (df(df > 0)/2)

    `Dirichlet (a1, ... ak)'
               r = (randg (a1), ..., randg (ak))
               r = r / sum (r)

     See also: rand, randn, rande, randp
}

#
randn
{
`randn' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/rand.oct

 -- Loadable Function:  randn (X)
 -- Loadable Function:  randn (N, M)
 -- Loadable Function:  randn ("state", X)
 -- Loadable Function:  randn ("seed", X)
     Return a matrix with normally distributed pseudo-random elements
     having zero mean and variance one.  The arguments are handled the
     same as the arguments for `rand'.

     By default, `randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to a normal distribution.
     (G. Marsaglia and W.W. Tsang, `Ziggurat method for generating
     random variables', J. Statistical Software, vol 5, 2000,
     `http://www.jstatsoft.org/v05/i08/')

     See also: rand, rande, randg, randp
}

#
randp
{
`randp' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/rand.oct

 -- Loadable Function:  randp (L, X)
 -- Loadable Function:  randp (L, N, M)
 -- Loadable Function:  randp ("state", X)
 -- Loadable Function:  randp ("seed", X)
     Return a matrix with Poisson distributed random elements with mean
     value parameter given by the first argument, L.  The arguments are
     handled the same as the arguments for `rand', except for the
     argument L.

     Five different algorithms are used depending on the range of L and
     whether or not L is a scalar or a matrix.

    For scalar L <= 12, use direct method.
          Press, et al., 'Numerical Recipes in C', Cambridge University
          Press, 1992.

    For scalar L > 12, use rejection method.[1]
          Press, et al., 'Numerical Recipes in C', Cambridge University
          Press, 1992.

    For matrix L <= 10, use inversion method.[2]
          Stadlober E., et al., WinRand source code, available via FTP.

    For matrix L > 10, use patchwork rejection method.
          Stadlober E., et al., WinRand source code, available via FTP,
          or H. Zechner, 'Efficient sampling from continuous and
          discrete unimodal distributions', Doctoral Dissertation,
          156pp., Technical University Graz, Austria, 1994.

    For L > 1e8, use normal approximation.
          L. Montanet, et al., 'Review of Particle Properties',
          Physical Review D 50 p1284, 1994

     See also: rand, randn, rande, randg
}

#
randperm
{
`randperm' is a function from the file /usr/share/octave/3.2.3/m/general/randperm.m

 -- Function File:  randperm (N)
     Return a row vector containing a random permutation of the
     integers from 1 to N.
}

#
range
{
`range' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/range.m

 -- Function File:  range (X)
 -- Function File:  range (X, DIM)
     If X is a vector, return the range, i.e., the difference between
     the maximum and the minimum, of the input data.

     If X is a matrix, do the above for each column of X.

     If the optional argument DIM is supplied, work along dimension DIM.
}

#
rank
{
`rank' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/rank.m

 -- Function File:  rank (A, TOL)
     Compute the rank of A, using the singular value decomposition.
     The rank is taken to be the number of singular values of A that
     are greater than the specified tolerance TOL.  If the second
     argument is omitted, it is taken to be

          tol = max (size (A)) * sigma(1) * eps;

     where `eps' is machine precision and `sigma(1)' is the largest
     singular value of A.
}

#
ranks
{
`ranks' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/ranks.m

 -- Function File:  ranks (X, DIM)
     Return the ranks of X along the first non-singleton dimension
     adjust for ties.  If the optional argument DIM is given, operate
     along this dimension.
}

#
rat
{
`rat' is a function from the file /usr/share/octave/3.2.3/m/general/rat.m

 -- Function File: S = rat (X, TOL)
 -- Function File: [N, D] = rat (X, TOL)
     Find a rational approximation to X within the tolerance defined by
     TOL using a continued fraction expansion.  For example,

          rat(pi) = 3 + 1/(7 + 1/16) = 355/113
          rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
                 = 1457/536

     Called with two arguments returns the numerator and denominator
     separately as two matrices.

   See also: rats
}

#
rats
{
`rats' is a built-in function

 -- Built-in Function:  rats (X, LEN)
     Convert X into a rational approximation represented as a string.
     You can convert the string back into a matrix as follows:

            r = rats(hilb(4));
            x = str2num(r)

     The optional second argument defines the maximum length of the
     string representing the elements of X.  By default LEN is 9.

     See also: format, rat
}

#
rcond
{
`rcond' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/rcond.oct

 -- Loadable Function: C = rcond (A)
     Compute the 1-norm estimate of the reciprocal condition as returned
     by LAPACK.  If the matrix is well-conditioned then C will be near
     1 and if the matrix is poorly conditioned it will be close to zero.

     The matrix A must not be sparse.  If the matrix is sparse then
     `condest (A)' or `rcond (full (A))' should be used instead.

     See also: inv
}

#
rdivide
{
`rdivide' is a built-in function

 -- Built-in Function:  rdivide (X, Y)
     This function is equivalent to `x ./ y'.
}

#
re_read_readline_init_file
{
`re_read_readline_init_file' is a built-in function

 -- Built-in Function:  re_read_readline_init_file ()
     Re-read the last readline library initialization file that was
     read.  *Note Readline Init File: (readline)Readline Init File, for
     details.
}

#
read_readline_init_file
{
`read_readline_init_file' is a built-in function

 -- Built-in Function:  read_readline_init_file (FILE)
     Read the readline library initialization file FILE.  If FILE is
     omitted, read the default initialization file (normally
     `~/.inputrc').

     *Note Readline Init File: (readline)Readline Init File, for
     details.
}

#
readdir
{
`readdir' is a built-in function

 -- Built-in Function: [FILES, ERR, MSG] = readdir (DIR)
     Return names of the files in the directory DIR as a cell array of
     strings.  If an error occurs, return an empty cell array in FILES.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: dir, glob
}

#
readlink
{
`readlink' is a built-in function

 -- Built-in Function: [RESULT, ERR, MSG] = readlink (SYMLINK)
     Read the value of the symbolic link SYMLINK.

     If successful, RESULT contains the contents of the symbolic link
     SYMLINK, ERR is 0 and MSG is an empty string.  Otherwise, ERR is
     nonzero and MSG contains a system-dependent error message.

     See also: link, symlink
}

#
real
{
`real' is a built-in function

 -- Mapping Function:  real (Z)
     Return the real part of Z.

     See also: imag, conj
}

#
reallog
{
`reallog' is a function from the file /usr/share/octave/3.2.3/m/specfun/reallog.m

 -- Function File:  reallog (X)
     Return the real-valued natural logarithm of each element of X.
     Report an error if any element results in a complex return value.

     See also: log, realpow, realsqrt
}

#
realmax
{
`realmax' is a built-in function

 -- Built-in Function:  realmax
 -- Built-in Function:  realmax (N)
 -- Built-in Function:  realmax (N, M)
 -- Built-in Function:  realmax (N, M, K, ...)
 -- Built-in Function:  realmax (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the largest floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, `realmax' is
     approximately 1.7977e+308 for double precision and 3.4028e+38 for
     single precision.

     When called with no arguments, return a scalar with the value
     `realmax("double")'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return type and may be either "double" or "single".

     See also: realmin, intmax, bitmax
}

#
realmin
{
`realmin' is a built-in function

 -- Built-in Function:  realmin
 -- Built-in Function:  realmin (N)
 -- Built-in Function:  realmin (N, M)
 -- Built-in Function:  realmin (N, M, K, ...)
 -- Built-in Function:  realmin (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the smallest normalized floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, `realmin' is
     approximately 2.2251e-308 for double precision and 1.1755e-38 for
     single precision.

     When called with no arguments, return a scalar with the value
     `realmin("double")'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return type and may be either "double" or "single".

     See also: realmax, intmin
}

#
realpow
{
`realpow' is a function from the file /usr/share/octave/3.2.3/m/specfun/realpow.m

 -- Function File:  realpow (X, Y)
     Compute the real-valued, element-by-element power operator.  This
     is equivalent to `X .^ Y', except that `realpow' reports an error
     if any return value is complex.

     See also: reallog, realsqrt
}

#
realsqrt
{
`realsqrt' is a function from the file /usr/share/octave/3.2.3/m/specfun/realsqrt.m

 -- Function File:  realsqrt (X)
     Return the real-valued square root of each element of X.  Report an
     error if any element results in a complex return value.

     See also: sqrt, realpow, reallog
}

#
record
{
`record' is a function from the file /usr/share/octave/3.2.3/m/audio/record.m

 -- Function File:  record (SEC, SAMPLING_RATE)
     Records SEC seconds of audio input into the vector X.  The default
     value for SAMPLING_RATE is 8000 samples per second, or 8kHz.  The
     program waits until the user types <RET> and then immediately
     starts to record.

     See also: lin2mu, mu2lin, loadaudio, saveaudio, playaudio, setaudio
}

#
rectangle_lw
{
`rectangle_lw' is a function from the file /usr/share/octave/3.2.3/m/signal/rectangle_lw.m

 -- Function File:  rectangle_lw (N, B)
     Rectangular lag window.  Subfunction used for spectral density
     estimation.
}

#
rectangle_sw
{
`rectangle_sw' is a function from the file /usr/share/octave/3.2.3/m/signal/rectangle_sw.m

 -- Function File:  rectangle_sw (N, B)
     Rectangular spectral window.  Subfunction used for spectral density
     estimation.
}

#
rectint
{
`rectint' is a function from the file /usr/share/octave/3.2.3/m/geometry/rectint.m

 -- Function File: AREA = rectint (A, B)
     Compute the area of intersection of rectangles in A and rectangles
     in B.  Rectangles are defined as [x y width height] where x and y
     are the minimum values of the two orthogonal dimensions.

     If A or B are matrices, then the output, AREA, is a matrix where
     the i-th row corresponds to the i-th row of a and the j-th column
     corresponds to the j-th row of b.

     See also: polyarea
}

#
refresh
{
`refresh' is a function from the file /usr/share/octave/3.2.3/m/plot/refresh.m

 -- Function File:  refresh ()
 -- Function File:  refresh (H)
     Refresh a figure, forcing it to be redrawn.  Called without an
     argument the current figure is redrawn, otherwise the figure
     pointed to by H is redrawn.

     See also: drawnow
}

#
refreshdata
{
`refreshdata' is a function from the file /usr/share/octave/3.2.3/m/plot/refreshdata.m

 -- Function File:  refreshdata ()
 -- Function File:  refreshdata (H)
 -- Function File:  refreshdata (H, WORKSPACE)
     Evaluate any `datasource' properties of the current figure and
     update the plot if the corresponding data has changed.  If called
     with one or more arguments H is a scalar or array of figure
     handles to refresh.  The optional second argument WORKSPACE can
     take the following values.

    `"base"'
          Evaluate the datasource properties in the base workspace.
          (default).

    `"caller"'
          Evaluate the datasource properties in the workspace of the
          function that called `refreshdata'.

     An example of the use of `refreshdata' is:

          x = 0:0.1:10;
          y = sin (x);
          plot (x, y, "ydatasource", "y");
          for i = 1 : 100
            pause(0.1)
            y = sin (x + 0.1 * i);
            refreshdata();
          endfor
}

#
regexp
{
`regexp' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/regexp.oct

 -- Loadable Function: [S, E, TE, M, T, NM] = regexp (STR, PAT)
 -- Loadable Function: [...] = regexp (STR, PAT, OPTS, ...)
     Regular expression string matching.  Matches PAT in STR and
     returns the position and matching substrings or empty values if
     there are none.

     The matched pattern PAT can include any of the standard regex
     operators, including:

    `.'
          Match any character

    `* + ? {}'
          Repetition operators, representing
         `*'
               Match zero or more times

         `+'
               Match one or more times

         `?'
               Match zero or one times

         `{}'
               Match range operator, which is of the form `{N}' to
               match exactly N times, `{M,}' to match M or more times,
               `{M,N}' to match between M and N times.

    `[...] [^...]'
          List operators, where for example `[ab]c' matches `ac' and
          `bc'

    `()'
          Grouping operator

    `|'
          Alternation operator.  Match one of a choice of regular
          expressions.  The alternatives must be delimited by the
          grouping operator `()' above

    `^ $'
          Anchoring operator.  `^' matches the start of the string STR
          and `$' the end

     In addition the following escaped characters have special meaning.
     It should be noted that it is recommended to quote PAT in single
     quotes rather than double quotes, to avoid the escape sequences
     being interpreted by Octave before being passed to `regexp'.

    `\b'
          Match a word boundary

    `\B'
          Match within a word

    `\w'
          Matches any word character

    `\W'
          Matches any non word character

    `\<'
          Matches the beginning of a word

    `\>'
          Matches the end of a word

    `\s'
          Matches any whitespace character

    `\S'
          Matches any non whitespace character

    `\d'
          Matches any digit

    `\D'
          Matches any non-digit

     The outputs of `regexp' by default are in the order as given below

    S
          The start indices of each of the matching substrings

    E
          The end indices of each matching substring

    TE
          The extents of each of the matched token surrounded by
          `(...)' in PAT.

    M
          A cell array of the text of each match.

    T
          A cell array of the text of each token matched.

    NM
          A structure containing the text of each matched named token,
          with the name being used as the fieldname.  A named token is
          denoted as `(?<name>...)'

     Particular output arguments or the order of the output arguments
     can be selected by additional OPTS arguments.  These are strings
     and the correspondence between the output arguments and the
     optional argument are

                   'start'              S                    
                   'end'                E                    
                   'tokenExtents'       TE                   
                   'match'              M                    
                   'tokens'             T                    
                   'names'              NM                   

     A further optional argument is 'once', that limits the number of
     returned matches to the first match.  Additional arguments are

    matchcase
          Make the matching case sensitive.

    ignorecase
          Make the matching case insensitive.

    stringanchors
          Match the anchor characters at the beginning and end of the
          string.

    lineanchors
          Match the anchor characters at the beginning and end of the
          line.

    dotall
          The character `.' matches the newline character.

    dotexceptnewline
          The character `.' matches all but the newline character.

    freespacing
          The pattern can include arbitrary whitespace and comments
          starting with `#'.

    literalspacing
          The pattern is taken literally.

     See also: regexpi, regexprep
}

#
regexpi
{
`regexpi' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/regexp.oct

 -- Loadable Function: [S, E, TE, M, T, NM] = regexpi (STR, PAT)
 -- Loadable Function: [...] = regexpi (STR, PAT, OPTS, ...)
     Case insensitive regular expression string matching.  Matches PAT
     in STR and returns the position and matching substrings or empty
     values if there are none.  *Note regexp: doc-regexp, for more
     details
}

#
regexprep
{
`regexprep' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/regexp.oct

 -- Loadable Function: STRING = regexprep (STRING, PAT, REPSTR, OPTIONS)
     Replace matches of PAT in  STRING with REPSTR.

     The replacement can contain `$i', which substitutes for the ith
     set of parentheses in the match string.  E.g.,

            regexprep("Bill Dunn",'(\w+) (\w+)','$2, $1')
     returns "Dunn, Bill"

     OPTIONS may be zero or more of
    `once'
          Replace only the first occurrence of PAT in the result.

    `warnings'
          This option is present for compatibility but is ignored.

    `ignorecase or matchcase'
          Ignore case for the pattern matching (see `regexpi').
          Alternatively, use (?i) or (?-i) in the pattern.

    `lineanchors and stringanchors'
          Whether characters ^ and $ match the beginning and ending of
          lines.  Alternatively, use (?m) or (?-m) in the pattern.

    `dotexceptnewline and dotall'
          Whether . matches newlines in the string.  Alternatively, use
          (?s) or (?-s) in the pattern.

    `freespacing or literalspacing'
          Whether whitespace and # comments can be used to make the
          regular expression more readable.  Alternatively, use (?x) or
          (?-x) in the pattern.


     See also: regexp, regexpi, strrep
}

#
regexptranslate
{
`regexptranslate' is a function from the file /usr/share/octave/3.2.3/m/strings/regexptranslate.m

 -- Function File:  regexptranslate (OP, S)
     Translate a string for use in a regular expression.  This might
     include either wildcard replacement or special character escaping.
     The behavior can be controlled by the OP that can have the values

    "wildcard"
          The wildcard characters `.', `*' and `?' are replaced with
          wildcards that are appropriate for a regular expression.  For
          example:
               regexptranslate ("wildcard", "*.m")
                    => ".*\.m"

    "escape"
          The characters `$.?[]', that have special meaning for regular
          expressions are escaped so that they are treated literally.
          For example:
               regexptranslate ("escape", "12.5")
                    => "12\.5"

     See also: regexp, regexpi, regexprep
}

#
rehash
{
`rehash' is a built-in function

 -- Built-in Function:  rehash ()
     Reinitialize Octave's load path directory cache.
}

#
rem
{
`rem' is a function from the file /usr/share/octave/3.2.3/m/general/rem.m

 -- Mapping Function:  rem (X, Y)
     Return the remainder of the division `X / Y', computed using the
     expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.

     See also: mod, fmod
}

#
remove_input_event_hook
{
`remove_input_event_hook' is a built-in function

 -- Built-in Function:  remove_input_event_hook (FCN)
     Remove the named function FCN to the list of functions to call
     periodically when Octave is waiting for input.

     See also: add_input_event_hook
}

#
rename
{
`rename' is a built-in function

 -- Built-in Function: [ERR, MSG] = rename (OLD, NEW)
     Change the name of file OLD to NEW.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: ls, dir
}

#
replot
{
`replot' is a function from the file /usr/share/octave/3.2.3/m/plot/replot.m

 -- Function File:  replot ()
     Refresh the plot window.
}

#
repmat
{
`repmat' is a function from the file /usr/share/octave/3.2.3/m/general/repmat.m

 -- Function File:  repmat (A, M, N)
 -- Function File:  repmat (A, [M N])
 -- Function File:  repmat (A, [M N P ...])
     Form a block matrix of size M by N, with a copy of matrix A as
     each element.  If N is not specified, form an M by M block matrix.
}

#
reshape
{
`reshape' is a built-in function

 -- Built-in Function:  reshape (A, M, N, ...)
 -- Built-in Function:  reshape (A, SIZE)
     Return a matrix with the given dimensions whose elements are taken
     from the matrix A.  The elements of the matrix are accessed in
     column-major order (like Fortran arrays are stored).

     For example,

          reshape ([1, 2, 3, 4], 2, 2)
              =>  1  3
                  2  4

     Note that the total number of elements in the original matrix must
     match the total number of elements in the new matrix.

     A single dimension of the return matrix can be unknown and is
     flagged by an empty argument.
}

#
residue
{
`residue' is a function from the file /usr/share/octave/3.2.3/m/polynomial/residue.m

 -- Function File: [R, P, K, E] = residue (B, A)
     Compute the partial fraction expansion for the quotient of the
     polynomials, B and A.

           B(s)    M       r(m)         N
           ---- = SUM -------------  + SUM k(i)*s^(N-i)
           A(s)   m=1 (s-p(m))^e(m)    i=1

     where M is the number of poles (the length of the R, P, and E),
     the K vector is a polynomial of order N-1 representing the direct
     contribution, and the E vector specifies the multiplicity of the
     m-th residue's pole.

     For example,

          b = [1, 1, 1];
          a = [1, -5, 8, -4];
          [r, p, k, e] = residue (b, a);
               => r = [-2; 7; 3]
               => p = [2; 2; 1]
               => k = [](0x0)
               => e = [1; 2; 1]

     which represents the following partial fraction expansion

                  s^2 + s + 1       -2        7        3
             ------------------- = ----- + ------- + -----
             s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)

 -- Function File: [B, A] = residue (R, P, K)
 -- Function File: [B, A] = residue (R, P, K, E)
     Compute the reconstituted quotient of polynomials, B(s)/A(s), from
     the partial fraction expansion; represented by the residues,
     poles, and a direct polynomial specified by R, P and K, and the
     pole multiplicity E.

     If the multiplicity, E, is not explicitly specified the
     multiplicity is determined by the script mpoles.m.

     For example,

          r = [-2; 7; 3];
          p = [2; 2; 1];
          k = [1, 0];
          [b, a] = residue (r, p, k);
               => b = [1, -5, 9, -3, 1]
               => a = [1, -5, 8, -4]

          where mpoles.m is used to determine e = [1; 2; 1]

     Alternatively the multiplicity may be defined explicitly, for
     example,

          r = [7; 3; -2];
          p = [2; 1; 2];
          k = [1, 0];
          e = [2; 1; 1];
          [b, a] = residue (r, p, k, e);
               => b = [1, -5, 9, -3, 1]
               => a = [1, -5, 8, -4]

     which represents the following partial fraction expansion

              -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
             ----- + ------- + ----- + s = --------------------------
             (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4

     See also: poly, roots, conv, deconv, mpoles, polyval, polyderiv,
     polyinteg
}

#
resize
{
`resize' is a built-in function

 -- Built-in Function:  resize (X, M)
 -- Built-in Function:  resize (X, M, N)
 -- Built-in Function:  resize (X, M, N, ...)
     Resize X cutting off elements as necessary.

     In the result, element with certain indices is equal to the
     corresponding element of X if the indices are within the bounds of
     X; otherwise, the element is set to zero.

     In other words, the statement

           y = resize (x, dv);

     is equivalent to the following code:

           y = zeros (dv, class (x));
           sz = min (dv, size (x));
           for i = 1:length (sz), idx{i} = 1:sz(i); endfor
           y(idx{:}) = x(idx{:});

     but is performed more efficiently.

     If only M is supplied and it is a scalar, the dimension of the
     result is M-by-M.  If M is a vector, then the dimensions of the
     result are given by the elements of M.  If both M and N are
     scalars, then the dimensions of the result are M-by-N.

     An object can be resized to more dimensions than it has; in such
     case the missing dimensions are assumed to be 1.  Resizing an
     object to fewer dimensions is not possible.

     See also: reshape, postpad
}

#
restoredefaultpath
{
`restoredefaultpath' is a built-in function

 -- Built-in Function:  restoredefaultpath (...)
     Restore Octave's path to it's initial state at startup.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep
}

#
rethrow
{
`rethrow' is a built-in function

 -- Built-in Function:  rethrow (ERR)
     Reissues a previous error as defined by ERR.  ERR is a structure
     that must contain at least the 'message' and 'identifier' fields.
     ERR can also contain a field 'stack' that gives information on the
     assumed location of the error.  Typically ERR is returned from
     `lasterror'.

     See also: lasterror, lasterr, error
}

#
return
{

 -- Keyword: return
     Return from a function.

     See also: function
}

#
reverse
{
`reverse' is a built-in function

 -- Built-in Function:  reverse (LIST)
     Return a new list created by reversing the elements of LIST.
}

#
rgb2hsv
{
`rgb2hsv' is a function from the file /usr/share/octave/3.2.3/m/image/rgb2hsv.m

 -- Function File: HSV_MAP = rgb2hsv (RGB_MAP)
     Transform a colormap or image from the rgb space to the hsv space.

     A color n the RGB space consists of the red, green and blue
     intensities.

     In the HSV space each color is represented by their hue, saturation
     and value (brightness).  Value gives the amount of light in the
     color.  Hue describes the dominant wavelength.  Saturation is the
     amount of Hue mixed into the color.

     See also: hsv2rgb
}

#
rgb2ind
{
`rgb2ind' is a function from the file /usr/share/octave/3.2.3/m/image/rgb2ind.m

 -- Function File: [X, MAP] = rgb2ind (RGB)
 -- Function File: [X, MAP] = rgb2ind (R, G, B)
     Convert an RGB image to an Octave indexed image.

     See also: ind2rgb, rgb2ntsc
}

#
rgb2ntsc
{
`rgb2ntsc' is a function from the file /usr/share/octave/3.2.3/m/image/rgb2ntsc.m

 -- Function File:  rgb2ntsc (RGB)
     Transform a colormap or image from RGB to NTSC.

     See also: ntsc2rgb
}

#
ribbon
{
`ribbon' is a function from the file /usr/share/octave/3.2.3/m/plot/ribbon.m

 -- Function File:  ribbon (X, Y, WIDTH)
 -- Function File:  ribbon (Y)
 -- Function File: H = ribbon (...)
     Plot a ribbon plot for the columns of Y vs.  X.  The optional
     parameter WIDTH specifies the width of a single ribbon (default is
     0.75).  If X is omitted, a vector containing the row numbers is
     assumed (1:rows(Y)).  If requested, return a vector H of the
     handles to the surface objects.

     See also: gca, colorbar
}

#
rindex
{
`rindex' is a function from the file /usr/share/octave/3.2.3/m/strings/rindex.m

 -- Function File:  rindex (S, T)
     Return the position of the last occurrence of the character string
     T in the character string S, or 0 if no occurrence is found.  For
     example,

          rindex ("Teststring", "t")
               => 6

     *Caution:*  This function does not work for arrays of character
     strings.

     See also: find, index
}

#
rmdir
{
`rmdir' is a built-in function

 -- Built-in Function: [STATUS, MSG, MSGID] = rmdir (DIR)
 -- Built-in Function: [STATUS, MSG, MSGID] = rmdir (DIR, `"s"')
     Remove the directory named DIR.

     If successful, STATUS is 1, with MSG and MSGID empty character
     strings.  Otherwise, STATUS is 0, MSG contains a system-dependent
     error message, and MSGID contains a unique message identifier.

     If the optional second parameter is supplied with value `"s"',
     recursively remove all subdirectories as well.

     See also: mkdir, confirm_recursive_rmdir
}

#
rmfield
{
`rmfield' is a built-in function

 -- Built-in Function:  rmfield (S, F)
     Remove field F from the structure S.  If F is a cell array of
     character strings or a character array, remove the named fields.

     See also: cellstr, iscellstr, setfield
}

#
rmpath
{
`rmpath' is a built-in function

 -- Built-in Function:  rmpath (DIR1, ...)
     Remove DIR1, ... from the current function search path.

     See also: path, addpath, genpath, pathdef, savepath, pathsep
}

#
roots
{
`roots' is a function from the file /usr/share/octave/3.2.3/m/polynomial/roots.m

 -- Function File:  roots (V)
     For a vector V with N components, return the roots of the
     polynomial

          v(1) * z^(N-1) + ... + v(N-1) * z + v(N)

     As an example, the following code finds the roots of the quadratic
     polynomial
          p(x) = x^2 - 5.

          c = [1, 0, -5];
          roots(c)
          =>  2.2361
          => -2.2361
     Note that the true result is +/- sqrt(5) which is roughly +/-
     2.2361.

     See also: compan
}

#
rose
{
`rose' is a function from the file /usr/share/octave/3.2.3/m/plot/rose.m

 -- Function File:  rose (TH, R)
 -- Function File:  rose (H, ...)
 -- Function File: H = rose (...)
 -- Function File: [R, TH] = rose (...)
     Plot an angular histogram.  With one vector argument TH, plots the
     histogram with 20 angular bins.  If TH is a matrix, then each
     column of TH produces a separate histogram.

     If R is given and is a scalar, then the histogram is produced with
     R bins.  If R is a vector, then the center of each bin are defined
     by the values of R.

     The optional return value H provides a list of handles to the the
     parts of the vector field (body, arrow and marker).

     If two output arguments are requested, then rather than plotting
     the histogram, the polar vectors necessary to plot the histogram
     are returned.

          [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
          polar (r, t);

     See also: plot, compass, polar, hist
}

#
rosser
{
`rosser' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/rosser.m

 -- Function File:  rosser ()
     Returns the Rosser matrix.  This is a difficult test case used to
     test eigenvalue algorithms.

     See also: hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
              hadamard, wilkinson, compan, pascal
}

#
rot90
{
`rot90' is a function from the file /usr/share/octave/3.2.3/m/general/rot90.m

 -- Function File:  rot90 (X, N)
     Return a copy of X with the elements rotated counterclockwise in
     90-degree increments.  The second argument is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  Negative values of N rotate the matrix in a
     clockwise direction.  For example,

          rot90 ([1, 2; 3, 4], -1)
               =>  3  1
                   4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rot90 ([1, 2; 3, 4], -1)
          rot90 ([1, 2; 3, 4], 3)
          rot90 ([1, 2; 3, 4], 7)

     Due to the difficulty of defining an axis about which to rotate the
     matrix `rot90' only work with 2-D arrays.  To rotate N-d arrays
     use `rotdim' instead.

     See also: rotdim, flipud, fliplr, flipdim
}

#
rotdim
{
`rotdim' is a function from the file /usr/share/octave/3.2.3/m/general/rotdim.m

 -- Function File:  rotdim (X, N, PLANE)
     Return a copy of X with the elements rotated counterclockwise in
     90-degree increments.  The second argument is optional, and
     specifies how many 90-degree rotations are to be applied (the
     default value is 1).  The third argument is also optional and
     defines the plane of the rotation.  As such PLANE is a two element
     vector containing two different valid dimensions of the matrix.
     If PLANE is not given Then the first two non-singleton dimensions
     are used.

     Negative values of N rotate the matrix in a clockwise direction.
     For example,

          rotdim ([1, 2; 3, 4], -1, [1, 2])
               =>  3  1
                   4  2

     rotates the given matrix clockwise by 90 degrees.  The following
     are all equivalent statements:

          rotdim ([1, 2; 3, 4], -1, [1, 2])
          rotdim ([1, 2; 3, 4], 3, [1, 2])
          rotdim ([1, 2; 3, 4], 7, [1, 2])

     See also: rot90, flipud, fliplr, flipdim
}

#
round
{
`round' is a built-in function

 -- Mapping Function:  round (X)
     Return the integer nearest to X.  If X is complex, return `round
     (real (X)) + round (imag (X)) * I'.
          round ([-2.7, 2.7])
              => -3   3

     See also: ceil, floor, fix
}

#
roundb
{
`roundb' is a built-in function

 -- Mapping Function:  roundb (X)
     Return the integer nearest to X.  If there are two nearest
     integers, return the even one (banker's rounding).  If X is
     complex, return `roundb (real (X)) + roundb (imag (X)) * I'.

     See also: round
}

#
rows
{
`rows' is a built-in function

 -- Built-in Function:  rows (A)
     Return the number of rows of A.

     See also: size, numel, columns, length, isscalar, isvector,
     ismatrix
}

#
rref
{
`rref' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/rref.m

 -- Function File: [R, K] = rref (A, TOL)
     Returns the reduced row echelon form of A.  TOL defaults to `eps *
     max (size (A)) * norm (A, inf)'.

     Called with two return arguments, K returns the vector of "bound
     variables", which are those columns on which elimination has been
     performed.
}

#
run
{
`run' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/run.m

 -- Function File:  run (F)
 -- Command:  run F
     Run scripts in the current workspace that are not necessarily on
     the path.  If F is the script to run, including its path, then
     `run' change the directory to the directory where F is found.
     `run' then executes the script, and returns to the original
     directory.

     See also: system
}

#
run_count
{
`run_count' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/run_count.m

 -- Function File:  run_count (X, N)
     Count the upward runs along the first non-singleton dimension of X
     of length 1, 2, ..., N-1 and greater than or equal to N.  If the
     optional argument DIM is given operate along this dimension
}

#
run_history
{
`run_history' is a built-in function

 -- Command: run_history [FIRST] [LAST]
     Similar to `edit_history', except that the editor is not invoked,
     and the commands are simply executed as they appear in the history
     list.

     See also: edit_history
}

#
run_test
{
`run_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/run_test.m

 -- Function File: [PVAL, CHISQ] = run_test (X)
     Perform a chi-square test with 6 degrees of freedom based on the
     upward runs in the columns of X.  Can be used to test whether X
     contains independent data.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value is displayed.
}

#
rundemos
{
`rundemos' is a function from the file /usr/share/octave/3.2.3/m/testfun/rundemos.m

 -- Function File:  rundemos (DIRECTORY)
}

#
runlength
{
`runlength' is a function from the file /usr/share/octave/3.2.3/m/general/runlength.m

 -- Function File:  runlength (X)
     Find the lengths of all sequences of common values.  Return the
     vector of lengths and the value that was repeated.

          runlength ([2, 2, 0, 4, 4, 4, 0, 1, 1, 1, 1])
          =>  [2, 1, 3, 1, 4]
}

#
save
{
`save' is a built-in function

 -- Command: save file
 -- Command: save options file
 -- Command: save options file V1 V2 ...
 -- Command: save options file -struct STRUCT F1 F2 ...
     Save the named variables V1, V2, ..., in the file FILE.  The
     special filename `-' may be used to write output to the terminal.
     If no variable names are listed, Octave saves all the variables in
     the current scope.  Otherwise, full variable names or pattern
     syntax can be used to specify the variables to save.  If the
     `-struct' modifier is used, fields F1 F2 ...  of the scalar
     structure STRUCT are saved as if they were variables with
     corresponding names.  Valid options for the `save' command are
     listed in the following table.  Options that modify the output
     format override the format specified by `default_save_options'.

     If save is invoked using the functional form

          save ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

    `-ascii'
          Save a single matrix in a text file without header or any
          other information.

    `-binary'
          Save the data in Octave's binary data format.

    `-float-binary'
          Save the data in Octave's binary data format but only using
          single precision.  Only use this format if you know that all
          the values to be saved can be represented in single precision.

    `-hdf5'
          Save the data in HDF5 format.  (HDF5 is a free, portable
          binary format developed by the National Center for
          Supercomputing Applications at the University of Illinois.)

    `-float-hdf5'
          Save the data in HDF5 format but only using single precision.
          Only use this format if you know that all the values to be
          saved can be represented in single precision.

    `-V7'
    `-v7'
    `-7'
    `-mat7-binary'
          Save the data in MATLAB's v7 binary data format.

    `-V6'
    `-v6'
    `-6'
    `-mat'
    `-mat-binary'
          Save the data in MATLAB's v6 binary data format.

    `-V4'
    `-v4'
    `-4'
    `-mat4-binary'
          Save the data in the binary format written by MATLAB version
          4.

    `-text'
          Save the data in Octave's text data format.  (default).

    `-zip'
    `-z'
          Use the gzip algorithm to compress the file.  This works
          equally on files that are compressed with gzip outside of
          octave, and gzip can equally be used to convert the files for
          backward compatibility.

     The list of variables to save may use wildcard patterns containing
     the following special characters:
    `?'
          Match any single character.

    `*'
          Match zero or more characters.

    `[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is `!' or `^', match all characters except those
          specified by LIST.  For example, the pattern `[a-zA-Z]' will
          match all lower and upper case alphabetic characters.

          Wildcards may also be used in the field name specifications
          when using the `-struct' modifier (but not in the struct name
          itself).


     Except when using the MATLAB binary data file format or the
     `-ascii' format, saving global variables also saves the global
     status of the variable.  If the variable is restored at a later
     time using `load', it will be restored as a global variable.

     The command

          save -binary data a b*

     saves the variable `a' and all variables beginning with `b' to the
     file `data' in Octave's binary format.

     See also: load, default_save_options, dlmread, csvread, fread
}

#
save_header_format_string
{
`save_header_format_string' is a built-in function

 -- Built-in Function: VAL = save_header_format_string ()
 -- Built-in Function: OLD_VAL = save_header_format_string (NEW_VAL)
     Query or set the internal variable that specifies the format
     string used for the comment line written at the beginning of
     text-format data files saved by Octave.  The format string is
     passed to `strftime' and should begin with the character `#' and
     contain no newline characters.  If the value of
     `save_header_format_string' is the empty string, the header
     comment is omitted from text-format data files.  The default value
     is

          "# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     See also: strftime, save
}

#
save_precision
{
`save_precision' is a built-in function

 -- Built-in Function: VAL = save_precision ()
 -- Built-in Function: OLD_VAL = save_precision (NEW_VAL)
     Query or set the internal variable that specifies the number of
     digits to keep when saving data in text format.
}

#
saveaudio
{
`saveaudio' is a function from the file /usr/share/octave/3.2.3/m/audio/saveaudio.m

 -- Function File:  saveaudio (NAME, X, EXT, BPS)
     Saves a vector X of audio data to the file `NAME.EXT'.  The
     optional parameters EXT and BPS determine the encoding and the
     number of bits per sample used in the audio file (see
     `loadaudio');  defaults are `lin' and 8, respectively.

     See also: lin2mu, mu2lin, loadaudio, playaudio, setaudio, record
}

#
saveimage
{
`saveimage' is a function from the file /usr/share/octave/3.2.3/m/image/saveimage.m

 -- Function File:  saveimage (FILE, X, FMT, MAP)
     Save the matrix X to FILE in image format FMT.  Valid values for
     FMT are

    `"img"'
          Octave's image format.  The current colormap is also saved in
          the file.

    `"ppm"'
          Portable pixmap format.

    `"ps"'
          PostScript format.  Note that images saved in PostScript
          format cannot be read back into Octave with loadimage.

     If the fourth argument is supplied, the specified colormap will
     also be saved along with the image.

     Note: if the colormap contains only two entries and these entries
     are black and white, the bitmap ppm and PostScript formats are
     used.  If the image is a gray scale image (the entries within each
     row of the colormap are equal) the gray scale ppm and PostScript
     image formats are used, otherwise the full color formats are used.

     See also: loadimage, save, load, colormap
}

#
saveobj
{
`saveobj' is a function from the file /usr/share/octave/3.2.3/m/general/saveobj.m

 -- Function File: B = saveobj (A)
     Method of a class to manipulate an object prior to saving it to a
     file.  The function `saveobj' is called when the object A is saved
     using the `save' function.  An example of the use of `saveobj'
     might be to remove fields of the object that don't make sense to
     be saved or it might be used to ensure that certain fields of the
     object are initialized before the object is saved.  For example

          function b = saveobj (a)
            b = a;
            if (isempty (b.field))
               b.field = initfield(b);
            endif
          endfunction

     See also: loadobj, class
}

#
savepath
{
`savepath' is a function from the file /usr/share/octave/3.2.3/m/path/savepath.m

 -- Function File:  savepath (FILE)
     Save the portion of the current function search path, that is not
     set during Octave's initialization process, to FILE.  If FILE is
     omitted, `~/.octaverc' is used.  If successful, `savepath' returns
     0.

     See also: path, addpath, rmpath, genpath, pathdef, pathsep
}

#
saving_history
{
`saving_history' is a built-in function

 -- Built-in Function: VAL = saving_history ()
 -- Built-in Function: OLD_VAL = saving_history (NEW_VAL)
     Query or set the internal variable that controls whether commands
     entered on the command line are saved in the history file.

     See also: history_file, history_size,
     history_timestamp_format_string
}

#
scanf
{
`scanf' is a built-in function

 -- Built-in Function: [VAL, COUNT] = scanf (TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT]] = scanf (TEMPLATE, "C")
     This is equivalent to calling `fscanf' with FID = `stdin'.

     It is currently not useful to call `scanf' in interactive programs.

     See also: fscanf, sscanf, printf
}

#
scatter
{
`scatter' is a function from the file /usr/share/octave/3.2.3/m/plot/scatter.m

 -- Function File:  scatter (X, Y, S, C)
 -- Function File:  scatter (..., 'filled')
 -- Function File:  scatter (..., STYLE)
 -- Function File:  scatter (..., PROP, VAL)
 -- Function File:  scatter (H, ...)
 -- Function File: H = scatter (...)
     Plot a scatter plot of the data.  A marker is plotted at each point
     defined by the points in the vectors X and Y.  The size of the
     markers used is determined by the S, which can be a scalar, a
     vector of the same length of X and Y.  If S is not given or is an
     empty matrix, then the default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color, a 3 element vector giving the red, green
     and blue components of the color, a vector of the same length as X
     that gives a scaled index into the current colormap, or a N-by-3
     matrix defining the colors of each of the markers individually.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the `plot' command.
     If the argument 'filled' is given then the markers as filled.  All
     additional arguments are passed to the underlying patch command.

     The optional return value H provides a handle to the patch object

          x = randn (100, 1);
          y = randn (100, 1);
          scatter (x, y, [], sqrt(x.^2 + y.^2));

     See also: plot, patch, scatter3
}

#
scatter3
{
`scatter3' is a function from the file /usr/share/octave/3.2.3/m/plot/scatter3.m

 -- Function File:  scatter3 (X, Y, Z, S, C)
 -- Function File:  scatter3 (..., 'filled')
 -- Function File:  scatter3 (..., STYLE)
 -- Function File:  scatter3 (..., PROP, VAL)
 -- Function File:  scatter3 (H, ...)
 -- Function File: H = scatter3 (...)
     Plot a scatter plot of the data in 3D.  A marker is plotted at
     each point defined by the points in the vectors X, Y and Z.  The
     size of the markers used is determined by S, which can be a scalar
     or a vector of the same length of X, Y and Z.  If S is not given
     or is an empty matrix, then the default value of 8 points is used.

     The color of the markers is determined by C, which can be a string
     defining a fixed color, a 3 element vector giving the red, green
     and blue components of the color, a vector of the same length as X
     that gives a scaled index into the current colormap, or a N-by-3
     matrix defining the colors of each of the markers individually.

     The marker to use can be changed with the STYLE argument, that is a
     string defining a marker in the same manner as the `plot' command.
     If the argument 'filled' is given then the markers as filled.  All
     additional arguments are passed to the underlying patch command.

     The optional return value H provides a handle to the patch object

          [x, y, z] = peaks (20);
          scatter3 (x(:), y(:), z(:), [], z(:));

     See also: plot, patch, scatter
}

#
schur
{
`schur' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/schur.oct

 -- Loadable Function: S = schur (A)
 -- Loadable Function: [U, S] = schur (A, OPT)
     The Schur decomposition is used to compute eigenvalues of a square
     matrix, and has applications in the solution of algebraic Riccati
     equations in control (see `are' and `dare').  `schur' always
     returns `s = u' * a * u' where `u' is a unitary matrix (`u'* u' is
     identity) and `s' is upper triangular.  The eigenvalues of `a'
     (and `s') are the diagonal elements of `s'.  If the matrix `a' is
     real, then the real Schur decomposition is computed, in which the
     matrix `u' is orthogonal and `s' is block upper triangular with
     blocks of size at most `2 x 2' along the diagonal.  The diagonal
     elements of `s' (or the eigenvalues of the `2 x 2' blocks, when
     appropriate) are the eigenvalues of `a' and `s'.

     The eigenvalues are optionally ordered along the diagonal
     according to the value of `opt'.  `opt = "a"' indicates that all
     eigenvalues with negative real parts should be moved to the leading
     block of `s' (used in `are'), `opt = "d"' indicates that all
     eigenvalues with magnitude less than one should be moved to the
     leading block of `s' (used in `dare'), and `opt = "u"', the
     default, indicates that no ordering of eigenvalues should occur.
     The leading `k' columns of `u' always span the `a'-invariant
     subspace corresponding to the `k' leading eigenvalues of `s'.
}

#
sec
{
`sec' is a function from the file /usr/share/octave/3.2.3/m/elfun/sec.m

 -- Mapping Function:  sec (X)
     Compute the secant for each element of X in radians.

     See also: asec, secd, sech
}

#
secd
{
`secd' is a function from the file /usr/share/octave/3.2.3/m/elfun/secd.m

 -- Function File:  secd (X)
     Compute the secant for each element of X in degrees.

     See also: asecd, sec
}

#
sech
{
`sech' is a function from the file /usr/share/octave/3.2.3/m/elfun/sech.m

 -- Mapping Function:  sech (X)
     Compute the hyperbolic secant of each element of X.

     See also: asech
}

#
semicolon
{
`semicolon' is the file /usr/share/octave/3.2.3/m/miscellaneous/semicolon.m

 -- Operator: ;
     Array row or command separator.

     See also: comma
}

#
semilogx
{
`semilogx' is a function from the file /usr/share/octave/3.2.3/m/plot/semilogx.m

 -- Function File:  semilogx (ARGS)
     Produce a two-dimensional plot using a log scale for the X axis.
     See the description of `plot' for a description of the arguments
     that `semilogx' will accept.

     See also: plot, semilogy, loglog
}

#
semilogxerr
{
`semilogxerr' is a function from the file /usr/share/octave/3.2.3/m/plot/semilogxerr.m

 -- Function File:  semilogxerr (ARGS)
     Produce two-dimensional plots on a semilogarithm axis with
     errorbars.  Many different combinations of arguments are possible.
     The most used form is

          semilogxerr (X, Y, EY, FMT)

     which produces a semi-logarithm plot of Y versus X with errors in
     the Y-scale defined by EY and the plot format defined by FMT.  See
     errorbar for available formats and additional information.

     See also: errorbar, loglogerr semilogyerr
}

#
semilogy
{
`semilogy' is a function from the file /usr/share/octave/3.2.3/m/plot/semilogy.m

 -- Function File:  semilogy (ARGS)
     Produce a two-dimensional plot using a log scale for the Y axis.
     See the description of `plot' for a description of the arguments
     that `semilogy' will accept.

     See also: plot, semilogx, loglog
}

#
semilogyerr
{
`semilogyerr' is a function from the file /usr/share/octave/3.2.3/m/plot/semilogyerr.m

 -- Function File:  semilogyerr (ARGS)
     Produce two-dimensional plots on a semilogarithm axis with
     errorbars.  Many different combinations of arguments are possible.
     The most used form is

          semilogyerr (X, Y, EY, FMT)

     which produces a semi-logarithm plot of Y versus X with errors in
     the Y-scale defined by EY and the plot format defined by FMT.  See
     errorbar for available formats and additional information.

     See also: errorbar, loglogerr semilogxerr
}

#
set
{
`set' is a built-in function

 -- Built-in Function:  set (H, P, V, ...)
     Set the named property value or vector P to the value V for the
     graphics handle H.
}

#
setaudio
{
`setaudio' is a function from the file /usr/share/octave/3.2.3/m/audio/setaudio.m

 -- Function File:  setaudio ([W_TYPE [, VALUE]])
     Execute the shell command `mixer [W_TYPE [, VALUE]]'
}

#
setdiff
{
`setdiff' is a function from the file /usr/share/octave/3.2.3/m/set/setdiff.m

 -- Function File:  setdiff (A, B)
 -- Function File:  setdiff (A, B, "rows")
 -- Function File: [C, I] = setdiff (A, B)
     Return the elements in A that are not in B, sorted in ascending
     order.  If A and B are both column vectors return a column vector,
     otherwise return a row vector.

     Given the optional third argument `"rows"', return the rows in A
     that are not in B, sorted in ascending order by rows.

     If requested, return I such that `c = a(i)'.

     See also: unique, union, intersect, setxor, ismember
}

#
setenv
{
`setenv' is a built-in function

 -- Built-in Function:  putenv (VAR, VALUE)
 -- Built-in Function:  setenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.
}

#
setfield
{
`setfield' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/setfield.m

 -- Function File: [K1, ..., V1] = setfield (S, K1, V1, ...)
     Set field members in a structure.

          oo(1,1).f0 = 1;
          oo = setfield (oo, {1,2}, "fd", {3}, "b", 6);
          oo(1,2).fd(3).b == 6
          => ans = 1

     Note that this function could be written

          i1 = {1,2}; i2 = "fd"; i3 = {3}; i4 = "b";
          oo(i1{:}).(i2)(i3{:}).(i4) == 6;

     See also: getfield, rmfield, isfield, isstruct, fieldnames, struct
}

#
setgrent
{
`setgrent' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getgrent.oct

 -- Loadable Function:  setgrent ()
     Return the internal pointer to the beginning of the group database.
}

#
setpwent
{
`setpwent' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/getpwent.oct

 -- Loadable Function:  setpwent ()
     Return the internal pointer to the beginning of the password
     database.
}

#
setstr
{
`setstr' is a function from the file /usr/share/octave/3.2.3/m/deprecated/setstr.m

 -- Function File:  setstr (S)
     This function has been deprecated.  Use char instead.
}

#
setxor
{
`setxor' is a function from the file /usr/share/octave/3.2.3/m/set/setxor.m

 -- Function File:  setxor (A, B)
 -- Function File:  setxor (A, B, 'rows')
     Return the elements exclusive to A or B, sorted in ascending
     order.  If A and B are both column vectors return a column vector,
     otherwise return a row vector.

 -- Function File: [C, IA, IB] = setxor (A, B)
     Return index vectors IA and IB such that `a == c(ia)' and `b ==
     c(ib)'.

     See also: unique, union, intersect, setdiff, ismember
}

#
shading
{
`shading' is a function from the file /usr/share/octave/3.2.3/m/plot/shading.m

 -- Function File:  shading (TYPE)
 -- Function File:  shading (AX, ...)
     Set the shading of surface or patch graphic objects.  Valid
     arguments for TYPE are

    `"flat"'
          Single colored patches with invisible edges.

    `"faceted"'
          Single colored patches with visible edges.

    `"interp"'
          Color between patch vertices are interpolated and the patch
          edges are invisible.

     If AX is given the shading is applied to axis AX instead of the
     current axis.
}

#
shell_cmd
{
`shell_cmd' is a built-in function

 -- Built-in Function:  system (STRING, RETURN_OUTPUT, TYPE)
     Execute a shell command specified by STRING.  The second argument
     is optional.  If TYPE is `"async"', the process is started in the
     background and the process id of the child process is returned
     immediately.  Otherwise, the process is started, and Octave waits
     until it exits.  If the TYPE argument is omitted, a value of
     `"sync"' is assumed.

     If two input arguments are given (the actual value of
     RETURN_OUTPUT is irrelevant) and the subprocess is started
     synchronously, or if SYSTEM is called with one input argument and
     one or more output arguments, the output from the command is
     returned.  Otherwise, if the subprocess is executed synchronously,
     its output is sent to the standard output.  To send the output of
     a command executed with SYSTEM through the pager, use a command
     like

          disp (system (cmd, 1));

     or

          printf ("%s\n", system (cmd, 1));

     The `system' function can return two values.  The first is the
     exit status of the command and the second is any output from the
     command that was written to the standard output stream.  For
     example,

          [status, output] = system ("echo foo; exit 2");

     will set the variable `output' to the string `foo', and the
     variable `status' to the integer `2'.
}

#
shg
{
`shg' is a function from the file /usr/share/octave/3.2.3/m/plot/shg.m

 -- Function File:  shg
     Show the graph window.  Currently, this is the same as executing
     `drawnow'.

     See also: drawnow, figure
}

#
shift
{
`shift' is a function from the file /usr/share/octave/3.2.3/m/general/shift.m

 -- Function File:  shift (X, B)
 -- Function File:  shift (X, B, DIM)
     If X is a vector, perform a circular shift of length B of the
     elements of X.

     If X is a matrix, do the same for each column of X.  If the
     optional DIM argument is given, operate along this dimension
}

#
shiftdim
{
`shiftdim' is a function from the file /usr/share/octave/3.2.3/m/general/shiftdim.m

 -- Function File: Y = shiftdim (X, N)
 -- Function File: [Y, NS] = shiftdim (X)
     Shifts the dimension of X by N, where N must be an integer scalar.
     When N is positive, the dimensions of X are shifted to the left,
     with the leading dimensions circulated to the end.  If N is
     negative, then the dimensions of X are shifted to the right, with
     N leading singleton dimensions added.

     Called with a single argument, `shiftdim', removes the leading
     singleton dimensions, returning the number of dimensions removed
     in the second output argument NS.

     For example

          x = ones (1, 2, 3);
          size (shiftdim (x, -1))
               => [1, 1, 2, 3]
          size (shiftdim (x, 1))
               => [2, 3]
          [b, ns] = shiftdim (x);
               => b =  [1, 1, 1; 1, 1, 1]
               => ns = 1

     See also: reshape, permute, ipermute, circshift, squeeze
}

#
sighup_dumps_octave_core
{
`sighup_dumps_octave_core' is a built-in function

 -- Built-in Function: VAL = sighup_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sighup_dumps_octave_core (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file "octave-core" if
     it receives a hangup signal.
}

#
sign
{
`sign' is a built-in function

 -- Mapping Function:  sign (X)
     Compute the "signum" function, which is defined as

                    -1, x < 0;
          sign (x) =  0, x = 0;
                     1, x > 0.

     For complex arguments, `sign' returns `x ./ abs (X)'.
}

#
sign_test
{
`sign_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/sign_test.m

 -- Function File: [PVAL, B, N] = sign_test (X, Y, ALT)
     For two matched-pair samples X and Y, perform a sign test of the
     null hypothesis PROB (X > Y) == PROB (X < Y) == 1/2.  Under the
     null, the test statistic B roughly follows a binomial distribution
     with parameters `N = sum (X != Y)' and P = 1/2.

     With the optional argument `alt', the alternative of interest can
     be selected.  If ALT is `"!="' or `"<>"', the null hypothesis is
     tested against the two-sided alternative PROB (X < Y) != 1/2.  If
     ALT is `">"', the one-sided alternative PROB (X > Y) > 1/2 ("x is
     stochastically greater than y") is considered.  Similarly for
     `"<"', the one-sided alternative PROB (X > Y) < 1/2 ("x is
     stochastically less than y") is considered.  The default is the
     two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
sigterm_dumps_octave_core
{
`sigterm_dumps_octave_core' is a built-in function

 -- Built-in Function: VAL = sigterm_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sigterm_dumps_octave_core (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file "octave-core" if
     it receives a terminate signal.
}

#
silent_functions
{
`silent_functions' is a built-in function

 -- Built-in Function: VAL = silent_functions ()
 -- Built-in Function: OLD_VAL = silent_functions (NEW_VAL)
     Query or set the internal variable that controls whether internal
     output from a function is suppressed.  If this option is disabled,
     Octave will display the results produced by evaluating expressions
     within a function body that are not terminated with a semicolon.
}

#
sin
{
`sin' is a built-in function

 -- Mapping Function:  sin (X)
     Compute the sine for each element of X in radians.

     See also: asin, sind, sinh
}

#
sinc
{
`sinc' is a function from the file /usr/share/octave/3.2.3/m/signal/sinc.m

 -- Function File:  sinc (X)
     Return  sin(pi*x)/(pi*x).
}

#
sind
{
`sind' is a function from the file /usr/share/octave/3.2.3/m/elfun/sind.m

 -- Function File:  sind (X)
     Compute the sine for each element of X in degrees.  Returns zero
     for elements where `X/180' is an integer.

     See also: asind, sin
}

#
sinetone
{
`sinetone' is a function from the file /usr/share/octave/3.2.3/m/signal/sinetone.m

 -- Function File:  sinetone (FREQ, RATE, SEC, AMPL)
     Return a sinetone of frequency FREQ with length of SEC seconds at
     sampling rate RATE and with amplitude AMPL.  The arguments FREQ
     and AMPL may be vectors of common size.

     Defaults are RATE = 8000, SEC = 1 and AMPL = 64.
}

#
sinewave
{
`sinewave' is a function from the file /usr/share/octave/3.2.3/m/signal/sinewave.m

 -- Function File:  sinewave (M, N, D)
     Return an M-element vector with I-th element given by `sin (2 * pi
     * (I+D-1) / N)'.

     The default value for D is 0 and the default value for N is M.
}

#
single
{
`single' is a built-in function

 -- Built-in Function:  single (X)
     Convert X to single precision type.

     See also: double
}

#
sinh
{
`sinh' is a built-in function

 -- Mapping Function:  sinh (X)
     Compute the hyperbolic sine for each element of X.

     See also: asinh, cosh, tanh
}

#
size
{
`size' is a built-in function

 -- Built-in Function:  size (A, N)
     Return the number rows and columns of A.

     With one input argument and one output argument, the result is
     returned in a row vector.  If there are multiple output arguments,
     the number of rows is assigned to the first, and the number of
     columns to the second, etc.  For example,

          size ([1, 2; 3, 4; 5, 6])
              => [ 3, 2 ]

          [nr, nc] = size ([1, 2; 3, 4; 5, 6])
              => nr = 3
              => nc = 2

     If given a second argument, `size' will return the size of the
     corresponding dimension.  For example

          size ([1, 2; 3, 4; 5, 6], 2)
              => 2

     returns the number of columns in the given matrix.

     See also: numel
}

#
size_equal
{
`size_equal' is a built-in function

 -- Built-in Function:  size_equal (A, B, ...)
     Return true if the dimensions of all arguments agree.  Trailing
     singleton dimensions are ignored.  Called with a single argument,
     size_equal returns true.

     See also: size, numel
}

#
sizeof
{
`sizeof' is a built-in function

 -- Built-in Function:  sizeof (VAL)
     Return the size of VAL in bytes
}

#
skewness
{
`skewness' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/skewness.m

 -- Function File:  skewness (X, DIM)
     If X is a vector of length n, return the skewness

          skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)

     of X.  If X is a matrix, return the skewness along the first
     non-singleton dimension of the matrix.  If the optional DIM
     argument is given, operate along this dimension.
}

#
sleep
{
`sleep' is a built-in function

 -- Built-in Function:  sleep (SECONDS)
     Suspend the execution of the program for the given number of
     seconds.
}

#
slice
{
`slice' is a function from the file /usr/share/octave/3.2.3/m/plot/slice.m

 -- Function File:  slice (X, Y, Z, V, SX, SY, SZ)
 -- Function File:  slice (X, Y, Z, V, XI, YI, ZI)
 -- Function File:  slice (V, SX, SY, SZ)
 -- Function File:  slice (V, XI, YI, ZI)
 -- Function File: H = slice (...)
 -- Function File: H = slice (..., METHOD)
     Plot slices of 3D data/scalar fields.  Each element of the
     3-dimensional array V represents a scalar value at a location
     given by the parameters X, Y, and Z.  The parameters X, X, and Z
     are either 3-dimensional arrays of the same size as the array V in
     the "meshgrid" format or vectors.  The parameters XI, etc. respect
     a similar format to X, etc., and they represent the points at
     which the array VI is interpolated using interp3.  The vectors SX,
     SY, and SZ contain points of orthogonal slices of the respective
     axes.

     If X, Y, Z are omitted, they are assumed to be `x = 1:size (V,
     2)', `y = 1:size (V, 1)' and `z = 1:size (V, 3)'.

     METHOD is one of:

    `"nearest"'
          Return the nearest neighbor.

    `"linear"'
          Linear interpolation from nearest neighbors.

    `"cubic"'
          Cubic interpolation from four nearest neighbors (not
          implemented yet).

    `"spline"'
          Cubic spline interpolation--smooth first and second
          derivatives throughout the curve.

     The default method is `"linear"'.  The optional return value H is
     a vector of handles to the surface graphic objects.

     Examples:
          [x, y, z] = meshgrid (linspace (-8, 8, 32));
          v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
          slice (x, y, z, v, [], 0, []);
          [xi, yi] = meshgrid (linspace (-7, 7));
          zi = xi + yi;
          slice (x, y, z, v, xi, yi, zi);

     See also: interp3, surface, pcolor
}

#
sombrero
{
`sombrero' is a function from the file /usr/share/octave/3.2.3/m/plot/sombrero.m

 -- Function File:  sombrero (N)
     Produce the familiar three-dimensional sombrero plot using N grid
     lines.  If N is omitted, a value of 41 is assumed.

     The function plotted is

          z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))

     See also: surf, meshgrid, mesh
}

#
sort
{
`sort' is a built-in function

 -- Loadable Function: [S, I] = sort (X)
 -- Loadable Function: [S, I] = sort (X, DIM)
 -- Loadable Function: [S, I] = sort (X, MODE)
 -- Loadable Function: [S, I] = sort (X, DIM, MODE)
     Return a copy of X with the elements arranged in increasing order.
     For matrices, `sort' orders the elements in each column.

     For example,

          sort ([1, 2; 2, 3; 3, 1])
              =>  1  1
                  2  2
                  3  3

     The `sort' function may also be used to produce a matrix
     containing the original row indices of the elements in the sorted
     matrix.  For example,

          [s, i] = sort ([1, 2; 2, 3; 3, 1])
              => s = 1  1
                     2  2
                     3  3
              => i = 1  3
                     2  1
                     3  2

     If the optional argument DIM is given, then the matrix is sorted
     along the dimension defined by DIM.  The optional argument `mode'
     defines the order in which the values will be sorted.  Valid
     values of `mode' are `ascend' or `descend'.

     For equal elements, the indices are such that the equal elements
     are listed in the order that appeared in the original list.

     The `sort' function may also be used to sort strings and cell
     arrays of strings, in which case the dictionary order of the
     strings is used.

     The algorithm used in `sort' is optimized for the sorting of
     partially ordered lists.
}

#
sortrows
{
`sortrows' is a function from the file /usr/share/octave/3.2.3/m/general/sortrows.m

 -- Function File:  sortrows (A, C)
     Sort the rows of the matrix A according to the order of the
     columns specified in C.  If C is omitted, a lexicographical sort
     is used.  By default ascending order is used however if elements
     of C are negative then the corresponding column is sorted in
     descending order.
}

#
source
{
`source' is a built-in function

 -- Built-in Function:  source (FILE)
     Parse and execute the contents of FILE.  This is equivalent to
     executing commands from a script file, but without requiring the
     file to be named `FILE.m'.
}

#
spalloc
{
`spalloc' is a function from the file /usr/share/octave/3.2.3/m/sparse/spalloc.m

 -- Function File: S = spalloc (R, C, NZ)
     Returns an empty sparse matrix of size R-by-C.  As Octave resizes
     sparse matrices at the first opportunity, so that no additional
     space is needed, the argument NZ is ignored.  This function is
     provided only for compatibility reasons.

     It should be noted that this means that code like

          k = 5;
          nz = r * k;
          s = spalloc (r, c, nz)
          for j = 1:c
            idx = randperm (r);
            s (:, j) = [zeros(r - k, 1); rand(k, 1)] (idx);
          endfor

     will reallocate memory at each step.  It is therefore vitally
     important that code like this is vectorized as much as possible.

     See also: sparse, nzmax
}

#
sparse
{
`sparse' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/sparse.oct

 -- Loadable Function: S = sparse (A)
 -- Loadable Function: S = sparse (I, J, SV, M, N, NZMAX)
 -- Loadable Function: S = sparse (I, J, SV)
 -- Loadable Function: S = sparse (I, J, S, M, N, "unique")
 -- Loadable Function: S = sparse (M, N)
     Create a sparse matrix from the full matrix or row, column, value
     triplets.  If A is a full matrix, convert it to a sparse matrix
     representation, removing all zero values in the process.

     Given the integer index vectors I and J, a 1-by-`nnz' vector of
     real of complex values SV, overall dimensions M and N of the
     sparse matrix.  The argument `nzmax' is ignored but accepted for
     compatibility with MATLAB.  If M or N are not specified their
     values are derived from the maximum index in the vectors I and J
     as given by `M = max (I)', `N = max (J)'.

     *Note*: if multiple values are specified with the same I, J
     indices, the corresponding values in S will be added.

     The following are all equivalent:

          s = sparse (i, j, s, m, n)
          s = sparse (i, j, s, m, n, "summation")
          s = sparse (i, j, s, m, n, "sum")

     Given the option "unique". if more than two values are specified
     for the same I, J indices, the last specified value will be used.

     `sparse(M, N)' is equivalent to `sparse ([], [], [], M, N, 0)'

     If any of SV, I or J are scalars, they are expanded to have a
     common size.

     See also: full
}

#
sparse_auto_mutate
{
`sparse_auto_mutate' is a built-in function

 -- Built-in Function: VAL = sparse_auto_mutate ()
 -- Built-in Function: OLD_VAL = sparse_auto_mutate (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will automatically mutate sparse matrices to real matrices to save
     memory.  For example,

          s = speye(3);
          sparse_auto_mutate (false)
          s (:, 1) = 1;
          typeinfo (s)
          => sparse matrix
          sparse_auto_mutate (true)
          s (1, :) = 1;
          typeinfo (s)
          => matrix
}

#
spatan2
{
`spatan2' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spatan2.m

 -- Function File:  spatan2 (Y, X)
     This function has been deprecated.  Use `atan2' instead.
}

#
spaugment
{
`spaugment' is a function from the file /usr/share/octave/3.2.3/m/sparse/spaugment.m

 -- Function File: S = spaugment (A, C)
     Creates the augmented matrix of A.  This is given by

          [C * eye(M, M),A; A', zeros(N,
          N)]

     This is related to the least squares solution of `A \\ B', by

          S * [ R / C; x] = [B, zeros(N,
          columns(B)]

     where R is the residual error

          R = B - A * X

     As the matrix S is symmetric indefinite it can be factorized with
     `lu', and the minimum norm solution can therefore be found without
     the need for a `qr' factorization.  As the residual error will be
     `zeros (M, M)' for under determined problems, and example can be

          m = 11; n = 10; mn = max(m ,n);
          a = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
                       [-1, 0, 1], m, n);
          x0 = a \ ones (m,1);
          s = spaugment (a);
          [L, U, P, Q] = lu (s);
          x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
          x1 = x1(end - n + 1 : end);

     To find the solution of an overdetermined problem needs an estimate
     of the residual error R and so it is more complex to formulate a
     minimum norm solution using the `spaugment' function.

     In general the left division operator is more stable and faster
     than using the `spaugment' function.
}

#
spchol
{
`spchol' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spchol.m

 -- Loadable Function: R = spchol (A)
 -- Loadable Function: [R, P] = spchol (A)
 -- Loadable Function: [R, P, Q] = spchol (A)
     This function has been deprecated.  Use `chol' instead.
}

#
spchol2inv
{
`spchol2inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spchol2inv.m

 -- Function File:  spchol2inv (U)
     This function has been deprecated.  Use `chol2inv' instead.
}

#
spcholinv
{
`spcholinv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spcholinv.m

 -- Function File:  spcholinv (U)
     This function has been deprecated.  Use `cholinv' instead.
}

#
spconvert
{
`spconvert' is a function from the file /usr/share/octave/3.2.3/m/sparse/spconvert.m

 -- Function File: X = spconvert (M)
     This function converts for a simple sparse matrix format easily
     produced by other programs into Octave's internal sparse format.
     The input X is either a 3 or 4 column real matrix, containing the
     row, column, real and imaginary parts of the elements of the
     sparse matrix.  An element with a zero real and imaginary part can
     be used to force a particular matrix size.
}

#
spcumprod
{
`spcumprod' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spcumprod.m

 -- Function File:  spcumprod (X, DIM)
     This function has been deprecated.  Use `cumprod' instead.
}

#
spcumsum
{
`spcumsum' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spcumsum.m

 -- Function File:  spcumsum (X, DIM)
     This function has been deprecated.  Use `cumsum' instead.
}

#
spdet
{
`spdet' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spdet.m

 -- Loadable Function: [D, RCOND] = spdet (A)
     This function has been deprecated.  Use `det' instead.
}

#
spdiag
{
`spdiag' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spdiag.m

 -- Function File:  spdiag (V, K)
     This function has been deprecated.  Use `sparse (diag (...))'
     instead.
}

#
spdiags
{
`spdiags' is a function from the file /usr/share/octave/3.2.3/m/sparse/spdiags.m

 -- Function File: [B, C] = spdiags (A)
 -- Function File: B = spdiags (A, C)
 -- Function File: B = spdiags (V, C, A)
 -- Function File: B = spdiags (V, C, M, N)
     A generalization of the function `diag'.  Called with a single
     input argument, the non-zero diagonals C of A are extracted.  With
     two arguments the diagonals to extract are given by the vector C.

     The other two forms of `spdiags' modify the input matrix by
     replacing the diagonals.  They use the columns of V to replace the
     columns represented by the vector C.  If the sparse matrix A is
     defined then the diagonals of this matrix are replaced.  Otherwise
     a matrix of M by N is created with the diagonals given by V.

     Negative values of C represent diagonals below the main diagonal,
     and positive values of C diagonals above the main diagonal.

     For example

          spdiags (reshape (1:12, 4, 3), [-1 0 1], 5, 4)
          =>    5 10  0  0
                1  6 11  0
                0  2  7 12
                0  0  3  8
                0  0  0  4
}

#
spearman
{
`spearman' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/spearman.m

 -- Function File:  spearman (X, Y)
     Compute Spearman's rank correlation coefficient RHO for each of
     the variables specified by the input arguments.

     For matrices, each row is an observation and each column a
     variable; vectors are always observations and may be row or column
     vectors.

     `spearman (X)' is equivalent to `spearman (X, X)'.

     For two data vectors X and Y, Spearman's RHO is the correlation of
     the ranks of X and Y.

     If X and Y are drawn from independent distributions, RHO has zero
     mean and variance `1 / (n - 1)', and is asymptotically normally
     distributed.
}

#
spectral_adf
{
`spectral_adf' is a function from the file /usr/share/octave/3.2.3/m/signal/spectral_adf.m

 -- Function File:  spectral_adf (C, WIN, B)
     Return the spectral density estimator given a vector of
     autocovariances C, window name WIN, and bandwidth, B.

     The window name, e.g., `"triangle"' or `"rectangle"' is used to
     search for a function called `WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     `1 / sqrt (length (X))' is used.
}

#
spectral_xdf
{
`spectral_xdf' is a function from the file /usr/share/octave/3.2.3/m/signal/spectral_xdf.m

 -- Function File:  spectral_xdf (X, WIN, B)
     Return the spectral density estimator given a data vector X,
     window name WIN, and bandwidth, B.

     The window name, e.g., `"triangle"' or `"rectangle"' is used to
     search for a function called `WIN_sw'.

     If WIN is omitted, the triangle window is used.  If B is omitted,
     `1 / sqrt (length (X))' is used.
}

#
specular
{
`specular' is a function from the file /usr/share/octave/3.2.3/m/plot/specular.m

 -- Function File:  specular (SX, SY, SZ, L, V)
 -- Function File:  specular (SX, SY, SZ, L, V, SE)
     Calculate specular reflection strength of a surface defined by the
     normal vector elements SX, SY, SZ using Phong's approximation.
     The light and view vectors can be specified using parameter L and
     V respectively.  Both can be given as 2-element vectors [azimuth,
     elevation] in degrees or as 3-element vector [x, y, z].  An
     optional 6th argument describes the specular exponent (spread) SE.

     See also: surfl, diffuse
}

#
speed
{
`speed' is a function from the file /usr/share/octave/3.2.3/m/testfun/speed.m

 -- Function File:  speed (F, INIT, MAX_N, F2, TOL)
 -- Function File: [ORDER, N, T_F, T_F2] = speed (...)
     Determine the execution time of an expression for various N.  The
     N are log-spaced from 1 to MAX_N.  For each N, an initialization
     expression is computed to create whatever data are needed for the
     test.  If a second expression is given, the execution times of the
     two expressions will be compared.  Called without output arguments
     the results are presented graphically.

    `F'
          The expression to evaluate.

    `MAX_N'
          The maximum test length to run.  Default value is 100.
          Alternatively, use `[min_n,max_n]' or for complete control,
          `[n1,n2,...,nk]'.

    `INIT'
          Initialization expression for function argument values.  Use K
          for the test number and N for the size of the test.  This
          should compute values for all variables listed in args.  Note
          that init will be evaluated first for k = 0, so things which
          are constant throughout the test can be computed then.  The
          default value is `X = randn (N, 1);'.

    `F2'
          An alternative expression to evaluate, so the speed of the two
          can be compared.  Default is `[]'.

    `TOL'
          If TOL is `Inf', then no comparison will be made between the
          results of expression F and expression F2.  Otherwise,
          expression F should produce a value V and expression F2
          should produce a value V2, and these shall be compared using
          `assert(V,V2,TOL)'.  If TOL is positive, the tolerance is
          assumed to be absolute.  If TOL is negative, the tolerance is
          assumed to be relative.  The default is `eps'.

    `ORDER'
          The time complexity of the expression `O(a n^p)'.  This is a
          structure with fields `a' and `p'.

    `N'
          The values N for which the expression was calculated and the
          execution time was greater than zero.

    `T_F'
          The nonzero execution times recorded for the expression F in
          seconds.

    `T_F2'
          The nonzero execution times recorded for the expression F2 in
          seconds.  If it is needed, the mean time ratio is just
          `mean(T_f./T_f2)'.


     The slope of the execution time graph shows the approximate power
     of the asymptotic running time `O(n^p)'.  This power is plotted
     for the region over which it is approximated (the latter half of
     the graph).  The estimated power is not very accurate, but should
     be sufficient to determine the general order of your algorithm.
     It should indicate if for example your implementation is
     unexpectedly `O(n^2)' rather than `O(n)' because it extends a
     vector each time through the loop rather than preallocating one
     which is big enough.  For example, in the current version of
     Octave, the following is not the expected `O(n)':

          speed ("for i = 1:n, y{i} = x(i); end", "", [1000,10000])

     but it is if you preallocate the cell array `y':

          speed ("for i = 1:n, y{i} = x(i); end", ...
                 "x = rand (n, 1); y = cell (size (x));", [1000, 10000])

     An attempt is made to approximate the cost of the individual
     operations, but it is wildly inaccurate.  You can improve the
     stability somewhat by doing more work for each `n'.  For example:

          speed ("airy(x)", "x = rand (n, 10)", [10000, 100000])

     When comparing a new and original expression, the line on the
     speedup ratio graph should be larger than 1 if the new expression
     is faster.  Better algorithms have a shallow slope.  Generally,
     vectorizing an algorithm will not change the slope of the execution
     time graph, but it will shift it relative to the original.  For
     example:

          speed ("v = sum (x)", "", [10000, 100000], ...
                 "v = 0; for i = 1:length (x), v += x(i); end")

     A more complex example, if you had an original version of `xcorr'
     using for loops and another version using an FFT, you could
     compare the run speed for various lags as follows, or for a fixed
     lag with varying vector lengths as follows:

          speed ("v = xcorr (x, n)", "x = rand (128, 1);", 100,
                 "v2 = xcorr_orig (x, n)", -100*eps)
          speed ("v = xcorr (x, 15)", "x = rand (20+n, 1);", 100,
                 "v2 = xcorr_orig (x, n)", -100*eps)

     Assuming one of the two versions is in XCORR_ORIG, this would
     compare their speed and their output values.  Note that the FFT
     version is not exact, so we specify an acceptable tolerance on the
     comparison `100*eps', and the errors should be computed
     relatively, as `abs((X - Y)./Y)' rather than absolutely as `abs(X
     - Y)'.

     Type `example('speed')' to see some real examples.  Note for
     obscure reasons, you can't run examples 1 and 2 directly using
     `demo('speed')'.  Instead use, `eval(example('speed',1))' and
     `eval(example('speed',2))'.
}

#
spencer
{
`spencer' is a function from the file /usr/share/octave/3.2.3/m/signal/spencer.m

 -- Function File:  spencer (X)
     Return Spencer's 15 point moving average of every single column of
     X.
}

#
speye
{
`speye' is a function from the file /usr/share/octave/3.2.3/m/sparse/speye.m

 -- Function File: Y = speye (M)
 -- Function File: Y = speye (M, N)
 -- Function File: Y = speye (SZ)
     Returns a sparse identity matrix.  This is significantly more
     efficient than `sparse (eye (M))' as the full matrix is not
     constructed.

     Called with a single argument a square matrix of size M by M is
     created.  Otherwise a matrix of M by N is created.  If called with
     a single vector argument, this argument is taken to be the size of
     the matrix to create.
}

#
spfind
{
`spfind' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spfind.m

 -- Loadable Function:  spfind (X)
 -- Loadable Function:  spfind (X, N)
 -- Loadable Function:  spfind (X, N, DIRECTION)
 -- Loadable Function: [I, J, V spfind (...)
     This function has been deprecated.  Use `find' instead.
}

#
spfun
{
`spfun' is a function from the file /usr/share/octave/3.2.3/m/sparse/spfun.m

 -- Function File: Y = spfun (F,X)
     Compute `f(X)' for the non-zero values of X.  This results in a
     sparse matrix with the same structure as X.  The function F can be
     passed as a string, a function handle or an inline function.
}

#
sph2cart
{
`sph2cart' is a function from the file /usr/share/octave/3.2.3/m/general/sph2cart.m

 -- Function File: [X, Y, Z] = sph2cart (THETA, PHI, R)
     Transform spherical to Cartesian coordinates.  X, Y and Z must be
     the same shape, or scalar.  THETA describes the angle relative to
     the positive x-axis.  PHI is the angle relative to the xy-plane.
     R is the distance to the origin (0, 0, 0).

     See also: pol2cart, cart2pol, cart2sph
}

#
sphcat
{
`sphcat' is a function from the file /usr/share/octave/3.2.3/m/sparse/sphcat.m

 -- Function File: Y = sphcat (A1, A2, ..., AN)
     Return the horizontal concatenation of sparse matrices.  This
     function is obselete and `horzcat' should be used.

     See also: spvcat, vertcat, horzcat, cat
}

#
sphere
{
`sphere' is a function from the file /usr/share/octave/3.2.3/m/plot/sphere.m

 -- Function File: [X, Y, Z] = sphere (N)
 -- Function File:  sphere (H, ...)
     Generates three matrices in `meshgrid' format, such that `surf (X,
     Y, Z)' generates a unit sphere.  The matrices of `N+1'-by-`N+1'.
     If N is omitted then a default value of 20 is assumed.

     Called with no return arguments, `sphere' call directly `surf (X,
     Y, Z)'.  If an axes handle is passed as the first argument, the
     surface is plotted to this set of axes.

     See also: peaks
}

#
spinmap
{
`spinmap' is a function from the file /usr/share/octave/3.2.3/m/plot/spinmap.m

 -- Function File:  spinmap (T, INC)
     Cycle the colormap for T seconds with an increment of INC.  Both
     parameters are optional.  The default cycle time is 5 seconds and
     the default increment is 2.

     A higher value of INC causes a faster cycle through the colormap.

     See also: gca, colorbar
}

#
spinv
{
`spinv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spinv.m

 -- Function File: [X, RCOND] = spinv (A)
     This function has been deprecated.  Use `inv' instead.
}

#
spkron
{
`spkron' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spkron.m

 -- Function File:  spkron (A, B)
     This function has been deprecated.  Use `kron' instead.
}

#
splchol
{
`splchol' is a function from the file /usr/share/octave/3.2.3/m/deprecated/splchol.m

 -- Loadable Function: L = splchol (A)
 -- Loadable Function: [L, P] = splchol (A)
 -- Loadable Function: [L, P, Q] = splchol (A)
     This function has been deprecated.  Use `chol (...,'lower')'
     instead.
}

#
splice
{
`splice' is a built-in function

 -- Built-in Function:  splice (LIST_1, OFFSET, LENGTH, LIST_2)
     Replace LENGTH elements of LIST_1 beginning at OFFSET with the
     contents of LIST_2 (if any).  If LENGTH is omitted, all elements
     from OFFSET to the end of LIST_1 are replaced.  As a special case,
     if OFFSET is one greater than the length of LIST_1 and LENGTH is
     0, splice is equivalent to `append (LIST_1, LIST_2)'.
}

#
spline
{
`spline' is a function from the file /usr/share/octave/3.2.3/m/polynomial/spline.m

 -- Function File: PP = spline (X, Y)
 -- Function File: YI = spline (X, Y, XI)
     Return the cubic spline interpolant of Y at points X.  If called
     with two arguments, `spline' returns the piece-wise polynomial PP
     that may later be used with `ppval' to evaluate the polynomial at
     specific points.  If called with a third input argument, `spline'
     evaluates the spline at the points XI.  There is an equivalence
     between `ppval (spline (X, Y), XI)' and `spline (X, Y, XI)'.

     The variable X must be a vector of length N, and Y can be either a
     vector or array.  In the case where Y is a vector, it can have a
     length of either N or `N + 2'.  If the length of Y is N, then the
     'not-a-knot' end condition is used.  If the length of Y is `N + 2',
     then the first and last values of the vector Y are the values of
     the first derivative of the cubic spline at the end-points.

     If Y is an array, then the size of Y must have the form `[S1, S2,
     ..., SK, N]' or `[S1, S2, ..., SK, N + 2]'.  The array is then
     reshaped internally to a matrix where the leading dimension is
     given by `S1 * S2 * ... * SK' and each row of this matrix is then
     treated separately.  Note that this is exactly the opposite
     treatment than `interp1' and is done for compatibility.

     See also: ppval, mkpp, unmkpp
}

#
split
{
`split' is a function from the file /usr/share/octave/3.2.3/m/deprecated/split.m

 -- Function File:  split (S, T, N)
     This function has been deprecated.  Use `char (strsplit (s, t))'
     instead.
}

#
split_long_rows
{
`split_long_rows' is a built-in function

 -- Built-in Function: VAL = split_long_rows ()
 -- Built-in Function: OLD_VAL = split_long_rows (NEW_VAL)
     Query or set the internal variable that controls whether rows of a
     matrix may be split when displayed to a terminal window.  If the
     rows are split, Octave will display the matrix in a series of
     smaller pieces, each of which can fit within the limits of your
     terminal width and each set of rows is labeled so that you can
     easily see which columns are currently being displayed.  For
     example:

          octave:13> rand (2,10)
          ans =

          Columns 1 through 6:

           0.75883  0.93290  0.40064  0.43818  0.94958  0.16467
           0.75697  0.51942  0.40031  0.61784  0.92309  0.40201

          Columns 7 through 10:

           0.90174  0.11854  0.72313  0.73326
           0.44672  0.94303  0.56564  0.82150
}

#
splu
{
`splu' is a function from the file /usr/share/octave/3.2.3/m/deprecated/splu.m

 -- Loadable Function: [L, U] = splu (A)
 -- Loadable Function: [L, U, P] = splu (A)
 -- Loadable Function: [L, U, P, Q] = splu (A)
 -- Loadable Function: [L, U, P, Q] = splu (..., THRES)
 -- Loadable Function: [L, U, P] = splu (..., Q)
     This function has been deprecated.  Use `lu' instead.
}

#
spmax
{
`spmax' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spmax.m

 -- Mapping Function:  spmax (X, Y, DIM)
 -- Mapping Function: [W, IW] = spmax (X)
     This function has been deprecated.  Use `max' instead.
}

#
spmin
{
`spmin' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spmin.m

 -- Mapping Function:  spmin (X, Y, DIM)
 -- Mapping Function: [W, IW] = spmin (X)
     This function has been deprecated.  Use `min' instead.
}

#
spones
{
`spones' is a function from the file /usr/share/octave/3.2.3/m/sparse/spones.m

 -- Function File: Y = spones (X)
     Replace the non-zero entries of X with ones.  This creates a
     sparse matrix with the same structure as X.
}

#
spparms
{
`spparms' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/spparms.oct

 -- Loadable Function:   spparms ()
 -- Loadable Function: VALS = spparms ()
 -- Loadable Function: [KEYS, VALS] = spparms ()
 -- Loadable Function: VAL = spparms (KEY)
 -- Loadable Function:   spparms (VALS)
 -- Loadable Function:   spparms ('defaults')
 -- Loadable Function:   spparms ('tight')
 -- Loadable Function:   spparms (KEY, VAL)
     Sets or displays the parameters used by the sparse solvers and
     factorization functions.  The first four calls above get
     information about the current settings, while the others change
     the current settings.  The parameters are stored as pairs of keys
     and values, where the values are all floats and the keys are one
     of the following strings:

    `spumoni'
          Printing level of debugging information of the solvers
          (default 0)

    `ths_rel'
          Included for compatibility.  Not used.  (default 1)

    `ths_abs'
          Included for compatibility.  Not used.  (default 1)

    `exact_d'
          Included for compatibility.  Not used.  (default 0)

    `supernd'
          Included for compatibility.  Not used.  (default 3)

    `rreduce'
          Included for compatibility.  Not used.  (default 3)

    `wh_frac'
          Included for compatibility.  Not used.  (default 0.5)

    `autommd'
          Flag whether the LU/QR and the '\' and '/' operators will
          automatically use the sparsity preserving mmd functions
          (default 1)

    `autoamd'
          Flag whether the LU and the '\' and '/' operators will
          automatically use the sparsity preserving amd functions
          (default 1)

    `piv_tol'
          The pivot tolerance of the UMFPACK solvers (default 0.1)

    `sym_tol'
          The pivot tolerance of the UMFPACK symmetric solvers (default
          0.001)

    `bandden'
          The density of non-zero elements in a banded matrix before it
          is treated by the LAPACK banded solvers (default 0.5)

    `umfpack'
          Flag whether the UMFPACK or mmd solvers are used for the LU,
          '\' and '/' operations (default 1)

     The value of individual keys can be set with `spparms (KEY, VAL)'.
     The default values can be restored with the special keyword
     'defaults'.  The special keyword 'tight' can be used to set the
     mmd solvers to attempt for a sparser solution at the potential
     cost of longer running time.
}

#
spprod
{
`spprod' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spprod.m

 -- Function File:  spprod (X, DIM)
     This function has been deprecated.  Use `prod' instead.
}

#
spqr
{
`spqr' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spqr.m

 -- Loadable Function: R = spqr (A)
 -- Loadable Function: R = spqr (A,0)
 -- Loadable Function: [C, R] = spqr (A,B)
 -- Loadable Function: [C, R] = spqr (A,B,0)
     This function has been deprecated.  Use `qr' instead.
}

#
sprand
{
`sprand' is a function from the file /usr/share/octave/3.2.3/m/sparse/sprand.m

 -- Function File:  sprand (M, N, D)
 -- Function File:  sprand (S)
     Generate a random sparse matrix.  The size of the matrix will be M
     by N, with a density of values given by D.  D should be between 0
     and 1. Values will be uniformly distributed between 0 and 1.

     Note: sometimes the actual density may be a bit smaller than D.
     This is unlikely to happen for large really sparse matrices.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero.

     See also: sprandn
}

#
sprandn
{
`sprandn' is a function from the file /usr/share/octave/3.2.3/m/sparse/sprandn.m

 -- Function File:  sprandn (M, N, D)
 -- Function File:  sprandn (S)
     Generate a random sparse matrix.  The size of the matrix will be M
     by N, with a density of values given by D.  D should be between 0
     and 1. Values will be normally distributed with mean of zero and
     variance 1.

     Note: sometimes the actual density may be a bit smaller than D.
     This is unlikely to happen for large really sparse matrices.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero.

     See also: sprand
}

#
sprandsym
{
`sprandsym' is a function from the file /usr/share/octave/3.2.3/m/sparse/sprandsym.m

 -- Function File:  sprandsym (N, D)
 -- Function File:  sprandsym (S)
     Generate a symmetric random sparse matrix.  The size of the matrix
     will be N by N, with a density of values given by D.  D should be
     between 0 and 1. Values will be normally distributed with mean of
     zero and variance 1.

     Note: sometimes the actual density may be a bit smaller than D.
     This is unlikely to happen for large really sparse matrices.

     If called with a single matrix argument, a random sparse matrix is
     generated wherever the matrix S is non-zero in its lower
     triangular part.

     See also: sprand, sprandn
}

#
sprank
{
`sprank' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/dmperm.oct

 -- Loadable Function: P = sprank (S)
     Calculates the structural rank of a sparse matrix S.  Note that
     only the structure of the matrix is used in this calculation based
     on a Dulmage-Mendelsohn permutation to block triangular form.  As
     such the numerical rank of the matrix S is bounded by `sprank (S)
     >= rank (S)'.  Ignoring floating point errors `sprank (S) == rank
     (S)'.

     See also: dmperm
}

#
spring
{
`spring' is a function from the file /usr/share/octave/3.2.3/m/image/spring.m

 -- Function File:  spring (N)
     Create color colormap.  This colormap is magenta to yellow.  The
     argument N should be a scalar.  If it is omitted, the length of
     the current colormap or 64 is assumed.

     See also: colormap
}

#
sprintf
{
`sprintf' is a built-in function

 -- Built-in Function:  sprintf (TEMPLATE, ...)
     This is like `printf', except that the output is returned as a
     string.  Unlike the C library function, which requires you to
     provide a suitably sized string as an argument, Octave's `sprintf'
     function returns the string, automatically sized to hold all of
     the items converted.

     See also: printf, fprintf, sscanf
}

#
spstats
{
`spstats' is a function from the file /usr/share/octave/3.2.3/m/sparse/spstats.m

 -- Function File: [COUNT, MEAN, VAR] = spstats (S)
 -- Function File: [COUNT, MEAN, VAR] = spstats (S, J)
     Return the stats for the non-zero elements of the sparse matrix S.
     COUNT is the number of non-zeros in each column, MEAN is the mean
     of the non-zeros in each column, and VAR is the variance of the
     non-zeros in each column.

     Called with two input arguments, if S is the data and J is the bin
     number for the data, compute the stats for each bin.  In this
     case, bins can contain data values of zero, whereas with `spstats
     (S)' the zeros may disappear.
}

#
spsum
{
`spsum' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spsum.m

 -- Function File:  spsum (X, DIM)
     This function has been deprecated.  Use `sum' instead.
}

#
spsumsq
{
`spsumsq' is a function from the file /usr/share/octave/3.2.3/m/deprecated/spsumsq.m

 -- Function File:  spsumsq (X, DIM)
     This function has been deprecated.  Use `sumsq' instead.
}

#
spvcat
{
`spvcat' is a function from the file /usr/share/octave/3.2.3/m/sparse/spvcat.m

 -- Function File: Y = spvcat (A1, A2, ..., AN)
     Return the vertical concatenation of sparse matrices.  This
     function is obselete and `vertcat' should be used

     See also: sphcat, vertcat, horzcat, cat
}

#
spy
{
`spy' is a function from the file /usr/share/octave/3.2.3/m/sparse/spy.m

 -- Function File:  spy (X)
 -- Function File:  spy (..., MARKERSIZE)
 -- Function File:  spy (..., LINE_SPEC)
     Plot the sparsity pattern of the sparse matrix X.  If the argument
     MARKERSIZE is given as an scalar value, it is used to determine the
     point size in the plot.  If the string LINE_SPEC is given it is
     passed to `plot' and determines the appearance of the plot.

     See also: plot
}

#
sqp
{
`sqp' is a function from the file /usr/share/octave/3.2.3/m/optimization/sqp.m

 -- Function File: [X, OBJ, INFO, ITER, NF, LAMBDA] = sqp (X, PHI, G,
          H, LB, UB, MAXITER, TOLERANCE)
     Solve the nonlinear program

               min phi (x)
                x

     subject to

               g(x)  = 0
               h(x) >= 0
               lb <= x <= ub

     using a successive quadratic programming method.

     The first argument is the initial guess for the vector X.

     The second argument is a function handle pointing to the objective
     function.  The objective function must be of the form

               y = phi (x)

     in which X is a vector and Y is a scalar.

     The second argument may also be a 2- or 3-element cell array of
     function handles.  The first element should point to the objective
     function, the second should point to a function that computes the
     gradient of the objective function, and the third should point to a
     function to compute the hessian of the objective function.  If the
     gradient function is not supplied, the gradient is computed by
     finite differences.  If the hessian function is not supplied, a
     BFGS update formula is used to approximate the hessian.

     If supplied, the gradient function must be of the form

          g = gradient (x)

     in which X is a vector and G is a vector.

     If supplied, the hessian function must be of the form

          h = hessian (x)

     in which X is a vector and H is a matrix.

     The third and fourth arguments are function handles pointing to
     functions that compute the equality constraints and the inequality
     constraints, respectively.

     If your problem does not have equality (or inequality) constraints,
     you may pass an empty matrix for CEF (or CIF).

     If supplied, the equality and inequality constraint functions must
     be of the form

          r = f (x)

     in which X is a vector and R is a vector.

     The third and fourth arguments may also be 2-element cell arrays of
     function handles.  The first element should point to the constraint
     function and the second should point to a function that computes
     the gradient of the constraint function:

                          [ d f(x)   d f(x)        d f(x) ]
              transpose ( [ ------   -----   ...   ------ ] )
                          [  dx_1     dx_2          dx_N  ]

     The fifth and sixth arguments are vectors containing lower and
     upper bounds on X.  These must be consistent with equality and
     inequality constraints G and H.  If the bounds are not specified,
     or are empty, they are set to -REALMAX and REALMAX by default.

     The seventh argument is max. number of iterations.  If not
     specified, the default value is 100.

     The eighth argument is tolerance for stopping criteria.  If not
     specified, the default value is EPS.

     Here is an example of calling `sqp':

          function r = g (x)
            r = [ sumsq(x)-10;
                  x(2)*x(3)-5*x(4)*x(5);
                  x(1)^3+x(2)^3+1 ];
          endfunction

          function obj = phi (x)
            obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
          endfunction

          x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];

          [x, obj, info, iter, nf, lambda] = sqp (x0, @phi, @g, [])

          x =

            -1.71714
             1.59571
             1.82725
            -0.76364
            -0.76364

          obj = 0.053950
          info = 101
          iter = 8
          nf = 10
          lambda =

            -0.0401627
             0.0379578
            -0.0052227

     The value returned in INFO may be one of the following:
    101
          The algorithm terminated because the norm of the last step
          was less than `tol * norm (x))' (the value of tol is
          currently fixed at `sqrt (eps)'--edit `sqp.m' to modify this
          value.

    102
          The BFGS update failed.

    103
          The maximum number of iterations was reached (the maximum
          number of allowed iterations is currently fixed at 100--edit
          `sqp.m' to increase this value).

     See also: qp
}

#
sqrt
{
`sqrt' is a built-in function

 -- Mapping Function:  sqrt (X)
     Compute the square root of each element of X.  If X is negative, a
     complex result is returned.  To compute the matrix square root, see
     *note Linear Algebra::.

     See also: realsqrt
}

#
sqrtm
{
`sqrtm' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/sqrtm.oct

 -- Loadable Function: [RESULT, ERROR_ESTIMATE] = sqrtm (A)
     Compute the matrix square root of the square matrix A.

     Ref: Nicholas J. Higham.  A new sqrtm for MATLAB.  Numerical
     Analysis Report No. 336, Manchester Centre for Computational
     Mathematics, Manchester, England, January 1999.

     See also: expm, logm
}

#
squeeze
{
`squeeze' is a built-in function

 -- Built-in Function:  squeeze (X)
     Remove singleton dimensions from X and return the result.  Note
     that for compatibility with MATLAB, all objects have a minimum of
     two dimensions and row vectors are left unchanged.
}

#
sscanf
{
`sscanf' is a built-in function

 -- Built-in Function: [VAL, COUNT] = sscanf (STRING, TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT] = sscanf (STRING, TEMPLATE,
          "C")
     This is like `fscanf', except that the characters are taken from
     the string STRING instead of from a stream.  Reaching the end of
     the string is treated as an end-of-file condition.

     See also: fscanf, scanf, sprintf
}

#
stairs
{
`stairs' is a function from the file /usr/share/octave/3.2.3/m/plot/stairs.m

 -- Function File:  stairs (X, Y)
 -- Function File:  stairs (..., STYLE)
 -- Function File:  stairs (..., PROP, VAL)
 -- Function File:  stairs (H, ...)
 -- Function File: H = stairs (...)
     Produce a stairstep plot.  The arguments may be vectors or
     matrices.

     If only one argument is given, it is taken as a vector of y-values
     and the x coordinates are taken to be the indices of the elements.

     If two output arguments are specified, the data are generated but
     not plotted.  For example,

          stairs (x, y);

     and

          [xs, ys] = stairs (x, y);
          plot (xs, ys);

     are equivalent.

     See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
     bar, xlabel, ylabel, title
}

#
stat
{
`stat' is a built-in function

 -- Built-in Function: [INFO, ERR, MSG] = stat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FILE)
     Return a structure S containing the following information about
     FILE.

    `dev'
          ID of device containing a directory entry for this file.

    `ino'
          File number of the file.

    `mode'
          File mode, as an integer.  Use the functions `S_ISREG',
          `S_ISDIR', `S_ISCHR', `S_ISBLK', `S_ISFIFO', `S_ISLNK', or
          `S_ISSOCK' to extract information from this value.

    `modestr'
          File mode, as a string of ten letters or dashes as would be
          returned by `ls -l'.

    `nlink'
          Number of links.

    `uid'
          User ID of file's owner.

    `gid'
          Group ID of file's group.

    `rdev'
          ID of device for block or character special files.

    `size'
          Size in bytes.

    `atime'
          Time of last access in the same form as time values returned
          from `time'.  *Note Timing Utilities::.

    `mtime'
          Time of last modification in the same form as time values
          returned from `time'.  *Note Timing Utilities::.

    `ctime'
          Time of last file status change in the same form as time
          values returned from `time'.  *Note Timing Utilities::.

    `blksize'
          Size of blocks in the file.

    `blocks'
          Number of blocks allocated for file.

     If the call is successful ERR is 0 and MSG is an empty string.  If
     the file does not exist, or some other error occurs, S is an empty
     matrix, ERR is -1, and MSG contains the corresponding system error
     message.

     If FILE is a symbolic link, `stat' will return information about
     the actual file that is referenced by the link.  Use `lstat' if
     you want information about the symbolic link itself.

     For example,

          [s, err, msg] = stat ("/vmlinuz")
               => s =
                 {
                   atime = 855399756
                   rdev = 0
                   ctime = 847219094
                   uid = 0
                   size = 389218
                   blksize = 4096
                   mtime = 847219094
                   gid = 6
                   nlink = 1
                   blocks = 768
                   mode = -rw-r--r--
                   modestr = -rw-r--r--
                   ino = 9316
                   dev = 2049
                 }
              => err = 0
              => msg =
}

#
static
{

 -- Keyword: static
     This function has been deprecated in favor of persistent.

     See also: persistent
}

#
statistics
{
`statistics' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/statistics.m

 -- Function File:  statistics (X)
     If X is a matrix, return a matrix with the minimum, first
     quartile, median, third quartile, maximum, mean, standard
     deviation, skewness and kurtosis of the columns of X as its
     columns.

     If X is a vector, calculate the statistics along the non-singleton
     dimension.
}

#
std
{
`std' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/std.m

 -- Function File:  std (X)
 -- Function File:  std (X, OPT)
 -- Function File:  std (X, OPT, DIM)
     If X is a vector, compute the standard deviation of the elements
     of X.

          std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
     If X is a matrix, compute the standard deviation for each column
     and return them in a row vector.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          normalizes with N-1, provides the square root of best
          unbiased estimator of   the variance [default]

    1:
          normalizes with N, this provides the square root of the
          second moment around   the mean

     The third argument DIM determines the dimension along which the
     standard deviation is calculated.

     See also: mean, median
}

#
stderr
{
`stderr' is a built-in function

 -- Built-in Function:  stderr ()
     Return the numeric value corresponding to the standard error
     stream.  Even if paging is turned on, the standard error is not
     sent to the pager.  It is useful for error messages and prompts.

     See also: stdin, stdout
}

#
stdin
{
`stdin' is a built-in function

 -- Built-in Function:  stdin ()
     Return the numeric value corresponding to the standard input
     stream.  When Octave is used interactively, this is filtered
     through the command line editing functions.

     See also: stdout, stderr
}

#
stdnormal_cdf
{
`stdnormal_cdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/stdnormal_cdf.m

 -- Function File:  stdnormal_cdf (X)
     For each component of X, compute the CDF of the standard normal
     distribution at X.
}

#
stdnormal_inv
{
`stdnormal_inv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/stdnormal_inv.m

 -- Function File:  stdnormal_inv (X)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the standard normal distribution.
}

#
stdnormal_pdf
{
`stdnormal_pdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/stdnormal_pdf.m

 -- Function File:  stdnormal_pdf (X)
     For each element of X, compute the probability density function
     (PDF) of the standard normal distribution at X.
}

#
stdnormal_rnd
{
`stdnormal_rnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/stdnormal_rnd.m

 -- Function File:  stdnormal_rnd (R, C)
 -- Function File:  stdnormal_rnd (SZ)
     Return an R by C or `size (SZ)' matrix of random numbers from the
     standard normal distribution.
}

#
stdout
{
`stdout' is a built-in function

 -- Built-in Function:  stdout ()
     Return the numeric value corresponding to the standard output
     stream.  Data written to the standard output is normally filtered
     through the pager.

     See also: stdin, stderr
}

#
stem
{
`stem' is a function from the file /usr/share/octave/3.2.3/m/plot/stem.m

 -- Function File: H = stem (X, Y, LINESPEC)
 -- Function File: H = stem (..., "filled")
     Plot a stem graph from two vectors of x-y data.  If only one
     argument is given, it is taken as the y-values and the x
     coordinates are taken from the indices of the elements.

     If Y is a matrix, then each column of the matrix is plotted as a
     separate stem graph.  In this case X can either be a vector, the
     same length as the number of rows in Y, or it can be a matrix of
     the same size as Y.

     The default color is `"r"' (red).  The default line style is `"-"'
     and the default marker is `"o"'.  The line style can be altered by
     the `linespec' argument in the same manner as the `plot' command.
     For example

          x = 1:10;
          y = ones (1, length (x))*2.*x;
          stem (x, y, "b");

     plots 10 stems with heights from 2 to 20 in blue;

     The return value of `stem' is a vector if "stem series" graphics
     handles, with one handle per column of the variable Y.  This
     handle regroups the elements of the stem graph together as the
     children of the "stem series" handle, allowing them to be altered
     together.  For example

          x = [0 : 10].';
          y = [sin(x), cos(x)]
          h = stem (x, y);
          set (h(2), "color", "g");
          set (h(1), "basevalue", -1)

     changes the color of the second "stem series"  and moves the base
     line of the first.

     See also: bar, barh, plot
}

#
stem3
{
`stem3' is a function from the file /usr/share/octave/3.2.3/m/plot/stem3.m

 -- Function File: H = stem3 (X, Y, Z, LINESPEC)
     Plot a three-dimensional stem graph and return the handles of the
     line and marker objects used to draw the stems as "stem series"
     object.  The default color is `"r"' (red).  The default line style
     is `"-"' and the default marker is `"o"'.

     For example,
          theta = 0:0.2:6;
          stem3 (cos (theta), sin (theta), theta)

     plots 31 stems with heights from 0 to 6 lying on a circle.  Color
     definitions with rgb-triples are not valid!

     See also: bar, barh, stem, plot
}

#
stft
{
`stft' is a function from the file /usr/share/octave/3.2.3/m/signal/stft.m

 -- Function File: [Y, C] = stft (X, WIN_SIZE, INC, NUM_COEF, W_TYPE)
     Compute the short-time Fourier transform of the vector X with
     NUM_COEF coefficients by applying a window of WIN_SIZE data points
     and an increment of INC points.

     Before computing the Fourier transform, one of the following
     windows is applied:

    hanning
          w_type = 1

    hamming
          w_type = 2

    rectangle
          w_type = 3

     The window names can be passed as strings or by the W_TYPE number.

     If not all arguments are specified, the following defaults are
     used: WIN_SIZE = 80, INC = 24, NUM_COEF = 64, and W_TYPE = 1.

     `Y = stft (X, ...)' returns the absolute values of the Fourier
     coefficients according to the NUM_COEF positive frequencies.

     `[Y, C] = stft (`x', ...)' returns the entire STFT-matrix Y and a
     3-element vector C containing the window size, increment, and
     window type, which is needed by the synthesis function.
}

#
str2double
{
`str2double' is a function from the file /usr/share/octave/3.2.3/m/strings/str2double.m

 -- Function File: [NUM, STATUS, STRARRAY] = str2double (STR, CDELIM,
          RDELIM, DDELIM)
     Convert strings into numeric values.

     `str2double' can replace `str2num', but avoids the use of `eval'
     on unknown data.

     STR can be the form `[+-]d[.]dd[[eE][+-]ddd]' in which `d' can be
     any of digit from 0 to 9, and `[]' indicate optional elements.

     NUM is the corresponding numeric value.  If the conversion fails,
     status is -1 and NUM is NaN.

     STATUS is 0 if the conversion was successful and -1 otherwise.

     STRARRAY is a cell array of strings.

     Elements which are not defined or not valid return NaN and the
     STATUS becomes -1.

     If STR is a character array or a cell array of strings, then NUM
     and STATUS return matrices of appropriate size.

     STR can also contain multiple elements separated by row and column
     delimiters (CDELIM and RDELIM).

     The parameters CDELIM, RDELIM, and DDELIM are optional column,
     row, and decimal delimiters.

     The default row-delimiters are newline, carriage return and
     semicolon (ASCII 10, 13 and 59).  The default column-delimiters
     are tab, space and comma (ASCII 9, 32, and 44).  The default
     decimal delimiter is `.' (ASCII 46).

     CDELIM, RDELIM, and DDELIM must contain only nul, newline,
     carriage return, semicolon, colon, slash, tab, space, comma, or
     `()[]{}' (ASCII 0, 9, 10, 11, 12, 13, 14, 32, 33, 34, 40, 41, 44,
     47, 58, 59, 91, 93, 123, 124, 125).

     Examples:

          str2double ("-.1e-5")
          => -1.0000e-006

          str2double (".314e1, 44.44e-1, .7; -1e+1")
          =>
             3.1400    4.4440    0.7000
           -10.0000       NaN       NaN

          line = "200, 300, NaN, -inf, yes, no, 999, maybe, NaN";
          [x, status] = str2double (line)
          => x =
              200   300   NaN  -Inf   NaN   NaN   999   NaN   NaN
          => status =
                0     0     0     0    -1    -1     0    -1     0

     See also: str2num
}

#
str2func
{
`str2func' is a built-in function

 -- Built-in Function:  str2func (FCN_NAME)
     Return a function handle constructed from the string FCN_NAME.
}

#
str2mat
{
`str2mat' is a function from the file /usr/share/octave/3.2.3/m/deprecated/str2mat.m

 -- Function File:  str2mat (S_1, ..., S_N)
     Return a matrix containing the strings S_1, ..., S_N as its rows.
     Each string is padded with blanks in order to form a valid matrix.

     This function is modelled after MATLAB.  In Octave, you can create
     a matrix of strings by `[S_1; ...; S_N]' even if the strings are
     not all the same length.
}

#
str2num
{
`str2num' is a function from the file /usr/share/octave/3.2.3/m/strings/str2num.m

 -- Function File:  str2num (S)
     Convert the string (or character array) S to a number (or an
     array).  Examples:

          str2num("3.141596")
               => 3.141596

          str2num(["1, 2, 3"; "4, 5, 6"]);
               => ans =
                  1  2  3
                  4  5  6

     *Caution:* As `str2num' uses the `eval' function to do the
     conversion, `str2num' will execute any code contained in the
     string S.  Use `str2double' instead if you want to avoid the use
     of `eval'.

     See also: str2double, eval
}

#
strcat
{
`strcat' is a function from the file /usr/share/octave/3.2.3/m/strings/strcat.m

 -- Function File:  strcat (S1, S2, ...)
     Return a string containing all the arguments concatenated
     horizontally.  If the arguments are cells strings,  `strcat'
     returns a cell string with the individual cells concatenated.  For
     numerical input, each element is converted to the corresponding
     ASCII character.  Trailing white space is eliminated.  For example,

          s = [ "ab"; "cde" ];
          strcat (s, s, s)
               => ans =
                  "ab ab ab "
                  "cdecdecde"

          s = { "ab"; "cde" };
          strcat (s, s, s)
               => ans =
                  {
                    [1,1] = ababab
                    [2,1] = cdecdecde
                  }

     See also: cstrcat, char, strvcat
}

#
strchr
{
`strchr' is a function from the file /usr/share/octave/3.2.3/m/strings/strchr.m

 -- Function File: IDX = strchr (STR, CHARS)
 -- Function File: IDX = strchr (STR, CHARS, N)
 -- Function File: IDX = strchr (STR, CHARS, N, DIRECTION)
     Search for the string STR for occurrences of characters from the
     set CHARS.  The return value, as well as the N and DIRECTION
     arguments behave identically as in `find'.

     This will be faster than using regexp in most cases.

     See also: find
}

#
strcmp
{
`strcmp' is a built-in function

 -- Built-in Function:  strcmp (S1, S2)
     Return 1 if the character strings S1 and S2 are the same, and 0
     otherwise.

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     See also: strcmpi, strncmp, strncmpi
}

#
strcmpi
{
`strcmpi' is a function from the file /usr/share/octave/3.2.3/m/strings/strcmpi.m

 -- Function File:  strcmpi (S1, S2)
     Ignoring case, return 1 if the character strings (or character
     arrays) S1 and S2 are the same, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmpi
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     See also: strcmp, strncmp, strncmpi
}

#
strerror
{
`strerror' is a function from the file /usr/share/octave/3.2.3/m/general/strerror.m

 -- Function File:  strerror (NAME, NUM)
     Return the text of an error message for function NAME
     corresponding to the error number NUM.  This function is intended
     to be used to print useful error messages for those functions that
     return numeric error codes.
}

#
strfind
{
`strfind' is a function from the file /usr/share/octave/3.2.3/m/strings/strfind.m

 -- Function File: IDX = strfind (STR, PATTERN)
 -- Function File: IDX = strfind (CELLSTR, PATTERN)
     Search for PATTERN in the string STR and return the starting index
     of every such occurrence in the vector IDX.  If there is no such
     occurrence, or if PATTERN is longer than STR, then IDX is the
     empty array `[]'.

     If the cell array of strings CELLSTR is specified instead of the
     string STR, then IDX is a cell array of vectors, as specified
     above.  Examples:

          strfind ("abababa", "aba")
               => [1, 3, 5]

          strfind ({"abababa", "bebebe", "ab"}, "aba")
               => ans =
                  {
                    [1,1] =

                       1   3   5

                    [1,2] = [](1x0)
                    [1,3] = [](1x0)
                  }

     See also: findstr, strmatch, strcmp, strncmp, strcmpi, strncmpi,
     find
}

#
strftime
{
`strftime' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/time.oct

 -- Loadable Function:  strftime (FMT, TM_STRUCT)
     Format the time structure TM_STRUCT in a flexible way using the
     format string FMT that contains `%' substitutions similar to those
     in `printf'.  Except where noted, substituted fields have a fixed
     size; numeric fields are padded if necessary.  Padding is with
     zeros by default; for fields that display a single number, padding
     can be changed or inhibited by following the `%' with one of the
     modifiers described below.  Unknown field specifiers are copied as
     normal characters.  All other characters are copied to the output
     without change.  For example,

          strftime ("%r (%Z) %A %e %B %Y", localtime (time ()))
              => "01:15:06 AM (CST) Monday 17 February 1997"

     Octave's `strftime' function supports a superset of the ANSI C
     field specifiers.

     Literal character fields:

    `%'
          % character.

    `n'
          Newline character.

    `t'
          Tab character.

     Numeric modifiers (a nonstandard extension):

    `- (dash)'
          Do not pad the field.

    `_ (underscore)'
          Pad the field with spaces.

     Time fields:

    `%H'
          Hour (00-23).

    `%I'
          Hour (01-12).

    `%k'
          Hour (0-23).

    `%l'
          Hour (1-12).

    `%M'
          Minute (00-59).

    `%p'
          Locale's AM or PM.

    `%r'
          Time, 12-hour (hh:mm:ss [AP]M).

    `%R'
          Time, 24-hour (hh:mm).

    `%s'
          Time in seconds since 00:00:00, Jan 1, 1970 (a nonstandard
          extension).

    `%S'
          Second (00-61).

    `%T'
          Time, 24-hour (hh:mm:ss).

    `%X'
          Locale's time representation (%H:%M:%S).

    `%Z'
          Time zone (EDT), or nothing if no time zone is determinable.

     Date fields:

    `%a'
          Locale's abbreviated weekday name (Sun-Sat).

    `%A'
          Locale's full weekday name, variable length (Sunday-Saturday).

    `%b'
          Locale's abbreviated month name (Jan-Dec).

    `%B'
          Locale's full month name, variable length (January-December).

    `%c'
          Locale's date and time (Sat Nov 04 12:02:33 EST 1989).

    `%C'
          Century (00-99).

    `%d'
          Day of month (01-31).

    `%e'
          Day of month ( 1-31).

    `%D'
          Date (mm/dd/yy).

    `%h'
          Same as %b.

    `%j'
          Day of year (001-366).

    `%m'
          Month (01-12).

    `%U'
          Week number of year with Sunday as first day of week (00-53).

    `%w'
          Day of week (0-6).

    `%W'
          Week number of year with Monday as first day of week (00-53).

    `%x'
          Locale's date representation (mm/dd/yy).

    `%y'
          Last two digits of year (00-99).

    `%Y'
          Year (1970-).

     See also: strptime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday
}

#
string_fill_char
{
`string_fill_char' is a built-in function

 -- Built-in Function: VAL = string_fill_char ()
 -- Built-in Function: OLD_VAL = string_fill_char (NEW_VAL)
     Query or set the internal variable used to pad all rows of a
     character matrix to the same length.  It must be a single
     character.  The default value is `" "' (a single space).  For
     example,

          string_fill_char ("X");
          [ "these"; "are"; "strings" ]
              => "theseXX"
                 "areXXXX"
                 "strings"
}

#
strjust
{
`strjust' is a function from the file /usr/share/octave/3.2.3/m/strings/strjust.m

 -- Function File:  strjust (S, ["left"|"right"|"center"])
     Shift the non-blank text of S to the left, right or center of the
     string.  If S is a string array, justify each string in the array.
     Null characters are replaced by blanks.  If no justification is
     specified, then all rows are right-justified.  For example:

          strjust (["a"; "ab"; "abc"; "abcd"])
               => ans =
                     a
                    ab
                   abc
                  abcd
}

#
strmatch
{
`strmatch' is a function from the file /usr/share/octave/3.2.3/m/strings/strmatch.m

 -- Function File:  strmatch (S, A, "exact")
     Return indices of entries of A that match the string S.  The
     second argument A may be a string matrix or a cell array of
     strings.  If the third argument `"exact"' is not given, then S
     only needs to match A up to the length of S.  Nul characters match
     blanks.  Results are returned as a column vector.  For example:

          strmatch ("apple", "apple juice")
               => 1

          strmatch ("apple", ["apple pie"; "apple juice"; "an apple"])
               => [1; 2]

          strmatch ("apple", {"apple pie"; "apple juice"; "tomato"})
               => [1; 2]

     See also: strfind, findstr, strcmp, strncmp, strcmpi, strncmpi,
     find
}

#
strncmp
{
`strncmp' is a built-in function

 -- Built-in Function:  strncmp (S1, S2, N)
     Return 1 if the first N characters of strings S1 and S2 are the
     same, and 0 otherwise.

          strncmp ("abce", "abcd", 3)
              => 1

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

          strncmp ("abce", {"abcd", "bca", "abc"}, 3)
              => [1, 0, 1]

     *Caution:* For compatibility with MATLAB, Octave's strncmp
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     See also: strncmpi, strcmp, strcmpi
}

#
strncmpi
{
`strncmpi' is a function from the file /usr/share/octave/3.2.3/m/strings/strncmpi.m

 -- Function File:  strncmpi (S1, S2, N)
     Ignoring case, return 1 if the first N characters of character
     strings (or character arrays) S1 and S2 are the same, and 0
     otherwise.

     If either S1 or S2 is a cell array of strings, then an array of
     the same size is returned, containing the values described above
     for every member of the cell array.  The other argument may also
     be a cell array of strings (of the same size or with only one
     element), char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strncmpi
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     See also: strcmp, strcmpi, strncmp
}

#
strptime
{
`strptime' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/time.oct

 -- Loadable Function: [TM_STRUCT, NCHARS] = strptime (STR, FMT)
     Convert the string STR to the time structure TM_STRUCT under the
     control of the format string FMT.

     If FMT fails to match, NCHARS is 0; otherwise it is set to the
     position of last matched character plus 1. Always check for this
     unless you're absolutely sure the date string will be parsed
     correctly.

     See also: strftime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday
}

#
strrep
{
`strrep' is a function from the file /usr/share/octave/3.2.3/m/strings/strrep.m

 -- Function File:  strrep (S, X, Y)
     Replace all occurrences of the substring X of the string S with
     the string Y and return the result.  For example,

          strrep ("This is a test string", "is", "&%$")
               => "Th&%$ &%$ a test string"

     See also: regexprep, strfind, findstr
}

#
strsplit
{
`strsplit' is a function from the file /usr/share/octave/3.2.3/m/strings/strsplit.m

 -- Function File: [S] = strsplit (P, SEP, STRIP_EMPTY)
     Split a single string using one or more delimiters and return a
     cell array of strings.  Consecutive delimiters and delimiters at
     boundaries result in empty strings, unless STRIP_EMPTY is true.
     The default value of STRIP_EMPTY is false.

     See also: strtok
}

#
strtok
{
`strtok' is a function from the file /usr/share/octave/3.2.3/m/strings/strtok.m

 -- Function File: [TOK, REM] = strtok (STR, DELIM)
     Find all characters up to but not including the first character
     which is in the string delim.  If REM is requested, it contains the
     remainder of the string, starting at the first delimiter.  Leading
     delimiters are ignored.  If DELIM is not specified, space is
     assumed.  For example:

          strtok ("this is the life")
               => "this"

          [tok, rem] = strtok ("14*27+31", "+-*/")
               =>
                  tok = 14
                  rem = *27+31

     See also: index, strsplit
}

#
strtrim
{
`strtrim' is a function from the file /usr/share/octave/3.2.3/m/strings/strtrim.m

 -- Function File:  strtrim (S)
     Remove leading and trailing blanks and nulls from S.  If S is a
     matrix, STRTRIM trims each row to the length of longest string.
     If S is a cell array, operate recursively on each element of the
     cell array.  For example:

          strtrim ("    abc  ")
               => "abc"

          strtrim ([" abc   "; "   def   "])
               => ["abc  "; "  def"]
}

#
strtrunc
{
`strtrunc' is a function from the file /usr/share/octave/3.2.3/m/strings/strtrunc.m

 -- Function File:  strtrunc (S, N)
     Truncate the character string S to length N.  If S is a char
     matrix, then the number of columns is adjusted.

     If S is a cell array of strings, then the operation is performed
     on its members and the new cell array is returned.
}

#
struct
{
`struct' is a built-in function

 -- Built-in Function:  struct ("field", VALUE, "field", VALUE, ...)
     Create a structure and initialize its value.

     If the values are cell arrays, create a structure array and
     initialize its values.  The dimensions of each cell array of
     values must match.  Singleton cells and non-cell values are
     repeated so that they fill the entire array.  If the cells are
     empty, create an empty structure array with the specified field
     names.

     If the argument is an object, return the underlying struct.
}

#
struct2cell
{
`struct2cell' is a built-in function

 -- Built-in Function:  struct2cell (S)
     Create a new cell array from the objects stored in the struct
     object.  If F is the number of fields in the structure, the
     resulting cell array will have a dimension vector corresponding to
     `[F size(S)]'.

     See also: cell2struct, fieldnames
}

#
struct_contains
{
`struct_contains' is a function from the file /usr/share/octave/3.2.3/m/deprecated/struct_contains.m

 -- Function File:  struct_contains (EXPR, NAME)
     This function has been deprecated.  Use isfield instead.
}

#
struct_elements
{
`struct_elements' is a function from the file /usr/share/octave/3.2.3/m/deprecated/struct_elements.m

 -- Function File:  struct_elements (STRUCT)
     This function has been deprecated.  Use fieldnames instead.
}

#
struct_levels_to_print
{
`struct_levels_to_print' is a built-in function

 -- Built-in Function: VAL = struct_levels_to_print ()
 -- Built-in Function: OLD_VAL = struct_levels_to_print (NEW_VAL)
     Query or set the internal variable that specifies the number of
     structure levels to display.
}

#
structfun
{
`structfun' is a function from the file /usr/share/octave/3.2.3/m/general/structfun.m

 -- Function File:  structfun (FUNC, S)
 -- Function File: [A, B] = structfun (...)
 -- Function File:  structfun (..., "ErrorHandler", ERRFUNC)
 -- Function File:  structfun (..., "UniformOutput", VAL)
     Evaluate the function named NAME on the fields of the structure S.
     The fields of S are passed to the function FUNC individually.

     `structfun' accepts an arbitrary function FUNC in the form of an
     inline function, function handle, or the name of a function (in a
     character string).  In the case of a character string argument, the
     function must accept a single argument named X, and it must return
     a string value.  If the function returns more than one argument,
     they are returned as separate output variables.

     If the parameter "UniformOutput" is set to true (the default),
     then the function must return a single element which will be
     concatenated into the return value.  If "UniformOutput" is false,
     the outputs placed in a structure with the same fieldnames as the
     input structure.

          s.name1 = "John Smith";
          s.name2 = "Jill Jones";
          structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s,
                     "UniformOutput", false)

     Given the parameter "ErrorHandler", then ERRFUNC defines a
     function to call in case FUNC generates an error.  The form of the
     function is

          function [...] = errfunc (SE, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by SE.  This is a structure with the elements
     "identifier", "message" and "index", giving respectively the error
     identifier, the error message, and the index into the input
     arguments of the element that caused the error.

     See also: cellfun, arrayfun
}

#
strvcat
{
`strvcat' is a built-in function

 -- Built-in Function:  strvcat (X)
 -- Built-in Function:  strvcat (X, ...)
 -- Built-in Function:  strvcat (S1, S2, ...)
 -- Built-in Function:  strvcat (CELL_ARRAY)
     Create a character array from one or more numeric matrices,
     character matrices, or cell arrays.  Arguments are concatenated
     vertically.  The returned values are padded with blanks as needed
     to make each row of the string array have the same length.  Unlike
     `char', empty strings are removed and will not appear in the
     output.

     For numerical input, each element is converted to the
     corresponding ASCII character.  A range error results if an input
     is outside the ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through `strvcat' can mostly be converted back
     with `cellstr'.  For example,

          strvcat ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
              => ["abc    "
                  "98     "
                  "99     "
                  "d      "
                  "str1   "
                  "half   "]

     See also: char, strcat, cstrcat
}

#
studentize
{
`studentize' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/studentize.m

 -- Function File:  studentize (X, DIM)
     If X is a vector, subtract its mean and divide by its standard
     deviation.

     If X is a matrix, do the above along the first non-singleton
     dimension.  If the optional argument DIM is given then operate
     along this dimension.
}

#
sub2ind
{
`sub2ind' is a function from the file /usr/share/octave/3.2.3/m/general/sub2ind.m

 -- Function File: IND = sub2ind (DIMS, I, J)
 -- Function File: IND = sub2ind (DIMS, S1, S2, ..., SN)
     Convert subscripts into a linear index.

     The following example shows how to convert the two-dimensional
     index `(2,3)' of a 3-by-3 matrix to a linear index.  The matrix is
     linearly indexed moving from one column to next, filling up all
     rows in each column.

          linear_index = sub2ind ([3, 3], 2, 3)
          => 8

     See also: ind2sub
}

#
subplot
{
`subplot' is a function from the file /usr/share/octave/3.2.3/m/plot/subplot.m

 -- Function File:  subplot (ROWS, COLS, INDEX)
 -- Function File:  subplot (RCN)
     Set up a plot grid with COLS by ROWS subwindows and plot in
     location given by INDEX.

     If only one argument is supplied, then it must be a three digit
     value specifying the location in digits 1 (rows) and 2 (columns)
     and the plot index in digit 3.

     The plot index runs row-wise.  First all the columns in a row are
     filled and then the next row is filled.

     For example, a plot with 2 by 3 grid will have plot indices
     running as follows:

               +-----+-----+-----+
               |  1  |  2  |  3  |
               +-----+-----+-----+
               |  4  |  5  |  6  |
               +-----+-----+-----+

     See also: plot
}

#
subsasgn
{
`subsasgn' is a built-in function

 -- Built-in Function:  subsasgn (VAL, IDX, RHS)
     Perform the subscripted assignment operation according to the
     subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     `type' and `subs'.  Valid values for `type' are `"()"', `"{}"',
     and `"."'.  The `subs' field may be either `":"' or a cell array
     of index values.

     The following example shows how to set the two first columns of a
     3-by-3 matrix to zero.

          val = magic(3);
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsasgn (val, idx, 0)
              => [ 0   0   6
                   0   0   7
                   0   0   2 ]

     Note that this is the same as writing `val(:,1:2) = 0'.

     See also: subsref, substruct
}

#
subsindex
{
`subsindex' is a function from the file /usr/share/octave/3.2.3/m/general/subsindex.m

 -- Function File: IDX = subsindex (A)
     Convert an object to an index vector.  When A is a class object
     defined with a class constructor, then `subsindex' is the
     overloading method that allows the conversion of this class object
     to a valid indexing vector.  It is important to note that
     `subsindex' must return a zero-based real integer vector of the
     class "double".  For example, if the class constructor

          function b = myclass (a)
           b = myclass (struct ("a", a), "myclass");
          endfunction

     then the `subsindex' function

          function idx = subsindex (a)
           idx = double (a.a) - 1.0;
          endfunction

     can then be used as follows

          a = myclass (1:4);
          b = 1:10;
          b(a)
          => 1  2  3  4

     See also: class, subsref, subsasgn
}

#
subspace
{
`subspace' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/subspace.m

 -- Function File: ANGLE = subspace (A, B)
     Determine the largest principal angle between two subspaces
     spanned by columns of matrices A and B.
}

#
subsref
{
`subsref' is a built-in function

 -- Built-in Function:  subsref (VAL, IDX)
     Perform the subscripted element selection operation according to
     the subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     `type' and `subs'.  Valid values for `type' are `"()"', `"{}"',
     and `"."'.  The `subs' field may be either `":"' or a cell array
     of index values.

     The following example shows how to extract the two first columns of
     a matrix

          val = magic(3)
              => val = [ 8   1   6
                         3   5   7
                         4   9   2 ]
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsref(val, idx)
              => [ 8   1
                   3   5
                   4   9 ]

     Note that this is the same as writing `val(:,1:2)'.

     See also: subsasgn, substruct
}

#
substr
{
`substr' is a function from the file /usr/share/octave/3.2.3/m/strings/substr.m

 -- Function File:  substr (S, OFFSET, LEN)
     Return the substring of S which starts at character number OFFSET
     and is LEN characters long.

     If OFFSET is negative, extraction starts that far from the end of
     the string.  If LEN is omitted, the substring extends to the end
     of S.

     For example,

          substr ("This is a test string", 6, 9)
               => "is a test"

     This function is patterned after AWK.  You can get the same result
     by `S(OFFSET : (OFFSET + LEN - 1))'.
}

#
substruct
{
`substruct' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/substruct.m

 -- Function File:  substruct (TYPE, SUBS, ...)
     Create a subscript structure for use with `subsref' or `subsasgn'.

     See also: subsref, subsasgn
}

#
sum
{
`sum' is a built-in function

 -- Built-in Function:  sum (X)
 -- Built-in Function:  sum (X, DIM)
 -- Built-in Function:  sum (..., 'native')
     Sum of elements along dimension DIM.  If DIM is omitted, it
     defaults to 1 (column-wise sum).

     As a special case, if X is a vector and DIM is omitted, return the
     sum of the elements.

     If the optional argument 'native' is given, then the sum is
     performed in the same type as the original argument, rather than
     in the default double type.  For example

          sum ([true, true])
           => 2
          sum ([true, true], 'native')
           => true

     See also: cumsum, sumsq, prod
}

#
summer
{
`summer' is a function from the file /usr/share/octave/3.2.3/m/image/summer.m

 -- Function File:  summer (N)
     Create color colormap.  This colormap is green to yellow.  The
     argument N should be a scalar.  If it is omitted, the length of
     the current colormap or 64 is assumed.

     See also: colormap
}

#
sumsq
{
`sumsq' is a built-in function

 -- Built-in Function:  sumsq (X)
 -- Built-in Function:  sumsq (X, DIM)
     Sum of squares of elements along dimension DIM.  If DIM is
     omitted, it defaults to 1 (column-wise sum of squares).

     As a special case, if X is a vector and DIM is omitted, return the
     sum of squares of the elements.

     This function is conceptually equivalent to computing
          sum (x .* conj (x), dim)
     but it uses less memory and avoids calling `conj' if X is real.

     See also: sum
}

#
superiorto
{
`superiorto' is a built-in function

 -- Built-in Function:  superiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a higher precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.
}

#
suppress_verbose_help_message
{
`suppress_verbose_help_message' is a built-in function

 -- Built-in Function: VAL = suppress_verbose_help_message ()
 -- Built-in Function: OLD_VAL = suppress_verbose_help_message (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     will add additional help information to the end of the output from
     the `help' command and usage messages for built-in commands.
}

#
surf
{
`surf' is a function from the file /usr/share/octave/3.2.3/m/plot/surf.m

 -- Function File:  surf (X, Y, Z)
     Plot a surface given matrices X, and Y from `meshgrid' and a
     matrix Z corresponding to the X and Y coordinates of the mesh.  If
     X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.

     See also: mesh, surface
}

#
surface
{
`surface' is a function from the file /usr/share/octave/3.2.3/m/plot/surface.m

 -- Function File:  surface (X, Y, Z, C)
 -- Function File:  surface (X, Y, Z)
 -- Function File:  surface (Z, C)
 -- Function File:  surface (Z)
 -- Function File:  surface (..., PROP, VAL)
 -- Function File:  surface (H, ...)
 -- Function File: H = surface (...)
     Plot a surface graphic object given matrices X, and Y from
     `meshgrid' and a matrix Z corresponding to the X and Y coordinates
     of the surface.  If X and Y are vectors, then a typical vertex is
     (X(j), Y(i), Z(i,j)).  Thus, columns of Z correspond to different
     X values and rows of Z correspond to different Y values.  If X and
     Y are missing, they are constructed from size of the matrix Z.

     Any additional properties passed are assigned to the surface.

     See also: surf, mesh, patch, line
}

#
surfc
{
`surfc' is a function from the file /usr/share/octave/3.2.3/m/plot/surfc.m

 -- Function File:  surfc (X, Y, Z)
     Plot a surface and contour given matrices X, and Y from `meshgrid'
     and a matrix Z corresponding to the X and Y coordinates of the
     mesh.  If X and Y are vectors, then a typical vertex is (X(j),
     Y(i), Z(i,j)).  Thus, columns of Z correspond to different X
     values and rows of Z correspond to different Y values.

     See also: meshgrid, surf, contour
}

#
surfl
{
`surfl' is a function from the file /usr/share/octave/3.2.3/m/plot/surfl.m

 -- Function File:  surfl (X, Y, Z)
 -- Function File:  surfl (Z)
 -- Function File:  surfl (X, Y, Z, L)
 -- Function File:  surfl (X, Y, Z, L, P)
 -- Function File:  surfl (...,"light")
     Plot a lighted surface given matrices X, and Y from `meshgrid' and
     a matrix Z corresponding to the X and Y coordinates of the mesh.
     If X and Y are vectors, then a typical vertex is (X(j), Y(i),
     Z(i,j)).  Thus, columns of Z correspond to different X values and
     rows of Z correspond to different Y values.

     The light direction can be specified using L.  It can be given as
     2-element vector [azimuth, elevation] in degrees or as 3-element
     vector [lx, ly, lz].  The default value is rotated 45
}

#
surfnorm
{
`surfnorm' is a function from the file /usr/share/octave/3.2.3/m/plot/surfnorm.m

 -- Function File:  surfnorm (X, Y, Z)
 -- Function File:  surfnorm (Z)
 -- Function File: [NX, NY, NZ] = surfnorm (...)
 -- Function File:  surfnorm (H, ...)
     Find the vectors normal to a meshgridded surface.  The meshed
     gridded surface is defined by X, Y, and Z.  If X and Y are not
     defined, then it is assumed that they are given by

          [X, Y] = meshgrid (1:size(Z, 1),
                               1:size(Z, 2));

     If no return arguments are requested, a surface plot with the
     normal vectors to the surface is plotted.  Otherwise the
     components of the normal vectors at the mesh gridded points are
     returned in NX, NY, and NZ.

     The normal vectors are calculated by taking the cross product of
     the diagonals of each of the quadrilaterals in the meshgrid to
     find the normal vectors of the centers of these quadrilaterals.
     The four nearest normal vectors to the meshgrid points are then
     averaged to obtain the normal to the surface at the meshgridded
     points.

     An example of the use of `surfnorm' is

          surfnorm (peaks (25));

     See also: surf, quiver3
}

#
svd
{
`svd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/svd.oct

 -- Loadable Function: S = svd (A)
 -- Loadable Function: [U, S, V] = svd (A)
     Compute the singular value decomposition of A

          A = U*S*V'

     The function `svd' normally returns the vector of singular values.
     If asked for three return values, it computes U, S, and V.  For
     example,

          svd (hilb (3))

     returns

          ans =

           1.4083189
           0.1223271
           0.0026873

     and

          [u, s, v] = svd (hilb (3))

     returns

          u =

           -0.82704   0.54745   0.12766
           -0.45986  -0.52829  -0.71375
           -0.32330  -0.64901   0.68867

          s =

           1.40832  0.00000  0.00000
           0.00000  0.12233  0.00000
           0.00000  0.00000  0.00269

          v =

           -0.82704   0.54745   0.12766
           -0.45986  -0.52829  -0.71375
           -0.32330  -0.64901   0.68867

     If given a second argument, `svd' returns an economy-sized
     decomposition, eliminating the unnecessary rows or columns of U or
     V.
}

#
svds
{
`svds' is a function from the file /usr/share/octave/3.2.3/m/sparse/svds.m

 -- Function File: S = svds (A)
 -- Function File: S = svds (A, K)
 -- Function File: S = svds (A, K, SIGMA)
 -- Function File: S = svds (A, K, SIGMA, OPTS)
 -- Function File: [U, S, V, FLAG] = svds (...)
     Find a few singular values of the matrix A.  The singular values
     are calculated using

          [M, N] = size(A)
          S = eigs([sparse(M, M), A; ...
                          A', sparse(N, N)])

     The eigenvalues returned by `eigs' correspond to the singular
     values of A.  The number of singular values to calculate is given
     by K, whose default value is 6.

     The argument SIGMA can be used to specify which singular values to
     find.  SIGMA can be either the string 'L', the default, in which
     case the largest singular values of A are found.  Otherwise SIGMA
     should be a real scalar, in which case the singular values closest
     to SIGMA are found.  Note that for relatively small values of
     SIGMA, there is the chance that the requested number of singular
     values are not returned.  In that case SIGMA should be increased.

     If OPTS is given, then it is a structure that defines options that
     `svds' will pass to EIGS.  The possible fields of this structure
     are therefore determined by `eigs'.  By default three fields of
     this structure are set by `svds'.

    `tol'
          The required convergence tolerance for the singular values.
          `eigs' is passed TOL divided by `sqrt(2)'.  The default value
          is 1e-10.

    `maxit'
          The maximum number of iterations.  The default is 300.

    `disp'
          The level of diagnostic printout.  If `disp' is 0 then there
          is no printout.  The default value is 0.

     If more than one output argument is given, then `svds' also
     calculates the left and right singular vectors of A.  FLAG is used
     to signal the convergence of `svds'.  If `svds' converges to the
     desired tolerance, then FLAG given by

          norm (A * V - U * S, 1) <= ...
                  TOL * norm (A, 1)

     will be zero.

   See also: eigs
}

#
swapbytes
{
`swapbytes' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/swapbytes.m

 -- Function File:  swapbytes (X)
     Swaps the byte order on values, converting from little endian to
     big endian and vice versa.  For example

          swapbytes (uint16 (1:4))
          => [   256   512   768  1024]

     See also: typecast, cast
}

#
switch
{

 -- Keyword: switch STATEMENT
     Begin a switch block.
          yesno = "yes"

          switch yesno
           case {"Yes" "yes" "YES" "y" "Y"}
             value = 1;
           case {"No" "no" "NO" "n" "N"}
             value = 0;
           otherwise
             error ("invalid value");
          endswitch

     See also: if, case, otherwise
}

#
syl
{
`syl' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/syl.oct

 -- Loadable Function: X = syl (A, B, C)
     Solve the Sylvester equation

          A X + X B + C = 0
     using standard LAPACK subroutines.  For example,

          syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
              => [ -0.50000, -0.66667; -0.66667, -0.50000 ]
}

#
sylvester_matrix
{
`sylvester_matrix' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/sylvester_matrix.m

 -- Function File:  sylvester_matrix (K)
     Return the Sylvester matrix of order n = 2^k.

     See also: hankel, vander, hilb, invhilb, toeplitz
}

#
symamd
{
`symamd' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/colamd.oct

 -- Loadable Function: P = symamd (S)
 -- Loadable Function: P = symamd (S, KNOBS)
 -- Loadable Function: [P, STATS] = symamd (S)
 -- Loadable Function: [P, STATS] = symamd (S, KNOBS)
     For a symmetric positive definite matrix S, returns the permutation
     vector p such that `S (P, P)' tends to have a sparser Cholesky
     factor than S.  Sometimes SYMAMD works well for symmetric
     indefinite matrices too.  The matrix S is assumed to be symmetric;
     only the strictly lower triangular part is referenced.  S must be
     square.

     KNOBS is an optional one- to two-element input vector.  If S is
     n-by-n, then rows and columns with more than
     `max(16,KNOBS(1)*sqrt(n))' entries are removed prior to ordering,
     and ordered last in the output permutation P.  No rows/columns are
     removed if `KNOBS(1) < 0'.  If `KNOBS (2)' is nonzero, `stats' and
     KNOBS are printed.  The default is `KNOBS = [10 0]'.  Note that
     KNOBS differs from earlier versions of symamd.

     STATS is an optional 20-element output vector that provides data
     about the ordering and the validity of the input matrix S.
     Ordering statistics are in `STATS (1:3)'.  `STATS (1) = STATS (2)'
     is the number of dense or empty rows and columns ignored by SYMAMD
     and `STATS (3)' is the number of garbage collections performed on
     the internal data structure used by SYMAMD (roughly of size `8.4 *
     nnz (tril (S, -1)) + 9 * N' integers).

     Octave built-in functions are intended to generate valid sparse
     matrices, with no duplicate entries, with ascending row indices of
     the nonzeros in each column, with a non-negative number of entries
     in each column (!)  and so on.  If a matrix is invalid, then
     SYMAMD may or may not be able to continue.  If there are duplicate
     entries (a row index appears two or more times in the same column)
     or if the row indices in a column are out of order, then SYMAMD
     can correct these errors by ignoring the duplicate entries and
     sorting each column of its internal copy of the matrix S (the
     input matrix S is not repaired, however).  If a matrix is invalid
     in other ways then SYMAMD cannot continue, an error message is
     printed, and no output arguments (P or STATS) are returned.
     SYMAMD is thus a simple way to check a sparse matrix to see if
     it's valid.

     `STATS (4:7)' provide information if SYMAMD was able to continue.
     The matrix is OK if `STATS (4)' is zero, or 1 if invalid.  `STATS
     (5)' is the rightmost column index that is unsorted or contains
     duplicate entries, or zero if no such column exists.  `STATS (6)'
     is the last seen duplicate or out-of-order row index in the column
     index given by `STATS (5)', or zero if no such row index exists.
     `STATS (7)' is the number of duplicate or out-of-order row
     indices.  `STATS (8:20)' is always zero in the current version of
     SYMAMD (reserved for future use).

     The ordering is followed by a column elimination tree
     post-ordering.

     The authors of the code itself are Stefan I. Larimore and Timothy
     A.  Davis (davis@cise.ufl.edu), University of Florida.  The
     algorithm was developed in collaboration with John Gilbert, Xerox
     PARC, and Esmond Ng, Oak Ridge National Laboratory.  (see
     `http://www.cise.ufl.edu/research/sparse/colamd')

     See also: colperm, colamd
}

#
symbfact
{
`symbfact' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/symbfact.oct

 -- Loadable Function: [COUNT, H, PARENT, POST, R] = symbfact (S, TYP,
          MODE)
     Performs a symbolic factorization analysis on the sparse matrix S.
     Where

    S
          S is a complex or real sparse matrix.

    TYP
          Is the type of the factorization and can be one of

         `sym'
               Factorize S.  This is the default.

         `col'
               Factorize `S' * S'.

         `row'
               Factorize `S * S''.

         `lo'
               Factorize `S''

    MODE
          The default is to return the Cholesky factorization for R,
          and if MODE is 'L', the conjugate transpose of the Cholesky
          factorization is returned.  The conjugate transpose version
          is faster and uses less memory, but returns the same values
          for COUNT, H, PARENT and POST outputs.

     The output variables are

    COUNT
          The row counts of the Cholesky factorization as determined by
          TYP.

    H
          The height of the elimination tree.

    PARENT
          The elimination tree itself.

    POST
          A sparse boolean matrix whose structure is that of the
          Cholesky factorization as determined by TYP.
}

#
symlink
{
`symlink' is a built-in function

 -- Built-in Function: [ERR, MSG] = symlink (OLD, NEW)
     Create a symbolic link NEW which contains the string OLD.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

     See also: link, readlink
}

#
symrcm
{
`symrcm' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/symrcm.oct

 -- Loadable Function: P = symrcm (S)
     Symmetric reverse Cuthill-McKee permutation of S.  Return a
     permutation vector P such that `S (P, P)' tends to have its
     diagonal elements closer to the diagonal than S.  This is a good
     preordering for LU or Cholesky factorization of matrices that come
     from 'long, skinny' problems.  It works for both symmetric and
     asymmetric S.

     The algorithm represents a heuristic approach to the NP-complete
     bandwidth minimization problem.  The implementation is based in the
     descriptions found in

     E. Cuthill, J. McKee: Reducing the Bandwidth of Sparse Symmetric
     Matrices. Proceedings of the 24th ACM National Conference, 157-172
     1969, Brandon Press, New Jersey.

     Alan George, Joseph W. H. Liu: Computer Solution of Large Sparse
     Positive Definite Systems, Prentice Hall Series in Computational
     Mathematics, ISBN 0-13-165274-5, 1981.

     See also: colperm, colamd, symamd
}

#
symvar
{
`symvar' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/symvar.m

 -- Function File:  symvar (S)
     Identifies the argument names in the function defined by a string.
     Common constant names such as `pi', `NaN', `Inf', `eps', `i' or
     `j' are ignored.  The arguments that are found are returned in a
     cell array of strings.  If no variables are found then the
     returned cell array is empty.
}

#
synthesis
{
`synthesis' is a function from the file /usr/share/octave/3.2.3/m/signal/synthesis.m

 -- Function File:  synthesis (Y, C)
     Compute a signal from its short-time Fourier transform Y and a
     3-element vector C specifying window size, increment, and window
     type.

     The values Y and C can be derived by

          [Y, C] = stft (X , ...)
}

#
system
{
`system' is a built-in function

 -- Built-in Function:  system (STRING, RETURN_OUTPUT, TYPE)
     Execute a shell command specified by STRING.  The second argument
     is optional.  If TYPE is `"async"', the process is started in the
     background and the process id of the child process is returned
     immediately.  Otherwise, the process is started, and Octave waits
     until it exits.  If the TYPE argument is omitted, a value of
     `"sync"' is assumed.

     If two input arguments are given (the actual value of
     RETURN_OUTPUT is irrelevant) and the subprocess is started
     synchronously, or if SYSTEM is called with one input argument and
     one or more output arguments, the output from the command is
     returned.  Otherwise, if the subprocess is executed synchronously,
     its output is sent to the standard output.  To send the output of
     a command executed with SYSTEM through the pager, use a command
     like

          disp (system (cmd, 1));

     or

          printf ("%s\n", system (cmd, 1));

     The `system' function can return two values.  The first is the
     exit status of the command and the second is any output from the
     command that was written to the standard output stream.  For
     example,

          [status, output] = system ("echo foo; exit 2");

     will set the variable `output' to the string `foo', and the
     variable `status' to the integer `2'.
}

#
t_cdf
{
`t_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/t_cdf.m

 -- Function File:  t_cdf (X, N)
     For each element of X, compute the CDF at X of the t (Student)
     distribution with N degrees of freedom, i.e., PROB (t(N) <= X).
}

#
t_inv
{
`t_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/t_inv.m

 -- Function File:  t_inv (X, N)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the t (Student) distribution with parameter N.
}

#
t_pdf
{
`t_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/t_pdf.m

 -- Function File:  t_pdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the T (Student) distribution with N degrees of
     freedom.
}

#
t_rnd
{
`t_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/t_rnd.m

 -- Function File:  t_rnd (N, R, C)
 -- Function File:  t_rnd (N, SZ)
     Return an R by C matrix of random samples from the t (Student)
     distribution with N degrees of freedom.  N must be a scalar or of
     size R by C.  Or if SZ is a vector create a matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the size
     of N.
}

#
t_test
{
`t_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/t_test.m

 -- Function File: [PVAL, T, DF] = t_test (X, M, ALT)
     For a sample X from a normal distribution with unknown mean and
     variance, perform a t-test of the null hypothesis `mean (X) == M'.
     Under the null, the test statistic T follows a Student
     distribution with `DF = length (X) - 1' degrees of freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `mean (X) != M'.  If ALT is
     `">"', the one-sided alternative `mean (X) > M' is considered.
     Similarly for "<", the one-sided alternative `mean (X) < M' is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
t_test_2
{
`t_test_2' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/t_test_2.m

 -- Function File: [PVAL, T, DF] = t_test_2 (X, Y, ALT)
     For two samples x and y from normal distributions with unknown
     means and unknown equal variances, perform a two-sample t-test of
     the null hypothesis of equal means.  Under the null, the test
     statistic T follows a Student distribution with DF degrees of
     freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `mean (X) != mean (Y)'.  If ALT
     is `">"', the one-sided alternative `mean (X) > mean (Y)' is used.
     Similarly for `"<"', the one-sided alternative `mean (X) < mean
     (Y)' is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
t_test_regression
{
`t_test_regression' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/t_test_regression.m

 -- Function File: [PVAL, T, DF] = t_test_regression (Y, X, RR, R, ALT)
     Perform an t test for the null hypothesis `RR * B = R' in a
     classical normal regression model `Y = X * B + E'.  Under the
     null, the test statistic T follows a T distribution with DF
     degrees of freedom.

     If R is omitted, a value of 0 is assumed.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `RR * B != R'.  If ALT is `">"',
     the one-sided alternative `RR * B > R' is used.  Similarly for
     "<", the one-sided alternative `RR * B < R' is used.  The default
     is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
table
{
`table' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/table.m

 -- Function File: [T, L_X] = table (X)
 -- Function File: [T, L_X, L_Y] = table (X, Y)
     Create a contingency table T from data vectors.  The L vectors are
     the corresponding levels.

     Currently, only 1- and 2-dimensional tables are supported.
}

#
tan
{
`tan' is a built-in function

 -- Mapping Function:  tan (Z)
     Compute the tangent for each element of X in radians.

     See also: atan, tand, tanh
}

#
tand
{
`tand' is a function from the file /usr/share/octave/3.2.3/m/elfun/tand.m

 -- Function File:  tand (X)
     Compute the tangent for each element of X in degrees.  Returns zero
     for elements where `X/180' is an integer and `Inf' for elements
     where `(X-90)/180' is an integer.

     See also: atand, tan
}

#
tanh
{
`tanh' is a built-in function

 -- Mapping Function:  tanh (X)
     Compute hyperbolic tangent for each element of X.

     See also: atanh, sinh, cosh
}

#
tar
{
`tar' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/tar.m

 -- Function File: ENTRIES = tar (TARFILE, FILES, ROOT)
     Pack FILES FILES into the TAR archive TARFILE.  The list of files
     must be a string or a cell array of strings.

     The optional argument ROOT changes the relative path of FILES from
     the current directory.

     If an output argument is requested the entries in the archive are
     returned in a cell array.

     See also: untar, gzip, gunzip, zip, unzip
}

#
tcdf
{
`tcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/tcdf.m

 -- Function File:  tcdf (X, N)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the t (Student) distribution with N degrees
     of freedom, i.e., PROB (t(N) <= X).
}

#
tempdir
{
`tempdir' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/tempdir.m

 -- Function File: DIR = tempdir ()
     Return the name of the system's directory for temporary files.
}

#
tempname
{
`tempname' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/tempname.m

 -- Function File: filename = tempname ()
     This function is an alias for `tmpnam'.
}

#
terminal_size
{
`terminal_size' is a built-in function

 -- Built-in Function:  terminal_size ()
     Return a two-element row vector containing the current size of the
     terminal window in characters (rows and columns).

     See also: list_in_columns
}

#
test
{
`test' is a function from the file /usr/share/octave/3.2.3/m/testfun/test.m

 -- Function File:  test NAME
 -- Function File:  test NAME quiet|normal|verbose
 -- Function File:  test ('NAME', 'quiet|normal|verbose', FID)
 -- Function File:  test ([], 'explain', FID)
 -- Function File: SUCCESS = test (...)
 -- Function File: [N, MAX] = test (...)
 -- Function File: [CODE, IDX] = test ('NAME','grabdemo')
     Perform tests from the first file in the loadpath matching NAME.
     `test' can be called as a command or as a function.  Called with a
     single argument NAME, the tests are run interactively and stop
     after the first error is encountered.

     With a second argument the tests which are performed and the
     amount of output is selected.

    'quiet'
          Don't report all the tests as they happen, just the errors.

    'normal'
          Report all tests as they happen, but don't do tests which
          require user interaction.

    'verbose'
          Do tests which require user interaction.

     The argument FID can be used to allow batch processing.  Errors
     can be written to the already open file defined by FID, and
     hopefully when Octave crashes this file will tell you what was
     happening when it did.  You can use `stdout' if you want to see
     the results as they happen.  You can also give a file name rather
     than an FID, in which case the contents of the file will be
     replaced with the log from the current test.

     Called with a single output argument SUCCESS, `test' returns true
     if all of the tests were successful.  Called with two output
     arguments N and MAX, the number of successful tests and the total
     number of tests in the file NAME are returned.

     If the second argument is the string 'grabdemo', the contents of
     the demo blocks are extracted but not executed.  Code for all code
     blocks is concatenated and returned as CODE with IDX being a
     vector of positions of the ends of the demo blocks.

     If the second argument is 'explain', then NAME is ignored and an
     explanation of the line markers used is written to the file FID.

     See also: error, assert, fail, demo, example
}

#
texas_lotto
{
`texas_lotto' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/texas_lotto.m

 -- Function File:  texas_lotto ()
     Pick 6 unique numbers between 1 and 50 that are guaranteed to win
     the Texas Lotto.

     See also: rand
}

#
text
{
`text' is a function from the file /usr/share/octave/3.2.3/m/plot/text.m

 -- Function File: H = text (X, Y, LABEL)
 -- Function File: H = text (X, Y, Z, LABEL)
 -- Function File: H = text (X, Y, LABEL, P1, V1, ...)
 -- Function File: H = text (X, Y, Z, LABEL, P1, V1, ...)
     Create a text object with text LABEL at position X, Y, Z on the
     current axes.  Property-value pairs following LABEL may be used to
     specify the appearance of the text.
}

#
tic
{
`tic' is a built-in function

 -- Built-in Function:  tic ()
 -- Built-in Function:  toc ()
     Set or check a wall-clock timer.  Calling `tic' without an output
     argument sets the timer.  Subsequent calls to `toc' return the
     number of seconds since the timer was set.  For example,

          tic ();
          # many computations later...
          elapsed_time = toc ();

     will set the variable `elapsed_time' to the number of seconds since
     the most recent call to the function `tic'.

     If called with one output argument then this function returns a
     scalar of type `uint64' and the wall-clock timer is not started.

          t = tic; sleep (5); (double (tic ()) - double (t)) * 1e-6
              => 5

     Nested timing with `tic' and `toc' is not supported.  Therefore
     `toc' will always return the elapsed time from the most recent
     call to `tic'.

     If you are more interested in the CPU time that your process used,
     you should use the `cputime' function instead.  The `tic' and
     `toc' functions report the actual wall clock time that elapsed
     between the calls.  This may include time spent processing other
     jobs or doing nothing at all.  For example,

          tic (); sleep (5); toc ()
              => 5
          t = cputime (); sleep (5); cputime () - t
              => 0

     (This example also illustrates that the CPU timer may have a fairly
     coarse resolution.)
}

#
tilde_expand
{
`tilde_expand' is a built-in function

 -- Built-in Function:  tilde_expand (STRING)
     Performs tilde expansion on STRING.  If STRING begins with a tilde
     character, (`~'), all of the characters preceding the first slash
     (or all characters, if there is no slash) are treated as a
     possible user name, and the tilde and the following characters up
     to the slash are replaced by the home directory of the named user.
     If the tilde is followed immediately by a slash, the tilde is
     replaced by the home directory of the user running Octave.  For
     example,

          tilde_expand ("~joeuser/bin")
              => "/home/joeuser/bin"
          tilde_expand ("~/bin")
              => "/home/jwe/bin"
}

#
time
{
`time' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/time.oct

 -- Loadable Function:  time ()
     Return the current time as the number of seconds since the epoch.
     The epoch is referenced to 00:00:00 CUT (Coordinated Universal
     Time) 1 Jan 1970.  For example, on Monday February 17, 1997 at
     07:15:06 CUT, the value returned by `time' was 856163706.

     See also: strftime, strptime, localtime, gmtime, mktime, now,
     date, clock, datenum, datestr, datevec, calendar, weekday
}

#
times
{
`times' is a built-in function

 -- Built-in Function:  times (X, Y)
     This function is equivalent to `x .* y'.
}

#
tinv
{
`tinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/tinv.m

 -- Function File:  tinv (X, N)
     For each probability value X, compute the inverse of the
     cumulative distribution function (CDF) of the t (Student)
     distribution with degrees of freedom N.  This function is
     analogous to looking in a table for the t-value of a single-tailed
     distribution.
}

#
title
{
`title' is a function from the file /usr/share/octave/3.2.3/m/plot/title.m

 -- Function File:  title (TITLE)
 -- Function File:  title (TITLE, P1, V1, ...)
     Create a title object and return a handle to it.
}

#
tmpfile
{
`tmpfile' is a built-in function

 -- Built-in Function: [FID, MSG] = tmpfile ()
     Return the file ID corresponding to a new temporary file with a
     unique name.  The file is opened in binary read/write (`"w+b"')
     mode.  The file will be deleted automatically when it is closed or
     when Octave exits.

     If successful, FID is a valid file ID and MSG is an empty string.
     Otherwise, FID is -1 and MSG contains a system-dependent error
     message.

     See also: tmpnam, mkstemp, P_tmpdir
}

#
tmpnam
{
`tmpnam' is a built-in function

 -- Built-in Function:  tmpnam (DIR, PREFIX)
     Return a unique temporary file name as a string.

     If PREFIX is omitted, a value of `"oct-"' is used.  If DIR is also
     omitted, the default directory for temporary files is used.  If
     DIR is provided, it must exist, otherwise the default directory
     for temporary files is used.  Since the named file is not opened,
     by `tmpnam', it is possible (though relatively unlikely) that it
     will not be available by the time your program attempts to open it.

     See also: tmpfile, mkstemp, P_tmpdir
}

#
toascii
{
`toascii' is a built-in function

 -- Mapping Function:  toascii (S)
     Return ASCII representation of S in a matrix.  For example,

          toascii ("ASCII")
              => [ 65, 83, 67, 73, 73 ]


     See also: char
}

#
toc
{
`toc' is a built-in function

 -- Built-in Function:  toc ()
     See tic.
}

#
toeplitz
{
`toeplitz' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/toeplitz.m

 -- Function File:  toeplitz (C, R)
     Return the Toeplitz matrix constructed given the first column C,
     and (optionally) the first row R.  If the first element of C is
     not the same as the first element of R, the first element of C is
     used.  If the second argument is omitted, the first row is taken
     to be the same as the first column.

     A square Toeplitz matrix has the form:

          c(0)  r(1)   r(2)  ...  r(n)
          c(1)  c(0)   r(1)  ... r(n-1)
          c(2)  c(1)   c(0)  ... r(n-2)
           .     ,      ,   .      .
           .     ,      ,     .    .
           .     ,      ,       .  .
          c(n) c(n-1) c(n-2) ...  c(0)

     See also: hankel, vander, sylvester_matrix, hilb, invhilb
}

#
tolower
{
`tolower' is a built-in function

 -- Mapping Function:  tolower (S)
 -- Mapping Function:  lower (S)
     Return a copy of the string or cell string S, with each upper-case
     character replaced by the corresponding lower-case one;
     non-alphabetic characters are left unchanged.  For example,

          tolower ("MiXeD cAsE 123")
              => "mixed case 123"

     See also: toupper
}

#
toupper
{
`toupper' is a built-in function

 -- Built-in Function:  toupper (S)
 -- Built-in Function:  upper (S)
     Return a copy of the string or cell string S, with each lower-case
     character replaced by the corresponding upper-case one;
     non-alphabetic characters are left unchanged.  For example,

          toupper ("MiXeD cAsE 123")
              => "MIXED CASE 123"

     See also: tolower
}

#
tpdf
{
`tpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/tpdf.m

 -- Function File:  tpdf (X, N)
     For each element of X, compute the probability density function
     (PDF) at X of the T (Student) distribution with N degrees of
     freedom.
}

#
trace
{
`trace' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/trace.m

 -- Function File:  trace (A)
     Compute the trace of A, `sum (diag (A))'.
}

#
transpose
{
`transpose' is a built-in function

 -- Built-in Function:  transpose (X)
     This function is equivalent to `x.''.
}

#
trapz
{
`trapz' is a function from the file /usr/share/octave/3.2.3/m/general/trapz.m

 -- Function File: Z = trapz (Y)
 -- Function File: Z = trapz (X, Y)
 -- Function File: Z = trapz (..., DIM)
     Numerical integration using trapezoidal method.  `trapz (Y)'
     computes the integral of the Y along the first non-singleton
     dimension.  If the argument X is omitted a equally spaced vector
     is assumed.  `trapz (X, Y)' evaluates the integral with respect to
     X.

     See also: cumtrapz
}

#
treelayout
{
`treelayout' is a function from the file /usr/share/octave/3.2.3/m/sparse/treelayout.m

 -- Function File:  treelayout (TREE)
 -- Function File:  treelayout (TREE, PERMUTATION)
     treelayout lays out a tree or a forest.  The first argument TREE
     is a vector of predecessors, optional parameter PERMUTATION is an
     optional postorder permutation.  The complexity of the algorithm
     is O(n) in terms of time and memory requirements.

     See also: etreeplot, gplot, treeplot
}

#
treeplot
{
`treeplot' is a function from the file /usr/share/octave/3.2.3/m/sparse/treeplot.m

 -- Function File:  treeplot (TREE)
 -- Function File:  treeplot (TREE, LINE_STYLE, EDGE_STYLE)
     Produces a graph of tree or forest.  The first argument is vector
     of predecessors, optional parameters LINE_STYLE and EDGE_STYLE
     define the output style.  The complexity of the algorithm is O(n)
     in terms of is time and memory requirements.

     See also: etreeplot, gplot
}

#
triangle_lw
{
`triangle_lw' is a function from the file /usr/share/octave/3.2.3/m/signal/triangle_lw.m

 -- Function File:  triangle_lw (N, B)
     Triangular lag window.  Subfunction used for spectral density
     estimation.
}

#
triangle_sw
{
`triangle_sw' is a function from the file /usr/share/octave/3.2.3/m/signal/triangle_sw.m

 -- Function File:  triangle_sw (N, B)
     Triangular spectral window.  Subfunction used for spectral density
     estimation.
}

#
tril
{
`tril' is a function from the file /usr/share/octave/3.2.3/m/general/tril.m

 -- Function File:  tril (A, K)
 -- Function File:  triu (A, K)
     Return a new matrix formed by extracting the lower (`tril') or
     upper (`triu') triangular part of the matrix A, and setting all
     other elements to zero.  The second argument is optional, and
     specifies how many diagonals above or below the main diagonal
     should also be set to zero.

     The default value of K is zero, so that `triu' and `tril' normally
     include the main diagonal as part of the result matrix.

     If the value of K is negative, additional elements above (for
     `tril') or below (for `triu') the main diagonal are also selected.

     The absolute value of K must not be greater than the number of
     sub- or super-diagonals.

     For example,

          tril (ones (3), -1)
               =>  0  0  0
                   1  0  0
                   1  1  0

     and

          tril (ones (3), 1)
               =>  1  1  0
                   1  1  1
                   1  1  1

     See also: triu, diag
}

#
trimesh
{
`trimesh' is a function from the file /usr/share/octave/3.2.3/m/geometry/trimesh.m

 -- Function File:  trimesh (TRI, X, Y, Z)
 -- Function File: H = trimesh (...)
     Plot a triangular mesh in 3D.  The variable TRI is the triangular
     meshing of the points `(X, Y)' which is returned from `delaunay'.
     The variable Z is value at the point `(X, Y)'.  The output
     argument H is the graphic handle to the plot.

     See also: triplot, delaunay3
}

#
triplequad
{
`triplequad' is a function from the file /usr/share/octave/3.2.3/m/general/triplequad.m

 -- Function File:  triplequad (F, XA, XB, YA, YB, ZA, ZB, TOL, QUADF,
          ...)
     Numerically evaluate a triple integral.  The function over which to
     integrate is defined by `F', and the interval for the integration
     is defined by `[XA, XB, YA, YB, ZA, ZB]'.  The function F must
     accept a vector X and a scalar Y, and return a vector of the same
     length as X.

     If defined, TOL defines the absolute tolerance to which to which
     to integrate each sub-integral.

     Additional arguments, are passed directly to F.  To use the default
     value for TOL one may pass an empty matrix.

     See also: dblquad, quad, quadv, quadl, quadgk, trapz
}

#
triplot
{
`triplot' is a function from the file /usr/share/octave/3.2.3/m/geometry/triplot.m

 -- Function File:  triplot (TRI, X, Y)
 -- Function File:  triplot (TRI, X, Y, LINESPEC)
 -- Function File: H = triplot (...)
     Plot a triangular mesh in 2D.  The variable TRI is the triangular
     meshing of the points `(X, Y)' which is returned from `delaunay'.
     If given, the LINESPEC determines the properties to use for the
     lines.  The output argument H is the graphic handle to the plot.

     See also: plot, trimesh, delaunay
}

#
trisurf
{
`trisurf' is a function from the file /usr/share/octave/3.2.3/m/geometry/trisurf.m

 -- Function File:  trisurf (TRI, X, Y, Z)
 -- Function File: H = trisurf (...)
     Plot a triangular surface in 3D.  The variable TRI is the
     triangular meshing of the points `(X, Y)' which is returned from
     `delaunay'.  The variable Z is value at the point `(X, Y)'.  The
     output argument H is the graphic handle to the plot.

     See also: triplot, delaunay3
}

#
triu
{
`triu' is a function from the file /usr/share/octave/3.2.3/m/general/triu.m

 -- Function File:  triu (A, K)
     See tril.
}

#
trnd
{
`trnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/trnd.m

 -- Function File:  trnd (N, R, C)
 -- Function File:  trnd (N, SZ)
     Return an R by C matrix of random samples from the t (Student)
     distribution with N degrees of freedom.  N must be a scalar or of
     size R by C.  Or if SZ is a vector create a matrix of size SZ.

     If R and C are omitted, the size of the result matrix is the size
     of N.
}

#
true
{
`true' is a built-in function

 -- Built-in Function:  true (X)
 -- Built-in Function:  true (N, M)
 -- Built-in Function:  true (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 1.  The arguments are handled the same as the arguments
     for `eye'.
}

#
try
{

 -- Keyword: try
     Begin a try-catch block.

     If an error occurs within a try block, then the catch code will be
     run and execution will proceed after the catch block (though it is
     often recommended to use the lasterr function to re-throw the
     error after cleanup is completed).

     See also: catch, unwind_protect
}

#
tsearch
{
`tsearch' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/tsearch.oct

 -- Loadable Function: IDX = tsearch (X, Y, T, XI, YI)
     Searches for the enclosing Delaunay convex hull.  For `T =
     delaunay (X, Y)', finds the index in T containing the points `(XI,
     YI)'.  For points outside the convex hull, IDX is NaN.

     See also: delaunay, delaunayn
}

#
tsearchn
{
`tsearchn' is a function from the file /usr/share/octave/3.2.3/m/geometry/tsearchn.m

 -- Function File: [IDX, P] = tsearchn (X, T, XI)
     Searches for the enclosing Delaunay convex hull.  For `T =
     delaunayn (X)', finds the index in T containing the points XI.
     For points outside the convex hull, IDX is NaN.  If requested
     `tsearchn' also returns the Barycentric coordinates P of the
     enclosing triangles.

     See also: delaunay, delaunayn
}

#
type
{
`type' is a function from the file /usr/share/octave/3.2.3/m/help/type.m

 -- Command: type options name ...
     Display the definition of each NAME that refers to a function.

     Normally also displays whether each NAME is user-defined or
     built-in; the `-q' option suppresses this behavior.

     If an output argument is requested nothing is displayed.  Instead,
     a cell array of strings is returned, where each element
     corresponds to the definition of each requested function.
}

#
typecast
{
`typecast' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/typecast.oct

 -- Loadable Function:  typecast (X, TYPE)
     Convert from one datatype to another without changing the
     underlying data.  The argument TYPE defines the type of the return
     argument and must be one of 'uint8', 'uint16', 'uint32', 'uint64',
     'int8', 'int16', 'int32', 'int64', 'single' or 'double'.

     An example of the use of typecast on a little-endian machine is

          X = uint16 ([1, 65535]);
          typecast (X, 'uint8')
          => [   0,   1, 255, 255]

     See also: cast, swapbytes
}

#
typeinfo
{
`typeinfo' is a built-in function

 -- Built-in Function:  typeinfo (EXPR)
     Return the type of the expression EXPR, as a string.  If EXPR is
     omitted, return an array of strings containing all the currently
     installed data types.
}

#
u_test
{
`u_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/u_test.m

 -- Function File: [PVAL, Z] = u_test (X, Y, ALT)
     For two samples X and Y, perform a Mann-Whitney U-test of the null
     hypothesis PROB (X > Y) == 1/2 == PROB (X < Y).  Under the null,
     the test statistic Z approximately follows a standard normal
     distribution.  Note that this test is equivalent to the Wilcoxon
     rank-sum test.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative PROB (X > Y) != 1/2.  If ALT is
     `">"', the one-sided alternative PROB (X > Y) > 1/2 is considered.
     Similarly for `"<"', the one-sided alternative PROB (X > Y) < 1/2
     is considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
uint16
{
`uint16' is a built-in function

 -- Built-in Function:  uint16 (X)
     Convert X to unsigned 16-bit integer type.
}

#
uint32
{
`uint32' is a built-in function

 -- Built-in Function:  uint32 (X)
     Convert X to unsigned 32-bit integer type.
}

#
uint64
{
`uint64' is a built-in function

 -- Built-in Function:  uint64 (X)
     Convert X to unsigned 64-bit integer type.
}

#
uint8
{
`uint8' is a built-in function

 -- Built-in Function:  uint8 (X)
     Convert X to unsigned 8-bit integer type.
}

#
umask
{
`umask' is a built-in function

 -- Built-in Function:  umask (MASK)
     Set the permission mask for file creation.  The parameter MASK is
     an integer, interpreted as an octal number.  If successful,
     returns the previous value of the mask (as an integer to be
     interpreted as an octal number); otherwise an error message is
     printed.
}

#
uminus
{
`uminus' is a built-in function

 -- Built-in Function:  uminus (X)
     This function is equivalent to `- x'.
}

#
uname
{
`uname' is a built-in function

 -- Built-in Function: [UTS, ERR, MSG] = uname ()
     Return system information in the structure.  For example,

          uname ()
              => {
                    sysname = x86_64
                    nodename = segfault
                    release = 2.6.15-1-amd64-k8-smp
                    version = Linux
                    machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006
                  }

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.
}

#
undo_string_escapes
{
`undo_string_escapes' is a built-in function

 -- Built-in Function:  undo_string_escapes (S)
     Converts special characters in strings back to their escaped
     forms.  For example, the expression

          bell = "\a";

     assigns the value of the alert character (control-g, ASCII code 7)
     to the string variable `bell'.  If this string is printed, the
     system will ring the terminal bell (if it is possible).  This is
     normally the desired outcome.  However, sometimes it is useful to
     be able to print the original representation of the string, with
     the special characters replaced by their escape sequences.  For
     example,

          octave:13> undo_string_escapes (bell)
          ans = \a

     replaces the unprintable alert character with its printable
     representation.
}

#
unidcdf
{
`unidcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unidcdf.m

 -- Function File:  unidcdf (X, V)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of a univariate discrete distribution which
     assumes the values in V with equal probability.
}

#
unidinv
{
`unidinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unidinv.m

 -- Function File:  unidinv (X, V)
     For each component of X, compute the quantile (the inverse of the
     CDF) at X of the univariate discrete distribution which assumes the
     values in V with equal probability
}

#
unidpdf
{
`unidpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unidpdf.m

 -- Function File:  unidpdf (X, V)
     For each element of X, compute the probability density function
     (PDF) at X of a univariate discrete distribution which assumes the
     values in V with equal probability.
}

#
unidrnd
{
`unidrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unidrnd.m

 -- Function File:  unidrnd (MX);
 -- Function File:  unidrnd (MX, V);
 -- Function File:  unidrnd (MX, M, N, ...);
     Return random values from discrete uniform distribution, with
     maximum value(s) given by the integer MX, which may be a scalar or
     multidimensional array.

     If MX is a scalar, the size of the result is specified by the
     vector V, or by the optional arguments M, N, ....  Otherwise, the
     size of the result is the same as the size of MX.
}

#
unifcdf
{
`unifcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unifcdf.m

 -- Function File:  unifcdf (X, A, B)
     Return the CDF at X of the uniform distribution on [A, B], i.e.,
     PROB (uniform (A, B) <= x).

     Default values are A = 0, B = 1.
}

#
unifinv
{
`unifinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unifinv.m

 -- Function File:  unifinv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the uniform distribution on [A, B].

     Default values are A = 0, B = 1.
}

#
uniform_cdf
{
`uniform_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/uniform_cdf.m

 -- Function File:  uniform_cdf (X, A, B)
     Return the CDF at X of the uniform distribution on [A, B], i.e.,
     PROB (uniform (A, B) <= x).

     Default values are A = 0, B = 1.
}

#
uniform_inv
{
`uniform_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/uniform_inv.m

 -- Function File:  uniform_inv (X, A, B)
     For each element of X, compute the quantile (the inverse of the
     CDF) at X of the uniform distribution on [A, B].

     Default values are A = 0, B = 1.
}

#
uniform_pdf
{
`uniform_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/uniform_pdf.m

 -- Function File:  uniform_pdf (X, A, B)
     For each element of X, compute the PDF at X of the uniform
     distribution on [A, B].

     Default values are A = 0, B = 1.
}

#
uniform_rnd
{
`uniform_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/uniform_rnd.m

 -- Function File:  uniform_rnd (A, B, R, C)
 -- Function File:  uniform_rnd (A, B, SZ)
     Return an R by C or a `size (SZ)' matrix of random samples from
     the uniform distribution on [A, B].  Both A and B must be scalar
     or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of A and B.
}

#
unifpdf
{
`unifpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unifpdf.m

 -- Function File:  unifpdf (X, A, B)
     For each element of X, compute the PDF at X of the uniform
     distribution on [A, B].

     Default values are A = 0, B = 1.
}

#
unifrnd
{
`unifrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/unifrnd.m

 -- Function File:  unifrnd (A, B, R, C)
 -- Function File:  unifrnd (A, B, SZ)
     Return an R by C or a `size (SZ)' matrix of random samples from
     the uniform distribution on [A, B].  Both A and B must be scalar
     or of size R by C.

     If R and C are omitted, the size of the result matrix is the
     common size of A and B.
}

#
union
{
`union' is a function from the file /usr/share/octave/3.2.3/m/set/union.m

 -- Function File:  union (A, B)
 -- Function File:  union (A, B, "rows")
     Return the set of elements that are in either of the sets A and B.
     For example,

          union ([1, 2, 4], [2, 3, 5])
               => [1, 2, 3, 4, 5]

     If the optional third input argument is the string "rows" each row
     of the matrices A and B will be considered an element of sets.
     For example,
          union([1, 2; 2, 3], [1, 2; 3, 4], "rows")
               =>  1   2
              2   3
              3   4

 -- Function File: [C, IA, IB] = union (A, B)
     Return index vectors IA and IB such that `a == c(ia)' and `b ==
     c(ib)'.

     See also: intersect, complement, unique
}

#
unique
{
`unique' is a function from the file /usr/share/octave/3.2.3/m/set/unique.m

 -- Function File:  unique (X)
 -- Function File:  unique (X, "rows")
 -- Function File:  unique (..., "first")
 -- Function File:  unique (..., "last")
 -- Function File: [Y, I, J] = unique (...)
     Return the unique elements of X, sorted in ascending order.  If X
     is a row vector, return a row vector, but if X is a column vector
     or a matrix return a column vector.

     If the optional argument `"rows"' is supplied, return the unique
     rows of X, sorted in ascending order.

     If requested, return index vectors I and J such that `x(i)==y' and
     `y(j)==x'.

     Additionally, one of `"first"' or `"last"' may be given as an
     argument.  If `"last"' is specified, return the highest possible
     indices in I, otherwise, if `"first"' is specified, return the
     lowest.  The default is `"last"'.

     See also: union, intersect, setdiff, setxor, ismember
}

#
unix
{
`unix' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/unix.m

 -- Function File: [STATUS, TEXT] unix (COMMAND)
 -- Function File: [STATUS, TEXT] unix (COMMAND, "-echo")
     Execute a system command if running under a Unix-like operating
     system, otherwise do nothing.  Return the exit status of the
     program in STATUS and any output sent to the standard output in
     TEXT.  If the optional second argument `"-echo"' is given, then
     also send the output from the command to the standard output.

     See also: isunix, ispc, system
}

#
unlink
{
`unlink' is a built-in function

 -- Built-in Function: [ERR, MSG] = unlink (FILE)
     Delete the file named FILE.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.
}

#
unmark_command
{
`unmark_command' is a function from the file /usr/share/octave/3.2.3/m/deprecated/unmark_command.m

 -- Built-in Function:  unmark_command (NAME)
     This function is obsolete and will be removed from a future
     version of Octave.
}

#
unmark_rawcommand
{
`unmark_rawcommand' is a function from the file /usr/share/octave/3.2.3/m/deprecated/unmark_rawcommand.m

 -- Built-in Function:  unmark_rawcommand (NAME)
     This function is obsolete and will be removed from a future
     version of Octave.
}

#
unmkpp
{
`unmkpp' is a function from the file /usr/share/octave/3.2.3/m/polynomial/unmkpp.m

 -- Function File: [X, P, N, K, D] = unmkpp (PP)
     Extract the components of a piece-wise polynomial structure PP.
     These are as follows:

    X
          Sample points.

    P
          Polynomial coefficients for points in sample interval.  `P
          (I, :)' contains the coefficients for the polynomial over
          interval I ordered from highest to lowest.  If `D > 1', `P
          (R, I, :)' contains the coefficients for the r-th polynomial
          defined on interval I.  However, this is stored as a 2-D
          array such that `C = reshape (P (:, J), N, D)' gives `C (I,
          R)' is the j-th coefficient of the r-th polynomial over the
          i-th interval.

    N
          Number of polynomial pieces.

    K
          Order of the polynomial plus 1.

    D
          Number of polynomials defined for each interval.

     See also: mkpp, ppval, spline
}

#
unpack
{
`unpack' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/unpack.m

 -- Function File: FILES = unpack (FILE, DIR)
 -- Function File: FILES = unpack (FILE, DIR, FILETYPE)
     Unpack the archive FILE based on its extension to the directory
     DIR.  If FILE is a cellstr, then all files will be handled
     individually.  If DIR is not specified, it defaults to the current
     directory.  It returns a list of FILES unpacked.  If a directory
     is in the file list, then the FILETYPE to unpack must also be
     specified.

     The FILES includes the entire path to the output files.

     See also: bunzip2, tar, untar, gzip, gunzip, zip, unzip
}

#
untar
{
`untar' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/untar.m

 -- Function File:  untar (TARFILE, DIR)
     Unpack the TAR archive TARFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: unpack, bunzip2, tar, gzip, gunzip, zip, unzip
}

#
until
{

 -- Keyword: until
     End a do-until loop.

     See also: do
}

#
unwind_protect
{

 -- Keyword: unwind_protect
     Begin an unwind_protect block.

     If an error occurs within the first part of an unwind_protect block
     the commands within the unwind_protect_cleanup block are executed
     before the error is thrown.  If an error is not thrown, then the
     unwind_protect_cleanup block is still executed (in other words, the
     unwind_protect_cleanup will be run with or without an error in the
     unwind_protect block).

     See also: unwind_protect_cleanup, try
}

#
unwind_protect_cleanup
{

 -- Keyword: unwind_protect_cleanup
     Begin the cleanup section of an unwind_protect block.

     See also: unwind_protect
}

#
unwrap
{
`unwrap' is a function from the file /usr/share/octave/3.2.3/m/signal/unwrap.m

 -- Function File: B = unwrap (A, TOL, DIM)
     Unwrap radian phases by adding multiples of 2*pi as appropriate to
     remove jumps greater than TOL.  TOL defaults to pi.

     Unwrap will unwrap along the first non-singleton dimension of A,
     unless the optional argument DIM is given, in which case the data
     will be unwrapped along this dimension
}

#
unzip
{
`unzip' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/unzip.m

 -- Function File:  unzip (ZIPFILE, DIR)
     Unpack the ZIP archive ZIPFILE to the directory DIR.  If DIR is
     not specified, it defaults to the current directory.

     See also: unpack, bunzip2, tar, untar, gzip, gunzip, zip
}

#
uplus
{
`uplus' is a built-in function

 -- Built-in Function:  uplus (X)
     This function is equivalent to `+ x'.
}

#
upper
{
`upper' is a built-in function

 -- Built-in Function:  toupper (S)
 -- Built-in Function:  upper (S)
     Return a copy of the string or cell string S, with each lower-case
     character replaced by the corresponding upper-case one;
     non-alphabetic characters are left unchanged.  For example,

          toupper ("MiXeD cAsE 123")
              => "MIXED CASE 123"

     See also: tolower
}

#
urlread
{
`urlread' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/urlwrite.oct

 -- Loadable Function: S = urlread (URL)
 -- Loadable Function: [S, SUCCESS] = urlread (URL)
 -- Loadable Function: [S, SUCCESS, MESSAGE] = urlread (URL)
 -- Loadable Function: [...] = urlread (URL, METHOD, PARAM)
     Download a remote file specified by its URL and return its content
     in string S.  For example,

          s = urlread ("ftp://ftp.octave.org/pub/octave/README");

     The variable SUCCESS is 1 if the download was successful,
     otherwise it is 0 in which case MESSAGE contains an error message.
     If no output argument is specified and if an error occurs, then
     the error is signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL.  For example,

          s = urlread ("http://user:password@example.com/file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is either `get' or `post' and PARAM is a cell
     array of parameter and value pairs.  For example,

          s = urlread ("http://www.google.com/search", "get",
                      {"query", "octave"});

     See also: urlwrite
}

#
urlwrite
{
`urlwrite' is a function from the file /usr/lib/octave/3.2.3/oct/i486-pc-linux-gnu/urlwrite.oct

 -- Loadable Function:  urlwrite (URL, LOCALFILE)
 -- Loadable Function: F = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS] = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS, MESSAGE] = urlwrite (URL, LOCALFILE)
     Download a remote file specified by its URL and save it as
     LOCALFILE.  For example,

          urlwrite ("ftp://ftp.octave.org/pub/octave/README",
                   "README.txt");

     The full path of the downloaded file is returned in F.  The
     variable SUCCESS is 1 if the download was successful, otherwise it
     is 0 in which case MESSAGE contains an error message.  If no
     output argument is specified and if an error occurs, then the
     error is signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL, for example:

          urlwrite ("http://username:password@example.com/file.txt",
                   "file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is either `get' or `post' and PARAM is a cell
     array of parameter and value pairs.  For example:

          urlwrite ("http://www.google.com/search", "search.html",
                   "get", {"query", "octave"});

     See also: urlread
}

#
usage
{
`usage' is a built-in function

 -- Built-in Function:  usage (MSG)
     Print the message MSG, prefixed by the string `usage: ', and set
     Octave's internal error state such that control will return to the
     top level without evaluating any more commands.  This is useful for
     aborting from functions.

     After `usage' is evaluated, Octave will print a traceback of all
     the function calls leading to the usage message.

     You should use this function for reporting problems errors that
     result from an improper call to a function, such as calling a
     function with an incorrect number of arguments, or with arguments
     of the wrong type.  For example, most functions distributed with
     Octave begin with code like this

          if (nargin != 2)
           usage ("foo (a, b)");
          endif

     to check for the proper number of arguments.
}

#
usleep
{
`usleep' is a built-in function

 -- Built-in Function:  usleep (MICROSECONDS)
     Suspend the execution of the program for the given number of
     microseconds.  On systems where it is not possible to sleep for
     periods of time less than one second, `usleep' will pause the
     execution for `round (MICROSECONDS / 1e6)' seconds.
}

#
validatestring
{
`validatestring' is a function from the file /usr/share/octave/3.2.3/m/strings/validatestring.m

 -- Function File: VALIDSTR = validatestring (STR, STRARRAY)
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME)
 -- Function File: VALIDSTR = validatestring (STR, STRARRAY, FUNCNAME,
          VARNAME)
 -- Function File: VALIDSTR = validatestring (..., POSITION)
     Verify that STR is a string or substring of an element of STRARRAY.

     STR is a character string to be tested, and STRARRAY is a cellstr
     of valid values.  VALIDSTR will be the validated form of STR where
     validation is defined as STR being a member or substring of
     VALIDSTR.  If STR is a substring of VALIDSTR and there are
     multiple matches, the shortest match will be returned if all
     matches are substrings of each other, and an error will be raised
     if the matches are not substrings of each other.

     All comparisons are case insensitive.

     See also: strcmp, strcmpi
}

#
values
{
`values' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/values.m

 -- Function File:  values (X)
     Return the different values in a column vector, arranged in
     ascending order.

     As an example, `values([1, 2, 3, 1])' returns the vector `[1, 2,
     3]'.
}

#
vander
{
`vander' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/vander.m

 -- Function File:  vander (C, N)
     Return the Vandermonde matrix whose next to last column is C.  If
     N is specified, it determines the number of columns; otherwise, N
     is taken to be equal to the length of C.

     A Vandermonde matrix has the form:

          c(1)^(n-1) ... c(1)^2  c(1)  1
          c(2)^(n-1) ... c(2)^2  c(2)  1
              .     .      .      .    .
              .       .    .      .    .
              .         .  .      .    .
          c(n)^(n-1) ... c(n)^2  c(n)  1

     See also: hankel, sylvester_matrix, hilb, invhilb, toeplitz
}

#
var
{
`var' is a function from the file /usr/share/octave/3.2.3/m/statistics/base/var.m

 -- Function File:  var (X)
     For vector arguments, return the (real) variance of the values.
     For matrix arguments, return a row vector containing the variance
     for each column.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          Normalizes with N-1, provides the best unbiased estimator of
          the variance [default].

    1:
          Normalizes with N, this provides the second moment around the
          mean.

     The third argument DIM determines the dimension along which the
     variance is calculated.
}

#
var_test
{
`var_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/var_test.m

 -- Function File: [PVAL, F, DF_NUM, DF_DEN] = var_test (X, Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and unknown variances, perform an F-test of the null
     hypothesis of equal variances.  Under the null, the test statistic
     F follows an F-distribution with DF_NUM and DF_DEN degrees of
     freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `var (X) != var (Y)'.  If ALT is
     `">"', the one-sided alternative `var (X) > var (Y)' is used.
     Similarly for "<", the one-sided alternative `var (X) > var (Y)'
     is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
varargin
{

 -- Keyword: varargin
     Pass an arbitrary number of arguments into a function.

     See also: varargout, nargin, nargout
}

#
varargout
{

 -- Keyword: varargout
     Pass an arbitrary number of arguments out of a function.

     See also: varargin, nargin, nargout
}

#
vec
{
`vec' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/vec.m

 -- Function File:  vec (X)
     Return the vector obtained by stacking the columns of the matrix X
     one above the other.
}

#
vech
{
`vech' is a function from the file /usr/share/octave/3.2.3/m/linear-algebra/vech.m

 -- Function File:  vech (X)
     Return the vector obtained by eliminating all supradiagonal
     elements of the square matrix X and stacking the result one column
     above the other.
}

#
vectorize
{
`vectorize' is a built-in function

 -- Built-in Function:  vectorize (FUN)
     Create a vectorized version of the inline function FUN by
     replacing all occurrences of `*', `/', etc., with `.*', `./', etc.
}

#
ver
{
`ver' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/ver.m

 -- Function File:  ver ()
     Display a header containing the current Octave version number,
     license string and operating system, followed by the installed
     package names, versions, and installation directories.

 -- Function File: v = ver ()
     Return a vector of structures, respecting Octave and each
     installed package.  The structure includes the following fields.

    `Name'
          Package name.

    `Version'
          Version of the package.

    `Revision'
          Revision of the package.

    `Date'
          Date respecting the version/revision.

 -- Function File: v = ver (`"Octave"')
     Return version information for Octave only..

 -- Function File: v = ver (PKG)
     Return version information for the specified package PKG.

     See also: license, version
}

#
version
{
`version' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/version.m

 -- Function File:  version ()
     Return Octave's version number as a string.  This is also the
     value of the built-in variable `OCTAVE_VERSION'.
}

#
vertcat
{
`vertcat' is a built-in function

 -- Built-in Function:  vertcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the vertical concatenation of N-d array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 1.

     See also: cat, horzcat
}

#
view
{
`view' is a function from the file /usr/share/octave/3.2.3/m/plot/view.m

 -- Function File:  view (AZIMUTH, ELEVATION)
 -- Function File:  view (DIMS)
 -- Function File: [AZIMUTH, ELEVATION] = view ()
     Set or get the viewpoint for the current axes.
}

#
voronoi
{
`voronoi' is a function from the file /usr/share/octave/3.2.3/m/geometry/voronoi.m

 -- Function File:  voronoi (X, Y)
 -- Function File:  voronoi (X, Y, "plotstyle")
 -- Function File:  voronoi (X, Y, "plotstyle", OPTIONS)
 -- Function File: [VX, VY] = voronoi (...)
     plots voronoi diagram of points `(X, Y)'.  The voronoi facets with
     points at infinity are not drawn.  [VX, VY] = voronoi(...) returns
     the vertices instead of plotting the diagram. plot (VX, VY) shows
     the voronoi diagram.

     A fourth optional argument, which must be a string, contains extra
     options passed to the underlying qhull command.  See the
     documentation for the Qhull library for details.

            x = rand (10, 1);
            y = rand (size (x));
            h = convhull (x, y);
            [vx, vy] = voronoi (x, y);
            plot (vx, vy, "-b", x, y, "o", x(h), y(h), "-g")
            legend ("", "points", "hull");

     See also: voronoin, delaunay, convhull
}

#
voronoin
{
`voronoin' is a function from the file /usr/share/octave/3.2.3/m/geometry/voronoin.m

 -- Function File: [C, F] = voronoin (PTS)
 -- Function File: [C, F] = voronoin (PTS, OPTIONS)
     computes n- dimensional voronoi facets.  The input matrix PTS of
     size [n, dim] contains n points of dimension dim.  C contains the
     points of the voronoi facets.  The list F contains for each facet
     the indices of the voronoi points.

     A second optional argument, which must be a string, contains extra
     options passed to the underlying qhull command.  See the
     documentation for the Qhull library for details.

     See also: voronoin, delaunay, convhull
}

#
waitforbuttonpress
{
`waitforbuttonpress' is a function from the file /usr/share/octave/3.2.3/m/plot/waitforbuttonpress.m

 -- Function File: B = waitforbuttonpress ()
     Wait for button or mouse press.over a figure window.  The value of
     B returns 0 if a mouse button was pressed or 1 is a key was
     pressed.

     See also: ginput
}

#
waitpid
{
`waitpid' is a built-in function

 -- Built-in Function: [PID, STATUS, MSG] = waitpid (PID, OPTIONS)
     Wait for process PID to terminate.  The PID argument can be:

    -1
          Wait for any child process.

    0
          Wait for any child process whose process group ID is equal to
          that of the Octave interpreter process.

    > 0
          Wait for termination of the child process with ID PID.

     The OPTIONS argument can be a bitwise OR of zero or more of the
     following constants:

    `0'
          Wait until signal is received or a child process exits (this
          is the default if the OPTIONS argument is missing).

    `WNOHANG'
          Do not hang if status is not immediately available.

    `WUNTRACED'
          Report the status of any child processes that are stopped,
          and whose status has not yet been reported since they stopped.

    `WCONTINUE'
          Return if a stopped child has been resumed by delivery of
          `SIGCONT'.  This value may not be meaningful on all systems.

     If the returned value of PID is greater than 0, it is the process
     ID of the child process that exited.  If an error occurs, PID will
     be less than zero and MSG will contain a system-dependent error
     message.  The value of STATUS contains additional system-dependent
     information about the subprocess that exited.

     See also: WCONTINUE, WCOREDUMP, WEXITSTATUS, WIFCONTINUED,
     WIFSIGNALED, WIFSTOPPED, WNOHANG, WSTOPSIG, WTERMSIG, WUNTRACED
}

#
warning
{
`warning' is a built-in function

 -- Built-in Function:  warning (TEMPLATE, ...)
 -- Built-in Function:  warning (ID, TEMPLATE, ...)
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the `printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the `stderr' stream.  The message is prefixed by the
     character string `warning: '.  You should use this function when
     you want to notify the user of an unusual condition, but only when
     it makes sense for your program to go on.

     The optional message identifier allows users to enable or disable
     warnings tagged by ID.  The special identifier `"all"' may be used
     to set the state of all warnings.

 -- Built-in Function:  warning ("on", ID)
 -- Built-in Function:  warning ("off", ID)
 -- Built-in Function:  warning ("error", ID)
 -- Built-in Function:  warning ("query", ID)
     Set or query the state of a particular warning using the identifier
     ID.  If the identifier is omitted, a value of `"all"' is assumed.
     If you set the state of a warning to `"error"', the warning named
     by ID is handled as if it were an error instead.

     See also: warning_ids
}

#
warning_ids
{
`warning_ids' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/warning_ids.m


`Octave:array-to-scalar'
     If the `Octave:array-to-scalar' warning is enabled, Octave will
     warn when an implicit conversion from an array to a scalar value is
     attempted.  By default, the `Octave:array-to-scalar' warning is
     disabled.

`Octave:array-to-vector'
     If the `Octave:array-to-vector' warning is enabled, Octave will
     warn when an implicit conversion from an array to a vector value is
     attempted.  By default, the `Octave:array-to-vector' warning is
     disabled.

`Octave:assign-as-truth-value'
     If the `Octave:assign-as-truth-value' warning is enabled, a
     warning is issued for statements like

          if (s = t)
            ...

     since such statements are not common, and it is likely that the
     intent was to write

          if (s == t)
            ...

     instead.

     There are times when it is useful to write code that contains
     assignments within the condition of a `while' or `if' statement.
     For example, statements like

          while (c = getc())
            ...

     are common in C programming.

     It is possible to avoid all warnings about such statements by
     disabling the `Octave:assign-as-truth-value' warning, but that may
     also let real errors like

          if (x = 1)  # intended to test (x == 1)!
            ...

     slip by.

     In such cases, it is possible suppress errors for specific
     statements by writing them with an extra set of parentheses.  For
     example, writing the previous example as

          while ((c = getc()))
            ...

     will prevent the warning from being printed for this statement,
     while allowing Octave to warn about other assignments used in
     conditional contexts.

     By default, the `Octave:assign-as-truth-value' warning is enabled.

`Octave:associativity-change'
     If the `Octave:associativity-change' warning is enabled, Octave
     will warn about possible changes in the meaning of some code due
     to changes in associativity for some operators.  Associativity
     changes have typically been made for MATLAB compatibility.  By
     default, the `Octave:associativity-change' warning is enabled.

`Octave:divide-by-zero'
     If the `Octave:divide-by-zero' warning is enabled, a warning is
     issued when Octave encounters a division by zero.  By default, the
     `Octave:divide-by-zero' warning is enabled.

`Octave:empty-list-elements'
     If the `Octave:empty-list-elements' warning is enabled, a warning
     is issued when an empty matrix is found in a matrix list.  For
     example,

          a = [1, [], 3, [], 5]

     By default, the `Octave:empty-list-elements' warning is enabled.

`Octave:fortran-indexing'
     If the `Octave:fortran-indexing' warning is enabled, a warning is
     printed for expressions which select elements of a two-dimensional
     matrix using a single index.  By default, the
     `Octave:fortran-indexing' warning is disabled.

`Octave:function-name-clash'
     If the `Octave:function-name-clash' warning is enabled, a warning
     is issued when Octave finds that the name of a function defined in
     a function file differs from the name of the file.  (If the names
     disagree, the name declared inside the file is ignored.)  By
     default, the `Octave:function-name-clash' warning is enabled.

`Octave:future-time-stamp'
     If the `Octave:future-time-stamp' warning is enabled, Octave will
     print a warning if it finds a function file with a time stamp that
     is in the future.  By default, the `Octave:future-time-stamp'
     warning is enabled.

`Octave:imag-to-real'
     If the `Octave:imag-to-real' warning is enabled, a warning is
     printed for implicit conversions of complex numbers to real
     numbers.  By default, the `Octave:imag-to-real' warning is
     disabled.

`Octave:matlab-incompatible'
     Print warnings for Octave language features that may cause
     compatibility problems with MATLAB.

`Octave:missing-semicolon'
     If the `Octave:missing-semicolon' warning is enabled, Octave will
     warn when statements in function definitions don't end in
     semicolons.  By default the `Octave:missing-semicolon' warning is
     disabled.

`Octave:neg-dim-as-zero'
     If the `Octave:neg-dim-as-zero' warning is enabled, print a warning
     for expressions like

          eye (-1)

     By default, the `Octave:neg-dim-as-zero' warning is disabled.

`Octave:num-to-str'
     If the `Octave:num-to-str' warning is enable, a warning is printed
     for implicit conversions of numbers to their ASCII character
     equivalents when strings are constructed using a mixture of
     strings and numbers in matrix notation.  For example,

          [ "f", 111, 111 ]
               => "foo"
     elicits a warning if the `Octave:num-to-str' warning is enabled.
     By default, the `Octave:num-to-str' warning is enabled.

`Octave:precedence-change'
     If the `Octave:precedence-change' warning is enabled, Octave will
     warn about possible changes in the meaning of some code due to
     changes in precedence for some operators.  Precedence changes have
     typically been made for MATLAB compatibility.  By default, the
     `Octave:precedence-change' warning is enabled.

`Octave:reload-forces-clear'
     If several functions have been loaded from the same file, Octave
     must clear all the functions before any one of them can be
     reloaded.  If the `Octave:reload-forces-clear' warning is enabled,
     Octave will warn you when this happens, and print a list of the
     additional functions that it is forced to clear.  By default, the
     `Octave:reload-forces-clear' warning is enabled.

`Octave:resize-on-range-error'
     If the `Octave:resize-on-range-error' warning is enabled, print a
     warning when a matrix is resized by an indexed assignment with
     indices outside the current bounds.  By default, the
     `Octave:resize-on-range-error' warning is disabled.

`Octave:separator-insert'
     Print warning if commas or semicolons might be inserted
     automatically in literal matrices.

`Octave:single-quote-string'
     Print warning if a single quote character is used to introduce a
     string constant.

`Octave:str-to-num'
     If the `Octave:str-to-num' warning is enabled, a warning is printed
     for implicit conversions of strings to their numeric ASCII
     equivalents.  For example,
          "abc" + 0
               => 97 98 99
     elicits a warning if the `Octave:str-to-num' warning is enabled.
     By default, the `Octave:str-to-num' warning is disabled.

`Octave:string-concat'
     If the `Octave:string-concat' warning is enabled, print a warning
     when concatenating a mixture of double and single quoted strings.
     By default, the `Octave:string-concat' warning is disabled.

`Octave:undefined-return-values'
     If the `Octave:undefined-return-values' warning is disabled, print
     a warning if a function does not define all the values in the
     return list which are expected.  By default, the
     `Octave:undefined-return-values' warning is enabled.

`Octave:variable-switch-label'
     If the `Octave:variable-switch-label' warning is enabled, Octave
     will print a warning if a switch label is not a constant or
     constant expression.  By default, the
     `Octave:variable-switch-label' warning is disabled.
}

#
warranty
{
`warranty' is a built-in function

 -- Built-in Function:  warranty ()
     Describe the conditions for copying and distributing Octave.
}

#
wavread
{
`wavread' is a function from the file /usr/share/octave/3.2.3/m/audio/wavread.m

 -- Function File: Y = wavread (FILENAME)
     Load the RIFF/WAVE sound file FILENAME, and return the samples in
     vector Y.  If the file contains multichannel data, then Y is a
     matrix with the channels represented as columns.

 -- Function File: [Y, FS, BITS] = wavread (FILENAME)
     Additionally return the sample rate (FS) in Hz and the number of
     bits per sample (BITS).

 -- Function File: [...] = wavread (FILENAME, N)
     Read only the first N samples from each channel.

 -- Function File: [...] = wavread (FILENAME,[N1 N2])
     Read only samples N1 through N2 from each channel.

 -- Function File: [SAMPLES, CHANNELS] = wavread (FILENAME, "size")
     Return the number of samples (N) and channels (CH) instead of the
     audio data.

     See also: wavwrite
}

#
wavwrite
{
`wavwrite' is a function from the file /usr/share/octave/3.2.3/m/audio/wavwrite.m

 -- Function File:  wavwrite (Y, FILENAME)
 -- Function File:  wavwrite (Y, FS, FILENAME)
 -- Function File:  wavwrite (Y, FS, BITS, FILENAME)
     Write Y to the canonical RIFF/WAVE sound file FILENAME with sample
     rate FS and bits per sample BITS.  The default sample rate is 8000
     Hz with 16-bits per sample.  Each column of the data represents a
     separate channel.

     See also: wavread
}

#
wblcdf
{
`wblcdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/wblcdf.m

 -- Function File:  wblcdf (X, SCALE, SHAPE)
     Compute the cumulative distribution function (CDF) at X of the
     Weibull distribution with shape parameter SCALE and scale
     parameter SHAPE, which is

          1 - exp(-(x/shape)^scale)
     for X >= 0.
}

#
wblinv
{
`wblinv' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/wblinv.m

 -- Function File:  wblinv (X, SCALE, SHAPE)
     Compute the quantile (the inverse of the CDF) at X of the Weibull
     distribution with shape parameter SCALE and scale parameter SHAPE.
}

#
wblpdf
{
`wblpdf' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/wblpdf.m

 -- Function File:  wblpdf (X, SCALE, SHAPE)
     Compute the probability density function (PDF) at X of the Weibull
     distribution with shape parameter SCALE and scale parameter SHAPE
     which is given by

             scale * shape^(-scale) * x^(scale-1) * exp(-(x/shape)^scale)

     for X > 0.
}

#
wblrnd
{
`wblrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/wblrnd.m

 -- Function File:  wblrnd (SCALE, SHAPE, R, C)
 -- Function File:  wblrnd (SCALE, SHAPE, SZ)
     Return an R by C matrix of random samples from the Weibull
     distribution with parameters SCALE and SHAPE which must be scalar
     or of size R by C.  Or if SZ is a vector return a matrix of size
     SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of ALPHA and SIGMA.
}

#
weekday
{
`weekday' is a function from the file /usr/share/octave/3.2.3/m/time/weekday.m

 -- Function File: [N, S] = weekday (D, [FORM])
     Return the day of week as a number in N and a string in S, for
     example `[1, "Sun"]', `[2, "Mon"]', ..., or `[7, "Sat"]'.

     D is a serial date number or a date string.

     If the string FORM is given and is `"long"', S will contain the
     full name of the weekday; otherwise (or if FORM is `"short"'), S
     will contain the abbreviated name of the weekday.

     See also: datenum, datevec, eomday
}

#
weibcdf
{
`weibcdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibcdf.m

 -- Function File:  weibcdf (X, SCALE, SHAPE)
     Compute the cumulative distribution function (CDF) at X of the
     Weibull distribution with shape parameter SCALE and scale
     parameter SHAPE, which is

          1 - exp(-(x/shape)^scale)

     for X >= 0.
}

#
weibinv
{
`weibinv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibinv.m

 -- Function File:  weibinv (X, SCALE, SHAPE)
     Compute the quantile (the inverse of the CDF) at X of the Weibull
     distribution with shape parameter SCALE and scale parameter SHAPE.
}

#
weibpdf
{
`weibpdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibpdf.m

 -- Function File:  weibpdf (X, SCALE, SHAPE)
     Compute the probability density function (PDF) at X of the Weibull
     distribution with shape parameter SCALE and scale parameter SHAPE
     which is given by

             scale * shape^(-scale) * x^(scale-1) * exp(-(x/shape)^scale)

     for X > 0.
}

#
weibrnd
{
`weibrnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibrnd.m

 -- Function File:  weibrnd (SCALE, SHAPE, R, C)
 -- Function File:  weibrnd (SCALE, SHAPE, SZ)
     Return an R by C matrix of random samples from the Weibull
     distribution with parameters SCALE and SHAPE which must be scalar
     or of size R by C.  Or if SZ is a vector return a matrix of size
     SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of ALPHA and SIGMA.
}

#
weibull_cdf
{
`weibull_cdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibull_cdf.m

 -- Function File:  weibull_cdf (X, SHAPE, SCALE)
     Compute the cumulative distribution function (CDF) at X of the
     Weibull distribution with shape parameter SCALE and scale
     parameter SHAPE, which is

          1 - exp(-(x/shape)^scale)

     for X >= 0.
}

#
weibull_inv
{
`weibull_inv' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibull_inv.m

 -- Function File:  weibull_inv (X, SHAPE, SCALE)
     Compute the quantile (the inverse of the CDF) at X of the Weibull
     distribution with shape parameter SCALE and scale parameter SHAPE.
}

#
weibull_pdf
{
`weibull_pdf' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibull_pdf.m

 -- Function File:  weibull_pdf (X, SHAPE, SCALE)
     Compute the probability density function (PDF) at X of the Weibull
     distribution with shape parameter SCALE and scale parameter SHAPE
     which is given by

             scale * shape^(-scale) * x^(scale-1) * exp(-(x/shape)^scale)

     for X > 0.
}

#
weibull_rnd
{
`weibull_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/weibull_rnd.m

 -- Function File:  weibull_rnd (SHAPE, SCALE, R, C)
 -- Function File:  weibull_rnd (SHAPE, SCALE, SZ)
     Return an R by C matrix of random samples from the Weibull
     distribution with parameters SCALE and SHAPE which must be scalar
     or of size R by C.  Or if SZ is a vector return a matrix of size
     SZ.

     If R and C are omitted, the size of the result matrix is the
     common size of ALPHA and SIGMA.
}

#
welch_test
{
`welch_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/welch_test.m

 -- Function File: [PVAL, T, DF] = welch_test (X, Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and unknown and not necessarily equal variances, perform a
     Welch test of the null hypothesis of equal means.  Under the null,
     the test statistic T approximately follows a Student distribution
     with DF degrees of freedom.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `mean (X) != M'.  If ALT is
     `">"', the one-sided alternative mean(x) > M is considered.
     Similarly for `"<"', the one-sided alternative mean(x) < M is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
what
{
`what' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/what.m

 -- Command:  what
 -- Command:  what DIR
 -- Function File: w = what (DIR)
     List the Octave specific files in a directory.  If the variable DIR
     is given then check that directory rather than the current
     directory.  If a return argument is requested, the files found are
     returned in the structure W.

     See also: which
}

#
which
{
`which' is a function from the file /usr/share/octave/3.2.3/m/help/which.m

 -- Command: which name ...
     Display the type of each NAME.  If NAME is defined from a function
     file, the full name of the file is also displayed.

     See also: help, lookfor
}

#
while
{

 -- Keyword: while
     Begin a while loop.

     See also: do
}

#
white
{
`white' is a function from the file /usr/share/octave/3.2.3/m/image/white.m

 -- Function File:  white (N)
     Create color colormap.  This colormap is completely white.  The
     argument N should be a scalar.  If it is omitted, the length of
     the current colormap or 64 is assumed.

     See also: colormap
}

#
who
{
`who' is a built-in function

 -- Command: who
 -- Command: who pattern ...
 -- Command: who option pattern ...
 -- Command: C = who("pattern", ...)
     List currently defined variables matching the given patterns.
     Valid pattern syntax is the same as described for the `clear'
     command.  If no patterns are supplied, all variables are listed.
     By default, only variables visible in the local scope are
     displayed.

     The following are valid options but may not be combined.

    `global'
          List variables in the global scope rather than the current
          scope.

    `-regexp'
          The patterns are considered to be regular expressions when
          matching the variables to display.  The same pattern syntax
          accepted by the `regexp' function is used.

    `-file'
          The next argument is treated as a filename.  All variables
          found within the specified file are listed.  No patterns are
          accepted when reading variables from a file.

     If called as a function, return a cell array of defined variable
     names matching the given patterns.

     See also: whos, regexp
}

#
whos
{
`whos' is a built-in function

 -- Command: whos
 -- Command: whos pattern ...
 -- Command: whos option pattern ...
 -- Command: S = whos("pattern", ...)
     Provide detailed information on currently defined variables
     matching the given patterns.  Options and pattern syntax are the
     same as for the `who' command.  Extended information about each
     variable is summarized in a table with the following default
     entries.

    Attr
          Attributes of the listed variable.  Possible attributes are:
         blank
               Variable in local scope

         `g'
               Variable with global scope

         `p'
               Persistent variable

    Name
          The name of the variable.

    Size
          The logical size of the variable.  A scalar is 1x1, a vector
          is 1xN or Nx1, a 2-D matrix is MxN.

    Bytes
          The amount of memory currently used to store the variable.

    Class
          The class of the variable.  Examples include double, single,
          char, uint16, cell, and struct.

     The table can be customized to display more or less information
     through the function `whos_line_format'.

     If `whos' is called as a function, return a struct array of defined
     variable names matching the given patterns.  Fields in the
     structure describing each variable are: name, size, bytes, class,
     global, sparse, complex, nesting, persistent.

     See also: who, whos_line_format
}

#
whos_line_format
{
`whos_line_format' is a built-in function

 -- Built-in Function: VAL = whos_line_format ()
 -- Built-in Function: OLD_VAL = whos_line_format (NEW_VAL)
     Query or set the format string used by the command `whos'.

     A full format string is:

          %[modifier]<command>[:width[:left-min[:balance]]];

     The following command sequences are available:

    `%a'
          Prints attributes of variables (g=global, p=persistent,
          f=formal parameter, a=automatic variable).

    `%b'
          Prints number of bytes occupied by variables.

    `%c'
          Prints class names of variables.

    `%e'
          Prints elements held by variables.

    `%n'
          Prints variable names.

    `%s'
          Prints dimensions of variables.

    `%t'
          Prints type names of variables.

     Every command may also have an alignment modifier:

    `l'
          Left alignment.

    `r'
          Right alignment (default).

    `c'
          Column-aligned (only applicable to command %s).

     The `width' parameter is a positive integer specifying the minimum
     number of columns used for printing.  No maximum is needed as the
     field will auto-expand as required.

     The parameters `left-min' and `balance' are only available when the
     column-aligned modifier is used with the command `%s'.  `balance'
     specifies the column number within the field width which will be
     aligned between entries.  Numbering starts from 0 which indicates
     the leftmost column.  `left-min' specifies the minimum field width
     to the left of the specified balance column.

     The default format is `"  %a:4; %ln:6; %cs:16:6:1;  %rb:12;
     %lc:-1;\n"'.

     See also: whos
}

#
wiener_rnd
{
`wiener_rnd' is a function from the file /usr/share/octave/3.2.3/m/deprecated/wiener_rnd.m

 -- Function File:  wiener_rnd (T, D, N)
     Return a simulated realization of the D-dimensional Wiener Process
     on the interval [0, T].  If D is omitted, D = 1 is used.  The
     first column of the return matrix contains time, the remaining
     columns contain the Wiener process.

     The optional parameter N gives the number of summands used for
     simulating the process over an interval of length 1.  If N is
     omitted, N = 1000 is used.
}

#
wienrnd
{
`wienrnd' is a function from the file /usr/share/octave/3.2.3/m/statistics/distributions/wienrnd.m

 -- Function File:  wienrnd (T, D, N)
     Return a simulated realization of the D-dimensional Wiener Process
     on the interval [0, T].  If D is omitted, D = 1 is used.  The
     first column of the return matrix contains time, the remaining
     columns contain the Wiener process.

     The optional parameter N gives the number of summands used for
     simulating the process over an interval of length 1.  If N is
     omitted, N = 1000 is used.
}

#
wilcoxon_test
{
`wilcoxon_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/wilcoxon_test.m

 -- Function File: [PVAL, Z] = wilcoxon_test (X, Y, ALT)
     For two matched-pair sample vectors X and Y, perform a Wilcoxon
     signed-rank test of the null hypothesis PROB (X > Y) == 1/2.
     Under the null, the test statistic Z approximately follows a
     standard normal distribution when N > 25.

     *Warning*: This function assumes a normal distribution for Z and
     thus is invalid for N <= 25.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative PROB (X > Y) != 1/2.  If alt is
     `">"', the one-sided alternative PROB (X > Y) > 1/2 is considered.
     Similarly for `"<"', the one-sided alternative PROB (X > Y) < 1/2
     is considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed.
}

#
wilkinson
{
`wilkinson' is a function from the file /usr/share/octave/3.2.3/m/special-matrix/wilkinson.m

 -- Function File:  wilkinson (N)
     Return the Wilkinson matrix of order N.

     See also: hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
              hadamard, rosser, compan, pascal
}

#
winter
{
`winter' is a function from the file /usr/share/octave/3.2.3/m/image/winter.m

 -- Function File:  winter (N)
     Create color colormap.  This colormap is blue to green.  The
     argument N should be a scalar.  If it is omitted, the length of
     the current colormap or 64 is assumed.

     See also: colormap
}

#
xlabel
{
`xlabel' is a function from the file /usr/share/octave/3.2.3/m/plot/xlabel.m

 -- Function File:  xlabel (STRING)
 -- Function File:  ylabel (STRING)
 -- Function File:  zlabel (STRING)
 -- Function File:  xlabel (H, STRING)
     Specify x, y, and z axis labels for the current figure.  If H is
     specified then label the axis defined by H.

     See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
     bar, stairs, title
}

#
xlim
{
`xlim' is a function from the file /usr/share/octave/3.2.3/m/plot/xlim.m

 -- Function File: XL = xlim ()
 -- Function File:  xlim (XL)
 -- Function File: M = xlim ('mode')
 -- Function File:  xlim (M)
 -- Function File:  xlim (H, ...)
     Get or set the limits of the x-axis of the current plot.  Called
     without arguments `xlim' returns the x-axis limits of the current
     plot.  If passed a two element vector XL, the limits of the x-axis
     are set to this value.

     The current mode for calculation of the x-axis can be returned
     with a call `xlim ('mode')', and can be either 'auto' or 'manual'.
     The current plotting mode can be set by passing either 'auto' or
     'manual' as the argument.

     If passed an handle as the first argument, then operate on this
     handle rather than the current axes handle.

     See also: ylim, zlim, set, get, gca
}

#
xor
{
`xor' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/xor.m

 -- Mapping Function:  xor (X, Y)
     Return the `exclusive or' of the entries of X and Y.  For boolean
     expressions X and Y, `xor (X, Y)' is true if and only if X or Y is
     true, but not if both X and Y are true.
}

#
yes_or_no
{
`yes_or_no' is a built-in function

 -- Built-in Function:  yes_or_no (PROMPT)
     Ask the user a yes-or-no question.  Return 1 if the answer is yes.
     Takes one argument, which is the string to display to ask the
     question.  It should end in a space; `yes-or-no-p' adds `(yes or
     no) ' to it.  The user must confirm the answer with RET and can
     edit it until it has been confirmed.
}

#
ylabel
{
`ylabel' is a function from the file /usr/share/octave/3.2.3/m/plot/ylabel.m

 -- Function File:  ylabel (STRING)
 -- Function File:  ylabel (H, STRING)
     See also: xlabel

     .
}

#
ylim
{
`ylim' is a function from the file /usr/share/octave/3.2.3/m/plot/ylim.m

 -- Function File: XL = ylim ()
 -- Function File:  ylim (XL)
 -- Function File: M = ylim ('mode')
 -- Function File:  ylim (M)
 -- Function File:  ylim (H, ...)
     Get or set the limits of the y-axis of the current plot.  Called
     without arguments `ylim' returns the y-axis limits of the current
     plot.  If passed a two element vector XL, the limits of the y-axis
     are set to this value.

     The current mode for calculation of the y-axis can be returned
     with a call `ylim ('mode')', and can be either 'auto' or 'manual'.
     The current plotting mode can be set by passing either 'auto' or
     'manual' as the argument.

     If passed an handle as the first argument, then operate on this
     handle rather than the current axes handle.

     See also: xlim, zlim, set, get, gca
}

#
yulewalker
{
`yulewalker' is a function from the file /usr/share/octave/3.2.3/m/signal/yulewalker.m

 -- Function File: [A, V] = yulewalker (C)
     Fit an AR (p)-model with Yule-Walker estimates given a vector C of
     autocovariances `[gamma_0, ..., gamma_p]'.

     Returns the AR coefficients, A, and the variance of white noise, V.
}

#
z_test
{
`z_test' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/z_test.m

 -- Function File: [PVAL, Z] = z_test (X, M, V, ALT)
     Perform a Z-test of the null hypothesis `mean (X) == M' for a
     sample X from a normal distribution with unknown mean and known
     variance V.  Under the null, the test statistic Z follows a
     standard normal distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `mean (X) != M'.  If ALT is
     `">"', the one-sided alternative `mean (X) > M' is considered.
     Similarly for `"<"', the one-sided alternative `mean (X) < M' is
     considered.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed along with some information.
}

#
z_test_2
{
`z_test_2' is a function from the file /usr/share/octave/3.2.3/m/statistics/tests/z_test_2.m

 -- Function File: [PVAL, Z] = z_test_2 (X, Y, V_X, V_Y, ALT)
     For two samples X and Y from normal distributions with unknown
     means and known variances V_X and V_Y, perform a Z-test of the
     hypothesis of equal means.  Under the null, the test statistic Z
     follows a standard normal distribution.

     With the optional argument string ALT, the alternative of interest
     can be selected.  If ALT is `"!="' or `"<>"', the null is tested
     against the two-sided alternative `mean (X) != mean (Y)'.  If alt
     is `">"', the one-sided alternative `mean (X) > mean (Y)' is used.
     Similarly for `"<"', the one-sided alternative `mean (X) < mean
     (Y)' is used.  The default is the two-sided case.

     The p-value of the test is returned in PVAL.

     If no output argument is given, the p-value of the test is
     displayed along with some information.
}

#
zeros
{
`zeros' is a built-in function

 -- Built-in Function:  zeros (X)
 -- Built-in Function:  zeros (N, M)
 -- Built-in Function:  zeros (N, M, K, ...)
 -- Built-in Function:  zeros (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 0.
     The arguments are handled the same as the arguments for `eye'.

     The optional argument CLASS, allows `zeros' to return an array of
     the specified type, for example

          val = zeros (n,m, "uint8")
}

#
zip
{
`zip' is a function from the file /usr/share/octave/3.2.3/m/miscellaneous/zip.m

 -- Function File: ENTRIES = zip (ZIPFILE, FILES)
 -- Function File: ENTRIES = zip (ZIPFILE, FILES, ROOTDIR)
     Compress the list of files and/or directories specified in FILES
     into the archive ZIPFILES in the same directory.  If ROOTDIR is
     defined the FILES is located relative to ROOTDIR rather than the
     current directory

     See also: unzip, tar
}

#
zlabel
{
`zlabel' is a function from the file /usr/share/octave/3.2.3/m/plot/zlabel.m

 -- Function File:  zlabel (STRING)
 -- Function File:  zlabel (H, STRING)
     See also: xlabel

     .
}

#
zlim
{
`zlim' is a function from the file /usr/share/octave/3.2.3/m/plot/zlim.m

 -- Function File: XL = zlim ()
 -- Function File:  zlim (XL)
 -- Function File: M = zlim ('mode')
 -- Function File:  zlim (M)
 -- Function File:  zlim (H, ...)
     Get or set the limits of the z-axis of the current plot.  Called
     without arguments `zlim' returns the z-axis limits of the current
     plot.  If passed a two element vector XL, the limits of the z-axis
     are set to this value.

     The current mode for calculation of the z-axis can be returned
     with a call `zlim ('mode')', and can be either 'auto' or 'manual'.
     The current plotting mode can be set by passing either 'auto' or
     'manual' as the argument.

     If passed an handle as the first argument, then operate on this
     handle rather than the current axes handle.

     See also: xlim, ylim, set, get, gca
}
